{"remainingRequest":"/Users/jonny/Documents/Work/test/node_modules/thread-loader/dist/cjs.js!/Users/jonny/Documents/Work/test/node_modules/babel-loader/lib/index.js!/Users/jonny/Documents/Work/test/node_modules/vuetify-loader/lib/loader.js??ref--17-0!/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/jonny/Documents/Work/test/src/views/Practise.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/jonny/Documents/Work/test/src/views/Practise.vue","mtime":1592314755731},{"path":"/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/vuetify-loader/lib/loader.js","mtime":1574476662000},{"path":"/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiL1VzZXJzL2pvbm55L0RvY3VtZW50cy9Xb3JrL3Rlc3Qvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KaW1wb3J0IEhlYWRlciBmcm9tICcuLi9jb21wb25lbnRzL0hlYWRlcic7CmltcG9ydCB7IGNvZGVtaXJyb3IgfSBmcm9tICd2dWUtY29kZW1pcnJvcic7IC8vIHJlcXVpcmUgc3R5bGVzCgppbXBvcnQgJ2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuY3NzJzsKaW1wb3J0IHsgU291cmNlRGF0YVJlcGxhY2Vmb3JFYXN5UGFyc2luZyB9IGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9mdW5jdGlvbnMnOwppbXBvcnQgKiBhcyBUeXBlQ2hlY2sgZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL1R5cGVDaGVja2luZyc7CmltcG9ydCAqIGFzIEFkdmFuY2VkVHlwZUNoZWNrIGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9BZHZhbmNlZFR5cGVDaGVja2luZyc7CmltcG9ydCAqIGFzIEJ1aWxkT3BlcmF0aW9uIGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9CdWlsZE9wZXJhdGlvbnMnOwppbXBvcnQgeyBQdXNoQXJyYXksIFB1c2hDYWxjdWxhdGlvbiwgUHVzaENvbmRpdGlvbmFsS2V5d29yZCwgUHVzaENvbmRpdGlvbiwgUHVzaEZvckxvb3AsIFB1c2hXaGlsZUxvb3AsIFB1c2hXaGlsZUxvb3BDb25kaXRpb24sIFB1c2hGb3JMb29wQXJ1Z3VtZW50cywgUHVzaEV4cHJlc3Npb24sIFB1c2hLZXl3b3JkLCBQdXNoTnVtYmVyLCBQdXNoT3BlcmF0b3IsIFB1c2hSZWFsVGltZVByaW50T3BlcmF0aW9uLCBQdXNoU3RyaW5nLCBQdXNoU3RyaW5nYW5kVmFsdWVPcGVyYXRpb24sIFB1c2hWYXJpYWJsZSwgUHVzaFZhcmlhYmxlVmFsdWUsIFB1c2hGdW5jdGlvbkRhdGEsIFB1c2hGdW5jdGlvbkV4ZWN1dGlvbiwgUHVzaFRvQXJyYXksIFB1c2hJbnB1dCB9IGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9QdXNoRnVuY3Rpb25zJzsKaW1wb3J0IHsgUmVtb3ZlQnJhY2tldHMsIENvdW50LCBSZXNldFZhbHVlLCBpc0FycmF5T3BlcmF0aW9uLCBDcmVhdGVBcnJheUVsZW1lbnQsIENhbGN1bGF0ZVZhbHVlcywgR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQsIFNldEFycmF5b3JTdHJpbmdFbGVtZW50LCBQcmludEFycmF5RWxlbWVudCwgaGFuZGxlbXVsdENvbmRpdGlvbnMsIEhhbmRsZUJsb2NrcywgU3BsaXRFbGVtZW50c0FycmF5LCBTZXRWYWx1ZXMsIFB1c2hTZXRBcnJheUluZGV4VmFsdWUsIFB1c2hHZXRBcnJheUluZGV4VmFsdWUsIFVwZGF0ZVVwZGF0ZWRfdG9rZW5zd2l0aFZhbHVlcywgR2V0Q29uZGl0aW9uVmFsdWUsIEZvckxvb3BBcnJheW9yU3RyaW5nT3V0cHV0LCBBc3NpZ25vclVwZGF0ZVZhbHVlcywgSGFuZGxlQ29uZGl0aW9ucywgZ2V0TG9vcEluZGV4U3RhcnQsIEZvckxvb3BTZXRNZXRhZGF0YSwgU2V0QXJyYXlJbmRleFZhbHVlIH0gZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL01pc2NJbXBvcnRhbnRGdW5jdGlvbnMnOwppbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnOwpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogIkhlbGxvV29ybGQiLAogIHByb3BzOiB7CiAgICBtc2c6IFN0cmluZwogIH0sCiAgY29tcHV0ZWQ6IG1hcFN0YXRlKFsnQ3VycmVudENvZGUnXSksCiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGNvZGU6ICcnLAogICAgICBDb2RlaW51c2U6ICcnLAogICAgICBvdXRwdXQ6ICcnLAogICAgICBjbTogJycsCiAgICAgIGVycm9yOiBbXSwKICAgICAgT3BlcmF0aW9uT2JqZWN0czogW10sCiAgICAgIGxpbmVieWxpbmVPdXRwdXQ6ICcnLAogICAgICBUaW1lVGFrZW46ICcnLAogICAgICBpbnB1dEluZGV4ZXM6IFtdLAogICAgICBpbnB1dDogJycsCiAgICAgIGlzRXJyb3I6ICcnLAogICAgICBMYXN0Q29uZGl0aW9uVmFsdWU6IFtdLAogICAgICBMaW5lQnlMaW5lQ29kZTogW10sCiAgICAgIGNtT3B0aW9uczogewogICAgICAgIC8vIGNvZGVtaXJyb3Igb3B0aW9ucwogICAgICAgIHRhYlNpemU6IDQsCiAgICAgICAgbGluZU51bWJlcnM6IHRydWUsCiAgICAgICAgbGluZTogdHJ1ZSwKICAgICAgICB0aGVtZTogJycKICAgICAgfQogICAgfTsKICB9LAogIGNvbXBvbmVudHM6IHsKICAgIGNvZGVtaXJyb3I6IGNvZGVtaXJyb3IsCiAgICBIZWFkZXI6IEhlYWRlcgogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIGNvbnNvbGUubG9nKCd0aGlzIGlzIGN1cnJlbnQgY29kZW1pcnJvciBvYmplY3QnLCB0aGlzLmNvZGVtaXJyb3IpOyAvLyB5b3UgY2FuIHVzZSB0aGlzLmNvZGVtaXJyb3IgdG8gZG8gc29tZXRoaW5nLi4uCiAgfSwKICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkgewogICAgdmFyIG0gPSB0aGlzLiRzdG9yZS5zdGF0ZS5DdXJyZW50Q29kZS5yZXBsYWNlKCcmbHQ7JywgJzwnKTsKICAgIG0gPSBtLnJlcGxhY2UoJyZndDsnLCAnPicpOwogICAgdGhpcy5jb2RlID0gbTsKICAgIC8qCiAgICB0aGlzLkNvZGVpbnVzZT1tCiAgICAKICAgIAogICAgaWYodGhpcy5jb2RlLmxlbmd0aD4wKQogICAgewogICAgCiAgICB0aGlzLkxpbmVCeUxpbmVDb2RlPXRoaXMuY29kZS5zcGxpdCgiXG4iKQogICAgCiAgICB0aGlzLkxpbmVCeUxpbmVDb2RlLmZvckVhY2goKGVsLGluZGV4KT0+ewogICAgICAgIAogICAgCiAgICAKICAgIGVsPSAoaW5kZXgrMSkgKyAnICAnICsgZWwKICAgIAogICAgdGhpcy5MaW5lQnlMaW5lQ29kZVtpbmRleF09ZWwgKyAnXG4nCiAgICAKICAgIAogICAgfSkKICAgIAogICAgIAogICAgIHRoaXMuTGluZUJ5TGluZUNvZGU9dGhpcy5MaW5lQnlMaW5lQ29kZS5qb2luKCdcbicpCiAgICAKICAgICB0aGlzLmNvZGU9dGhpcy5MaW5lQnlMaW5lQ29kZQogICAgCiAgICB9CiAgICAgCiAgICAqLwogIH0sCiAgbWV0aG9kczogewogICAgb25DbVJlYWR5OiBmdW5jdGlvbiBvbkNtUmVhZHkoY20pIHsKICAgICAgY29uc29sZS5sb2coJ3RoZSBlZGl0b3IgaXMgcmVhZGllZCEnLCBjbSk7CiAgICAgIHRoaXMuY20gPSBjbTsKCiAgICAgIGlmIChzY3JlZW4ud2lkdGggPCA0MjApIHsKICAgICAgICB0aGlzLmNtLnNldFNpemUoJzEwMCUnLCAzMDApOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuY20uc2V0U2l6ZSgnMTAwJScsIDUwMCk7CiAgICAgIH0KICAgIH0sCiAgICBvbkNtRm9jdXM6IGZ1bmN0aW9uIG9uQ21Gb2N1cyhjbSkgey8vdGhpcy5jbT1jbQogICAgfSwKICAgIG9uQ21Db2RlQ2hhbmdlOiBmdW5jdGlvbiBvbkNtQ29kZUNoYW5nZShuZXdDb2RlKSB7CiAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMgaXMgbmV3IGNvZGUnLCBuZXdDb2RlKQogICAgICB0aGlzLmNvZGUgPSBuZXdDb2RlOwogICAgfSwKICAgIEFkZDogZnVuY3Rpb24gQWRkKGluc2VydCkgewogICAgICB2YXIgZG9jID0gdGhpcy5jbS5nZXREb2MoKTsKICAgICAgdmFyIGN1cnNvciA9IGRvYy5nZXRDdXJzb3IoKTsKICAgICAgZG9jLnJlcGxhY2VSYW5nZShpbnNlcnQsIGN1cnNvcik7CiAgICB9LAogICAgUlVOOiBmdW5jdGlvbiBSVU4oKSB7CiAgICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgICB2YXIgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTsKICAgICAgdGhpcy5pc0Vycm9yID0gZmFsc2U7IC8vdG8gc3RvcCBhY2N1bXVsYXRpbmcgb3V0cHV0IG9uIHN1Y2Nlc2l2ZSBSVU4KCiAgICAgIHRoaXMub3V0cHV0ID0gJyc7CiAgICAgIHRoaXMuaW5wdXQgPSAnJywgdGhpcy5saW5lYnlsaW5lT3V0cHV0ID0gdGhpcy5vdXRwdXQuc3BsaXQoIlxuIik7CiAgICAgIHRoaXMuaW5wdXRJbmRleGVzID0gW107CiAgICAgIHRoaXMuZXJyb3IgPSBbXTsKICAgICAgdGhpcy5PcGVyYXRpb25PYmplY3RzID0gW107CiAgICAgIHZhciBzb3VyY2VkYXRhID0gdGhpcy5jb2RlOwogICAgICB2YXIgY2xlYW5lZF9zb3VyY2VkYXRhID0gW107CiAgICAgIHZhciBpID0gMDsKICAgICAgdmFyIHRva2VucyA9IFtdOwogICAgICB2YXIgbWl4ZWRpbXB1cml0eSA9IFtdOwogICAgICB2YXIgdXBkYXRlZF90b2tlbnMgPSBbXTsKICAgICAgdmFyIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zID0gW107CiAgICAgIHZhciB2YXJpYWJsZXNfYXJyYXkgPSBbXTsKICAgICAgdmFyIGFzc2lnbmVkX3ZhcmlhYmxlcyA9IFtdOwogICAgICB2YXIgdGVybXMgPSBbXTsKICAgICAgdmFyIHRlcm1zMiA9IFtdOwogICAgICB2YXIgb3BlcmF0aW9uID0gJyc7CiAgICAgIHZhciBDYWxjdWxhdGlvblN0YWNrID0gW107CiAgICAgIHZhciBmb3VuZFRva2VuID0gJyc7CiAgICAgIHZhciBSZUludGlhbGl6ZWRWYXJpYWJsZXMgPSBbXTsKICAgICAgdmFyIHRlbXB0aGlzID0gdGhpczsgLy9lbXB0eWluZyBhY2N1bXVsYXRlZHZhbHVlIHN0b3JlZCBmb3Igb3BlcmF0aW9ucyBsaWtlIE5hbWU9IE5hbWUrQXJyYXlbaV0KICAgICAgLy9TZWUgQXNzaWdub3JVcGRhdGVWYWx1ZXMgZnVjdGlvbiBmb3IgbW9yZQoKICAgICAgUmVzZXRWYWx1ZSgpOwoKICAgICAgZnVuY3Rpb24gQWRkT3V0cHV0KHRlbXB0aGlzLCB2YWx1ZSkgewogICAgICAgIHRlbXB0aGlzLm91dHB1dCA9IHRlbXB0aGlzLm91dHB1dCArIHZhbHVlICsgIlxuIjsKICAgICAgfSAvL3ByZXBhcmluZyBzb3VyY2VkYXRhIGZvciBlYXN5IHBhcnNpbmcgYnkgaGFuZGxpbmcgbmV3IGxpbmVzLCBlbnRlcnMgZXRjLgogICAgICAvL2NsZWFuaW5nIHVwIHRoZSBkYXRhIHRvIGdldCBteSB2ZXJzaW9uIG9mIHNvdXJjZWRhdGEuIGl0J3MgYmV0dGVyIHRvIGdldCB2ZXJzaW9uIHN1aXRhYmxlIGZvciBtZSBiZWNhdXNlIHVzZXJzIGNhbiB0eXBlIHdoYXQgdGhleSB3aXNoIGJ1dCBJIG5lZWQgdG8gbWFpbnRhaW4gCiAgICAgIC8vaW50ZWdyaXR5IG9mIHByb2dyYW0gaW4gZXZlcnkgcG9zc2libGUgY29uZGl0aW8uIFNvLiBJIGNyZWF0ZWQgbXkgb3duIGNvbmRpdGlvbiBiZWxvdwoKCiAgICAgIGZ1bmN0aW9uIEdldENsZWFuU291cmNlZGF0YShzb3VyY2VkYXRhLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGltcHVyaXRpZXMpIHsKICAgICAgICBzb3VyY2VkYXRhID0gU291cmNlRGF0YVJlcGxhY2Vmb3JFYXN5UGFyc2luZyhzb3VyY2VkYXRhKTsKICAgICAgICBzb3VyY2VkYXRhLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGkpIHsKICAgICAgICAgIC8vZmluZGluZyB0aGUgZWxlbWVudHMgd2hpY2ggaGFzID0iIGluIGl0IHNvIHRoYXQgdG8gc2VwcmF0ZSB0aGVtIGUuZy4gYW5uYT0ic3dhbmFuZCIgYWxzbyBmaW5kaW5nIHRoZSBlbGVtZW50cyB3aGljaCBzdGFydHMgd2l0aCA9LiBlLmcgIj03ODc4Nzg5MCIKICAgICAgICAgIGlmICghZWxlbWVudC5pbmNsdWRlcygnPT0nKSAmJiAoZWxlbWVudC5pbmRleE9mKCc9IicpID4gLTEgfHwgZWxlbWVudC5pbmRleE9mKCc9JykgPiAwIHx8IGVsZW1lbnQuY2hhckF0KDApID09ICI9IikgJiYgZWxlbWVudCAhPSAnPT0nKSB7CiAgICAgICAgICAgIGltcHVyaXRpZXMucHVzaChlbGVtZW50KTsgLy9wdXNoIHN1Y2ggZWxlbWVudCBhcyBpbXB1cml0eSBpbiBpbXB1cml0aWVzCgogICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBlbGVtZW50LnNwbGl0KCI9Iik7CiAgICAgICAgICAgIHZhciBpbmRleCA9IGNsZWFuZWRfc291cmNlZGF0YS5sZW5ndGg7CiAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YVtpbmRleF0gPSBlbGVtZW50c1swXTsKICAgICAgICAgICAgY2xlYW5lZF9zb3VyY2VkYXRhW2luZGV4ICsgMV0gPSAiPSI7CiAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YVtpbmRleCArIDJdID0gZWxlbWVudHNbMV07CiAgICAgICAgICB9IC8vYXMgbG9uZyBhcyBlbGVtZW50IGlzIHB1cmUsIHB1c2ggaXQgdG8gbmV3IGFuZCBjbGVhbiB2ZXJzaW9uIG9mIHNvdXJjZWRhdGEKCgogICAgICAgICAgaWYgKCFpbXB1cml0aWVzLmluY2x1ZGVzKGVsZW1lbnQpKSB7CiAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YS5wdXNoKGVsZW1lbnQpOwogICAgICAgICAgfSAvLwoKICAgICAgICB9KTsgLy9yZW1vdmluZyBlbXB0eSAiIiB2YWx1ZXMgZm9yIGZpbmFsIHZlcnNpb24gb2Ygc291cmNlZGF0YQogICAgICAgIC8vU0VDVElPTiBGSW5hbCBzb3VyY2VkYXRhIGNsZWFuaW5nCgogICAgICAgIGNsZWFuZWRfc291cmNlZGF0YSA9IGNsZWFuZWRfc291cmNlZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICAgIHJldHVybiBpdGVtICE9PSAiIjsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gY2xlYW5lZF9zb3VyY2VkYXRhOwogICAgICB9CgogICAgICB2YXIgUmVzdWx0ID0gR2V0Q2xlYW5Tb3VyY2VkYXRhKHNvdXJjZWRhdGEsIGNsZWFuZWRfc291cmNlZGF0YSwgbWl4ZWRpbXB1cml0eSk7CiAgICAgIGNsZWFuZWRfc291cmNlZGF0YSA9IFJlc3VsdDsKICAgICAgY29uc29sZS5sb2coJ2NsZWFuZWRfc291cmNlZGF0YTogJywgY2xlYW5lZF9zb3VyY2VkYXRhKTsgLy9TRUNUSU9OIC0gQ2hlY2tpbmcgZm9yIHR5cGUgb2YgY2hhcmFjdGVycwoKICAgICAgdmFyIGlzVmFyaWFibGUgPSBUeXBlQ2hlY2suaXNWYXJpYWJsZSgpOwogICAgICB2YXIgaXNOdW1iZXIgPSBUeXBlQ2hlY2suaXNOdW1iZXIoKTsKICAgICAgdmFyIGlzT3BlcmF0b3IgPSBUeXBlQ2hlY2suaXNPcGVyYXRvcigpOwogICAgICB2YXIgaXNLZXl3b3JkID0gVHlwZUNoZWNrLmlzS2V5d29yZCgpOwogICAgICB2YXIgaXNDb25kaXRpb25hbEtleXdvcmQgPSBUeXBlQ2hlY2suaXNDb25kaXRpb25hbEtleXdvcmQoKTsKICAgICAgdmFyIGlzRm9yTG9vcCA9IFR5cGVDaGVjay5pc0Zvckxvb3AoKTsKICAgICAgdmFyIGlzV2hpbGVMb29wID0gVHlwZUNoZWNrLmlzV2hpbGVMb29wKCk7CiAgICAgIHZhciBpc0Z1bmN0aW9uID0gVHlwZUNoZWNrLmlzRnVuY3Rpb24oKTsgLy9uZWVkcyB3b3JrCgogICAgICB2YXIgaXNFeHByZXNzaW9uID0gVHlwZUNoZWNrLmlzRXhwcmVzc2lvbigpOwogICAgICB2YXIgaXNBcnJheSA9IFR5cGVDaGVjay5pc0FycmF5KCk7CiAgICAgIHZhciBpc0lucHV0ID0gVHlwZUNoZWNrLmlzSW5wdXQoKTsKICAgICAgdmFyIGlzU2V0QXJyYXlJbmRleFZhbHVlID0gVHlwZUNoZWNrLmlzU2V0QXJyYXlJbmRleFZhbHVlKCk7IC8vIGNvbnN0IGlzRW1wdHlBcnJheUluaXQgPSBUeXBlQ2hlY2suaXNFbXB0eUFycmF5SW5pdCgpCgogICAgICB2YXIgaXNTdHJpbmcgPSBUeXBlQ2hlY2suaXNTdHJpbmcoKTsKICAgICAgdmFyIGlzRW1wdHlTdHJpbmdvckNoYXIgPSBUeXBlQ2hlY2suaXNFbXB0eVN0cmluZ29yQ2hhcigpOwogICAgICB2YXIgaXNQdXJlRXZhbCA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzUHVyZUV2YWwoKTsgLy9pZiBwYXJzZXIgZW5jb3VudGVycyBhbnl0aGluZyBsaWtlICgiIG9yICgsIHRoZW4gdGhhdCdzIGEgcmVhbHRpbWUgcHJpbnQuIAogICAgICAvL2J1aWxkc3RyaW5nIHdpbGwgYmUgYXBwbGllZCBub3cgdG8gY3JlYXRlIGEgc3RyaW5nIGFuZCBwdXNoIGl0IGludG8gdG9rZW5zCgogICAgICB2YXIgaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcgPSBBZHZhbmNlZFR5cGVDaGVjay5pc1JlYWxUaW1lUHJpbnRNdWx0aXBsZVN0cmluZygpOwogICAgICB2YXIgaXNTdHJpbmdhbmRWYWx1ZSA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzU3RyaW5nYW5kVmFsdWUoKTsKICAgICAgdmFyIGlzQ2FsY3VsYXRpb24gPSBBZHZhbmNlZFR5cGVDaGVjay5pc0NhbGN1bGF0aW9uKCk7CiAgICAgIHZhciBpc0RpcmVjdFByaW50QXJpdGhtZXRpYyA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzRGlyZWN0UHJpbnRBcml0aG1ldGljKCk7IC8vU0VDVElPTiBCdWlsZCBPcGVyYXRpb25zIAoKICAgICAgdmFyIEJ1aWxkU3RyaW5nID0gQnVpbGRPcGVyYXRpb24uQnVpbGRTdHJpbmcoKTsKICAgICAgdmFyIEJ1aWxkQXJyYXkgPSBCdWlsZE9wZXJhdGlvbi5CdWlsZEFycmF5KCk7IC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBoYW5kbGxlIG9wZXJhdGlvbnMgbGlrZSDgpIXgpJfgpLAgKGFnZW9uZT09MTAgJiYgQXZlcmFnZUFnZTwxMDAwICYmIGFnZXR3bz4xMDAgfHwgYWdlb25lPT0xMCkgT1IgKGFnZW9uZT09MTAgKQoKICAgICAgdmFyIEJ1aWxkQ29uZGl0aW9uID0gQnVpbGRPcGVyYXRpb24uQnVpbGRDb25kaXRpb24oKTsgLy9UaGlzIHdpbGwgcnVuIGZvciBldmVyeSBwcmludCBzdGF0ZW1lbnQgZW5jb3VudGVyZWQgaW4gdGhlIHByb2dyYW0sIG5vdCBqdXN0IGZvciBsb29wcwoKICAgICAgZnVuY3Rpb24gSWZUb2tlblByaW50KFRva2VucywgdXBkYXRlZF90b2tlbnMsIGosIGdsb2JhbCwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IpIHsKICAgICAgICB2YXIgdG9rZW4gPSBUb2tlbnNbal0udmFsdWU7CiAgICAgICAgdmFyIE5leHRUb2tlblZhbHVlID0gVG9rZW5zW2ogKyAxXS52YWx1ZTsgLy9OZXh0VG9rZW5WYWx1ZSA9IE5leHRUb2tlblZhbHVlLnJlcGxhY2UoIisiLCAnICsgJykKCiAgICAgICAgdmFyIFN0cmluZ1ZhciA9IFtdOwogICAgICAgIHZhciBiID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICBpZiAoaXNWYXJpYWJsZShiKSAmJiAhdmFyaWFibGVzX2FycmF5LmluY2x1ZGVzKGIpKSB7CiAgICAgICAgICB2YXJpYWJsZXNfYXJyYXkucHVzaChiKTsgLy8gCiAgICAgICAgfSAvL1NFQ1RJT04gLSBPdXRwdXR0aW5nIHRoZSBjb2RlCiAgICAgICAgLy8gZmluZGluZyB0aGUgcmVsdmFudCB2YWx1ZSBhbmQgdGhlbiBvdXRwdXQgaXQgYXMgSFRNTAogICAgICAgIC8vVGhpcyBsb29wIGlzIG9ubHkgZm9yIHByaW50aW5nIGRpcmVjdCB2YWx1ZXMgbGlrZSBwcmludChuYW1lKSwgcHJpbnQoYXJyYXkpCgoKICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaSkgewogICAgICAgICAgaWYgKGVsLm5hbWUgPT0gYikgewogICAgICAgICAgICAvL2ZvciBjYWxjdWxhdGlvbnMgbGlrZSB4PWFnZW9uZSthZ2V0d28KICAgICAgICAgICAgLy9JZiB3ZSBoYXZlIGFscmVhZHkgY2FsdWN1bGF0ZWQgdmFsdWUsIHVzZSB0aGF0IG9yIGVsc2UgbW92ZSBmb3J3YXJkCiAgICAgICAgICAgIGlmIChhc3NpZ25lZF92YXJpYWJsZXMuaW5jbHVkZXMoZWwpIHx8IGFzc2lnbmVkX3ZhcmlhYmxlcy5pbmNsdWRlcyhlbC5uYW1lKSkgewogICAgICAgICAgICAgIEFkZE91dHB1dChnbG9iYWwsIGVsLnZhbHVlKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoZWwudmFsdWUpKSB7CiAgICAgICAgICAgICAgICBBZGRPdXRwdXQoZ2xvYmFsLCBlbC52YWx1ZSk7CiAgICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbC5uYW1lKTsKICAgICAgICAgICAgICB9IC8vb3BlcmF0aW9ucyBsaWtlIGFnZT0yMDIwLTE5OTYKICAgICAgICAgICAgICBlbHNlIGlmIChpc1B1cmVFdmFsKGVsLnZhbHVlKSkgewogICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0cHVyZSA9IGV2YWwoZWwudmFsdWUpOwogICAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IG91dHB1dHB1cmU7CiAgICAgICAgICAgICAgICAgIEFkZE91dHB1dChnbG9iYWwsIGVsLnZhbHVlKTsKICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgICAgICB9IC8vb3BlcmF0aW9ucyBsaWtlIG5hbWU9InN3YW5hbmQga2FkYW0iLCB2YXJpYWJsZSBhc3NpZ25tZW50cyBhcyBzdHJpbmdzCiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNQdXJlRXZhbChlbC52YWx1ZSkgJiYgIWlzTnVtYmVyKGVsLnZhbHVlKSkgewogICAgICAgICAgICAgICAgICAgIGlmICghKGVsLm5hbWUuaW5jbHVkZXMoJ10nKSAmJiBlbC5uYW1lLmluY2x1ZGVzKCdbJykpKSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudHlwZSA9PSAnQXJyYXknKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC52YWx1ZS5pbmNsdWRlcygnWycpID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZWwudmFsdWUgPSAnWycgKyBlbC52YWx1ZS50b1N0cmluZygpICsgJ10nOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgQWRkT3V0cHV0KGdsb2JhbCwgZWwudmFsdWUpOwogICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gLy8gd29yayB0byBiZSBjb250aW51ZWQKCiAgICAgICAgfSk7IC8vQU5DSE9SIC0gQ09ORElUSU9OIDIKCiAgICAgICAgaWYgKFRva2Vuc1tqICsgMV0udHlwZSA9PSAnQXJyYXknKSB7CiAgICAgICAgICAvL1RvIHJ1biBvbmx5IGlmIGl0ZXJhdG9yIGlzIHByZXNlbnQKICAgICAgICAgIC8vVGhpcyBydW5zIG9uIGZvciBsb29wIC0gUHJpbnQoQXJyYXlbYV0pIGV0YwogICAgICAgICAgLy90aGlzIHJ1bnMgb25seSBpZiBmb3IoaSkgYW5kIGluIHRoZSBsb29wLCBhcnJheVtpXSwgbm90IG9uIGFycmF5W3hdLiBJdGVyYXRvciBhbmQgaW5kZXggc2hvdWxkIGJlIHNhbWUKICAgICAgICAgIGlmIChpdGVyYXRvciAhPSB1bmRlZmluZWQgJiYgVG9rZW5zW2ogKyAxXS5JbmRleElucHV0ID09IE9yaWdpbmFsSXRlcmF0b3IpIHsKICAgICAgICAgICAgdmFyIFZhbHVlID0gTmV4dFRva2VuVmFsdWU7IC8vIGNvbnNvbGUubG9nKCdWYWx1ZTogJywgVmFsdWUpOwoKICAgICAgICAgICAgdmFyIEFycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChWYWx1ZSwgaXRlcmF0b3IpOwogICAgICAgICAgICB2YXIgb3V0cHV0ID0gR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2Vucyk7CiAgICAgICAgICAgIEFkZE91dHB1dChnbG9iYWwsIG91dHB1dCk7CiAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKFRva2Vuc1tqICsgMV0pOwogICAgICAgICAgfSAvL1RoaXMgcnVucyB0byBQcmludChBcnJheVsyXSkgbGlrZSBzcGVjaWZpYyBhcnJheSB2YWx1ZXMKICAgICAgICAgIGVsc2UgaWYgKFRva2Vuc1tqICsgMV0uSW5kZXhJbnB1dCAhPSBPcmlnaW5hbEl0ZXJhdG9yKSB7CiAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICB2YXIgX1ZhbHVlID0gTmV4dFRva2VuVmFsdWU7CiAgICAgICAgICAgICAgdmFyIEluZGV4VG9DaGFuZ2UgPSBUb2tlbnNbaiArIDFdLkluZGV4SW5wdXQ7CgogICAgICAgICAgICAgIHZhciBfQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KF9WYWx1ZSwgSW5kZXhUb0NoYW5nZSk7CgogICAgICAgICAgICAgIHZhciBfZWxlbWVudCA9IF9BcnJheUVsZW1lbnQucmVwbGFjZSgnXScsICcnKTsKCiAgICAgICAgICAgICAgdmFyIFNwbGl0ID0gX2VsZW1lbnQuc3BsaXQoJ1snKTsKCiAgICAgICAgICAgICAgaWYgKFNwbGl0WzFdLmluY2x1ZGVzKCctJykgfHwgU3BsaXRbMV0uaW5jbHVkZXMoJysnKSkgewogICAgICAgICAgICAgICAgdmFyIF9vdXRwdXQyID0gQ2FsY3VsYXRlVmFsdWVzKFNwbGl0WzFdLCBqLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgICAgICAgU3BsaXRbMV0gPSBfb3V0cHV0MjsKICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpICsgJ10nOwogICAgICAgICAgICAgICAgX0FycmF5RWxlbWVudCA9IFNwbGl0OyAvL2NvbnNvbGUubG9nKCdBcnJheUVsZW1lbnQ6ICcsIEFycmF5RWxlbWVudCk7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICB2YXIgX3Rva2VuID0gdXBkYXRlZF90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IFNwbGl0WzFdOwogICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICBpZiAoX3Rva2VuICE9IHVuZGVmaW5lZCAmJiBPcmlnaW5hbEl0ZXJhdG9yICE9IFNwbGl0WzFdKSB7CiAgICAgICAgICAgICAgICBTcGxpdFsxXSA9IF90b2tlbi52YWx1ZTsKICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpICsgJ10nOwogICAgICAgICAgICAgICAgX0FycmF5RWxlbWVudCA9IFNwbGl0OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBfQXJyYXlFbGVtZW50ID0gX0FycmF5RWxlbWVudDsgLy9jb25zb2xlLmxvZygnQXJyYXlFbGVtZW50OiAnLCBBcnJheUVsZW1lbnQpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdmFyIF9vdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChfQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgICAgIEFkZE91dHB1dChnbG9iYWwsIF9vdXRwdXQpOwogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvdXRwdXQ6ICcsIF9vdXRwdXQpOwogICAgICAgICAgICB9CiAgICAgICAgfSAvL3ByaW50aW5nIGRpcmVjdCBudW1iZXJzIGFuZCBkaXJlY3QgY2FsY3VsdGlvbnMgbGlrZSBwcmludCgxMCksIHByaW50KDEwKjEwKQogICAgICAgIGVsc2UgaWYgKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIChpc1B1cmVFdmFsKFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkgfHwgaXNOdW1iZXIoUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSkpIHsKICAgICAgICAgICAgTmV4dFRva2VuVmFsdWUgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7CgogICAgICAgICAgICBpZiAoaXNOdW1iZXIoTmV4dFRva2VuVmFsdWUpICYmIFRva2Vuc1tqICsgMV0udHlwZSAhPSAnQ2FsY3VsYXRpb24nKSB7CiAgICAgICAgICAgICAgQWRkT3V0cHV0KGdsb2JhbCwgTmV4dFRva2VuVmFsdWUpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciBhID0gZXZhbChOZXh0VG9rZW5WYWx1ZSk7CiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2E6ICcsIGEpOwogICAgICAgICAgICAgIEFkZE91dHB1dChnbG9iYWwsIGEpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vZm9yb3BlcmF0aW9ucyBsaWtlIHByaW50KCd5b3UgbGl2ZSwgeW91IGxlYXJuJykKICAgICAgICAgIGVsc2UgaWYgKFRva2Vuc1tqICsgMV0ubW9kZSA9PSAiUmVhbFRpbWVQcmludCIgJiYgIU5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCcrJykgJiYgIU5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCc9JykpIHsKICAgICAgICAgICAgICB2YXIgX291dHB1dDMgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7CgogICAgICAgICAgICAgIF9vdXRwdXQzID0gX291dHB1dDMucmVwbGFjZSgvIi9nLCAnJyk7CiAgICAgICAgICAgICAgX291dHB1dDMgPSBfb3V0cHV0My5yZXBsYWNlKC8nL2csICcnKTsKICAgICAgICAgICAgICBBZGRPdXRwdXQoZ2xvYmFsLCBfb3V0cHV0MyArICJcbiIpOwogICAgICAgICAgICB9IC8vb3BlcmF0aW9ucyBsaWtlIHByaW50KEFnZSArICdpcyB5b3VuZyBhZ2UnKQogICAgICAgICAgICBlbHNlIGlmIChUb2tlbnNbaiArIDFdLm1vZGUgPT0gIlJlYWxUaW1lUHJpbnQiICYmIE5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCcrJykpIHsKICAgICAgICAgICAgICAgIHZhciB4ID0gU3BsaXRFbGVtZW50c0FycmF5KE5leHRUb2tlblZhbHVlKTsKICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyh4LCB1cGRhdGVkX3Rva2Vucyk7CiAgICAgICAgICAgICAgICBTdHJpbmdWYXIgPSBTdHJpbmdWYXIuam9pbignJyk7CiAgICAgICAgICAgICAgICBTdHJpbmdWYXIgPSBTdHJpbmdWYXIuc3BsaXQoIisiKTsKCiAgICAgICAgICAgICAgICB2YXIgX291dHB1dDQgPSBTdHJpbmdWYXIuam9pbignICcpOwoKICAgICAgICAgICAgICAgIF9vdXRwdXQ0ID0gUmVtb3ZlQnJhY2tldHMoX291dHB1dDQpOwogICAgICAgICAgICAgICAgQWRkT3V0cHV0KGdsb2JhbCwgX291dHB1dDQgKyAiXG4iKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsY3VsYXRpb24oUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSAmJiBUb2tlbnNbaiArIDFdLm1vZGUgIT0gIlJlYWxUaW1lUHJpbnQiKSB7CiAgICAgICAgICAgICAgICBOZXh0VG9rZW5WYWx1ZSA9IFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKTsKCiAgICAgICAgICAgICAgICB2YXIgX291dHB1dDUgPSBDYWxjdWxhdGVWYWx1ZXMoTmV4dFRva2VuVmFsdWUsIGosIHVwZGF0ZWRfdG9rZW5zKTsKCiAgICAgICAgICAgICAgICBBZGRPdXRwdXQoZ2xvYmFsLCBfb3V0cHV0NSArICJcbiIpOwogICAgICAgICAgICAgIH0KICAgICAgfSAvL0VORCBPRiBGdW5jdGlvbnMgYW5kIEltcG9ydGVkIEZ1bmN0aW9ucwogICAgICAvL1NFQ1RJT04gLSBQYXJzaW5nIFNUQVJUUyBoZXJlCiAgICAgIC8vU0VDVElPTiAtIENoZWNraW5nIGVhY2ggdG9rZW4gYW5kIGFkZGluZyB0byB0b2tlbnMgYXJyYXkKCgogICAgICB2YXIgdmFyaWFibGVBcnJheSA9IFtdOyAvL1RPIFJFTU9WRSBEVVBMSUNBVEUgVkFSSUFCTEVTLCBTRUUgNDgyCgogICAgICBmdW5jdGlvbiBQYXJzZShjbGVhbmVkX3NvdXJjZWRhdGEsIGkpIHsKICAgICAgICB2YXIgZWxlbWVudCA9IGNsZWFuZWRfc291cmNlZGF0YVtpXTsKICAgICAgICB2YXIgc3RyaW5nID0gW107CgogICAgICAgIGlmIChpc1ZhcmlhYmxlKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgIGlmIChjbGVhbmVkX3NvdXJjZWRhdGFbaSArIDFdID09ICc9JykgewogICAgICAgICAgICBQdXNoVmFyaWFibGUoZWxlbWVudCwgdG9rZW5zKTsKCiAgICAgICAgICAgIGlmICh2YXJpYWJsZUFycmF5LmluY2x1ZGVzKGVsZW1lbnQpKSB7CiAgICAgICAgICAgICAgLy8gbGV0IFVwZGF0ZUVsZW1lbnRWYWx1ZSA9IGVsZW1lbnQKICAgICAgICAgICAgICB2YXIgeCA9IHRva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGVsLnZhbHVlID09IGVsZW1lbnQ7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdG9rZW5zLmluZGV4T2YoeCk7CiAgICAgICAgICAgICAgUmVJbnRpYWxpemVkVmFyaWFibGVzLnB1c2goewogICAgICAgICAgICAgICAgbmFtZTogZWxlbWVudAogICAgICAgICAgICAgIH0pOyAvLwogICAgICAgICAgICAgIC8vdG9rZW5zW2luZGV4KzJdLnZhbHVlPSBjbGVhbmVkX3NvdXJjZWRhdGFbaSsyXQogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXJpYWJsZUFycmF5LnB1c2goZWxlbWVudCk7CiAgICAgICAgICB9IGVsc2UgaWYgKGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0gPT0gJz0nKSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlbGVtZW50OiAnLCBlbGVtZW50KTsKICAgICAgICAgICAgUHVzaFZhcmlhYmxlVmFsdWUoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgIFB1c2hOdW1iZXIoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICB9IGVsc2UgaWYgKGlzRW1wdHlTdHJpbmdvckNoYXIoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgaWYgKGVsZW1lbnQubGVuZ3RoID4gMSAmJiAoZWxlbWVudC5jaGFyQXQoMCkgPT0gIiciIHx8IGVsZW1lbnQuY2hhckF0KDApID09ICciJykpIHsKICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmVwbGFjZSgvWyciXSsvZywgJycpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZWxlbWVudCA9ICIgIjsKICAgICAgICAgIH0KCiAgICAgICAgICBQdXNoVmFyaWFibGVWYWx1ZShlbGVtZW50LCB0b2tlbnMpOwogICAgICAgIH0gZWxzZSBpZiAoaXNJbnB1dChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICBQdXNoSW5wdXQoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgIH0gZWxzZSBpZiAoaXNPcGVyYXRvcihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICBQdXNoT3BlcmF0b3IoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICB9IGVsc2UgaWYgKGlzS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICBQdXNoS2V5d29yZChlbGVtZW50LCB0b2tlbnMpOwogICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICBQdXNoRnVuY3Rpb25EYXRhKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgICAgICB9IC8vY2hlY2sgaWYgaXQgYWNjcGV0cyBBcnJ5WzJhXSBhcyBpbmRleCA6IAogICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICBpZiAoZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGggLSAxKSA9PSAnXScpIHsKICAgICAgICAgICAgICBQdXNoQXJyYXkoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB2YXIgQnVpbHRBcnJheSA9IEJ1aWxkQXJyYXkoZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKTsKICAgICAgICAgICAgICBQdXNoQXJyYXkoQnVpbHRBcnJheSwgdG9rZW5zKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSAvL2ZvciBOdW1iZXJzW2FdPXgKICAgICAgICAgIGVsc2UgaWYgKGlzU2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgIFB1c2hTZXRBcnJheUluZGV4VmFsdWUoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgICB9IC8vZm9yIHg9TnVtYmVyc1thXQogICAgICAgICAgICBlbHNlIGlmIChpc1NldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICBQdXNoR2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ29uZGl0aW9uYWxLZXl3b3JkKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgIGlmIChpc1doaWxlTG9vcChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgIFB1c2hXaGlsZUxvb3AoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOyAvLyBQdXNoV2hpbGVMb29wQ29uZGl0aW9uKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgUHVzaENvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHZhciBmb3VuZGNvbmRpdGlvbiA9IEJ1aWxkQ29uZGl0aW9uKGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7IC8vIGNvbnNvbGUubG9nKCdmb3VuZGNvbmRpdGlvbjogJywgZm91bmRjb25kaXRpb24pOwoKICAgICAgICAgICAgICAgIFB1c2hDb25kaXRpb24oZm91bmRjb25kaXRpb24sIHRva2Vucyk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmluY2x1ZGVzKCfgpKrgpYHgpLYnKSkgewogICAgICAgICAgICAgICAgUHVzaFRvQXJyYXkoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRm9yTG9vcChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICBQdXNoRm9yTG9vcChlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgICAgICAgUHVzaEZvckxvb3BBcnVndW1lbnRzKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKTsKICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICBuYW1lOiBjbGVhbmVkX3NvdXJjZWRhdGFbaSArIDFdLAogICAgICAgICAgICAgICAgICB2YWx1ZTogMCwKICAgICAgICAgICAgICAgICAgdHlwZTogJ0Zvckxvb3BJdGVyYXRvcicKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxjdWxhdGlvbihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICB2YXIgX2VsZW1lbnQyID0gJyc7CgogICAgICAgICAgICAgICAgaWYgKGNsZWFuZWRfc291cmNlZGF0YVtpICsgMV0gIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcGVyZm9ybSBsb25nIG9wZXJhdGlvbnMgbGlrZSBBdmVyYWdlQWdlPShhZ2VvbmUrYWdldHdvKS8yICsgKGFnZW9uZSthZ2V0d28pKjIKICAgICAgICAgICAgICAgICAgd2hpbGUgKGlzQ2FsY3VsYXRpb24oY2xlYW5lZF9zb3VyY2VkYXRhW2ldKSkgewogICAgICAgICAgICAgICAgICAgIF9lbGVtZW50MiA9IF9lbGVtZW50MiArIGNsZWFuZWRfc291cmNlZGF0YVtpXTsKICAgICAgICAgICAgICAgICAgICBpKys7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gLy9QdXNoQ2FsY3VsYXRpb24oZWxlbWVudCx0b2tlbnMpCiAgICAgICAgICAgICAgICAvLyAgCgoKICAgICAgICAgICAgICAgIHRlcm1zID0gX2VsZW1lbnQyLnNwbGl0KCcnKTsgLy9yZW1vdmluZyB0aGUgIigiIiBhbmQgIikiCgogICAgICAgICAgICAgICAgdmFyIENsZWFuZWRFbGVtZW50ID0gUmVtb3ZlQnJhY2tldHMoX2VsZW1lbnQyKTsgLy8gdG8gc3RvcCBwcmV2ZW50aW9uIG9mIGV4cHJlc3Npb25zIGxpa2UgaXMiKyBnZXR0aW5nIGFkZGVkIGFzIGEgY2FsY3VsYXRpb24KCiAgICAgICAgICAgICAgICBpZiAoIUNsZWFuZWRFbGVtZW50LmluY2x1ZGVzKCciJykgJiYgX2VsZW1lbnQyLmNoYXJBdCgwKSAhPSAnLycgJiYgX2VsZW1lbnQyLmNoYXJBdCgwKSAhPSAnKicgJiYgX2VsZW1lbnQyLmNoYXJBdCgwKSAhPSAiJyIpIHsKICAgICAgICAgICAgICAgICAgUHVzaENhbGN1bGF0aW9uKF9lbGVtZW50MiwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gLy9maW5kaW5nIG9wZXJhdGlvbnMgbGlrZSBwcmludCgic3dhbmFuZCIpLiBUaGUgcmVhbHRpbWVwcmludCBvcGVyYXRpb25zCiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICB2YXIgZm91bmRTdHJpbmcgPSAnJzsKICAgICAgICAgICAgICAgICAgdmFyIGsgPSBpOyAvLyAgY29uc29sZS5sb2coJ2VsZW1lbnQ6ICcsIGVsZW1lbnQpOwoKICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbkVuZCA9IGVsZW1lbnQuY2hhckF0KGVsZW1lbnQubGVuZ3RoIC0gMSkgKyBlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDIpOyAvL2NvbnNvbGUubG9nKCdjb25kaXRpb25FbmQ6ICcsIGNvbmRpdGlvbkVuZCk7CgogICAgICAgICAgICAgICAgICB2YXIgZmxhZyA9IDA7CgogICAgICAgICAgICAgICAgICBmb3IgKGs7IGsgPCBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOyBrKyspIHsKICAgICAgICAgICAgICAgICAgICB2YXIgX2VsZW1lbnQzID0gY2xlYW5lZF9zb3VyY2VkYXRhW2tdOwoKICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbmRpdGlvbkVuZCA9IF9lbGVtZW50My5jaGFyQXQoX2VsZW1lbnQzLmxlbmd0aCAtIDEpICsgX2VsZW1lbnQzLmNoYXJBdChfZWxlbWVudDMubGVuZ3RoIC0gMik7CgogICAgICAgICAgICAgICAgICAgIGlmIChfZWxlbWVudDMuaW5jbHVkZXMoJ+CkpuClgeCkueCksOCkvuCkkycpIHx8IF9lbGVtZW50My5pbmNsdWRlcygn4KSw4KSa4KSo4KS+JykgfHwgX2VsZW1lbnQzLmluY2x1ZGVzKCfgpIXgpKjgpY3gpK/gpKXgpL4nKSB8fCBfZWxlbWVudDMuaW5jbHVkZXMoJ+Ckh+CkqOCkquClgeCknycpIHx8IF9lbGVtZW50My5pbmNsdWRlcygn4KSq4KWB4KS2JykgfHwgX2VsZW1lbnQzLmluY2x1ZGVzKCfgpKrgpY3gpLDgpL/gpILgpJ8nKSB8fCBfZWxlbWVudDMuaW5jbHVkZXMoJ+CkheCkl+CksCcpIHx8IGNsZWFuZWRfc291cmNlZGF0YVtrICsgMV0gPT0gJz0nIHx8IF9lbGVtZW50MyA9PSAnfScpIHsKICAgICAgICAgICAgICAgICAgICAgIC8vZm91bmRTdHJpbmc9Zm91bmRTdHJpbmcrICAnICcrIGNsZWFuZWRfc291cmNlZGF0YVtrXQogICAgICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb25kaXRpb25FbmQgPT0gJykiJykgewogICAgICAgICAgICAgICAgICAgICAgZm91bmRTdHJpbmcgPSBmb3VuZFN0cmluZyArICcgJyArIGNsZWFuZWRfc291cmNlZGF0YVtrXTsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZyA9PSAxKSB7CiAgICAgICAgICAgICAgICAgICAgICBmb3VuZFN0cmluZyA9IGZvdW5kU3RyaW5nICsgJyAnICsgY2xlYW5lZF9zb3VyY2VkYXRhW2tdOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZyA9PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBmb3VuZFN0cmluZyA9IGNsZWFuZWRfc291cmNlZGF0YVtrXTsKICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSAxOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZFN0cmluZy5pbmNsdWRlcygiPiIpICYmICFmb3VuZFN0cmluZy5pbmNsdWRlcygnLycpICYmICFmb3VuZFN0cmluZy5pbmNsdWRlcygnKicpICYmICFmb3VuZFN0cmluZy5pbmNsdWRlcygnPCcpICYmICFmb3VuZFN0cmluZy5pbmNsdWRlcygnPT0nKSkgewogICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZvdW5kU3RyaW5nOiAnLCBmb3VuZFN0cmluZyk7CiAgICAgICAgICAgICAgICAgICAgUHVzaFJlYWxUaW1lUHJpbnRPcGVyYXRpb24oZm91bmRTdHJpbmcsIHRva2Vucyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gLy9zdG9yaW5nIG9ubHkgdGhlIHN0cmluZyB2YWx1ZXMgdG8gdG9rZW5zICggbm90IHRoZSBzdHJpbmdzIGluIHByaW50IHN0YXRlbWVudHMpCiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhlbGVtZW50KSkgewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlbGVtZW50OiAnLCBlbGVtZW50KTsKICAgICAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlZFN0cmluZyA9IEJ1aWxkU3RyaW5nKGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NhbGN1bGF0ZWRTdHJpbmc6ICcsIGNhbGN1bGF0ZWRTdHJpbmcpOwogICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRTdHJpbmcgPSBjYWxjdWxhdGVkU3RyaW5nLnJlcGxhY2UoL1snIl0rL2csICcnKTsKICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGN1bGF0ZWRTdHJpbmcuaW5jbHVkZXMoIuCkquCljeCksOCkv+CkguCknyIpKSBQdXNoU3RyaW5nKGNhbGN1bGF0ZWRTdHJpbmcsIHRva2Vucyk7CiAgICAgICAgICAgICAgICAgIH0gLy9Gb3VuZCBTb2x1dGlvbiB1c2luZyByZWdleHAtIHByaW50KGEpIHdpdGhvdXQgc3BhY2UgaXMgZ2V0dGluZyBhY2NlcHRlZCBhcyBleHByZXNzaW9uCiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eKD89Lio/4KSq4KWN4KSw4KS/4KSC4KSfKSg/PS4qW2Etel0pLy50ZXN0KGVsZW1lbnQpKSB7CiAgICAgICAgICAgICAgICAgICAgICBQdXNoS2V5d29yZChlbGVtZW50LnNsaWNlKDAsIDYpLCB0b2tlbnMpOyAvL1B1c2hpbmcgcHJpbnQga2V5d29yZCBvbmx5CgogICAgICAgICAgICAgICAgICAgICAgUHVzaEV4cHJlc3Npb24oZWxlbWVudC5zbGljZSg2KSwgdG9rZW5zKTsgLy9QdXNoaW5nIHJlbWFpbmluZyBleHByZXNzaW9uIGxpa2UgKGEpLCAoZ2FnYWtzKSBldGMKICAgICAgICAgICAgICAgICAgICB9IC8vZXJyb3IgcHJvbmUgY2hhbmdlIG1hZGUgaGVyZS0gUHVzaGluZyBleHByZXNzaW9uIGluIGhlcmUKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0V4cHJlc3Npb24oZWxlbWVudCkgPT0gdHJ1ZSAmJiAhaXNDYWxjdWxhdGlvbihlbGVtZW50KSAmJiAhZWxlbWVudC5pbmNsdWRlcygnWycpICYmICFlbGVtZW50LmluY2x1ZGVzKCddJykgJiYgIWlzQ29uZGl0aW9uYWxLZXl3b3JkKGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0pICYmIGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0gIT0gJ+CkruClhycgJiYgY2xlYW5lZF9zb3VyY2VkYXRhW2kgLSAxXSAhPSAn4KSw4KSa4KSo4KS+JykgewogICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ2hlY2tGdW5jdGlvbkV4cHJlc3Npb24gPSBlbGVtZW50LnNwbGl0KCcoJyk7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXNzZWRWYWx1ZXMgPSBSZW1vdmVCcmFja2V0cyhDaGVja0Z1bmN0aW9uRXhwcmVzc2lvblsxXSk7CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZFZhbHVlcyA9IHBhc3NlZFZhbHVlcy5zcGxpdCgnLCcpOwoKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90b2tlbjIgPSB0b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwudmFsdWUgPT0gQ2hlY2tGdW5jdGlvbkV4cHJlc3Npb25bMF07CiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90b2tlbjIgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEZ1bmN0aW9uRXhlY3V0aW9uKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCBwYXNzZWRWYWx1ZXMpOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNFeHByZXNzaW9uKGVsZW1lbnQpID09IHRydWUgJiYgZWxlbWVudC5pbmNsdWRlcygnWycpICYmIGVsZW1lbnQuaW5jbHVkZXMoJ10nKSkgewogICAgICAgICAgICAgICAgICAgICAgICBQdXNoQXJyYXkoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzS2V5d29yZChlbGVtZW50KSAmJiAhaXNOdW1iZXIoZWxlbWVudCkgJiYgIWlzVmFyaWFibGUoZWxlbWVudCkgJiYgIWlzRXhwcmVzc2lvbihlbGVtZW50KSAmJiAhaXNPcGVyYXRvcihlbGVtZW50KSkgey8vQU5DSE9SIAoKICAgICAgICAgICAgICAgICAgICAgICAgLypIbmFkbGluZyBJbXB1cml0eSBlcnJvci1UaGUgbWFpbiBwcm9ibGVtIGlzIGZpZ3VyaW5nIG91dCBob3cgdG8gc29sdmUgIj03MDAwIiBsaWtlIHRoaW5ncwogICAgICAgICAgICAgICAgICAgICAgICBpbnN0ZWFkIGFza2luZyBkZXZlbG9wZXJzIHRvIGFkZCBzcGFjZSBtYW51YWxseQogICAgICAgICAgICAgICAgICAgICAgICBIYW5kbGluZyBBbHBoYW51bWVyaWMgc3RyaW5ncyB0byBzb2x2ZSBpc3N1ZXMgbGlrZSAnIGFubmE9MjM2MjkzNCcKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltcHVyaXR5ID0gZWxlbWVudC5zcGxpdCgnPScpCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaW5kU3RyaW5nID0gaW1wdXJpdHlbMV0KICAgICAgICAgICAgICAgICAgICAgICAgLy90byBhY2NlcHQgbG9uZyBudW1iZXJzIGkuZSBhPTc0OTM3NDU5Mzc0NTkzNwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShpbXB1cml0eVswXSkgJiYgaXNOdW1iZXIoaW1wdXJpdHlbMV0pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHlbMl0gPSBpbXB1cml0eVsxXTsKICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHlbMV0gPSAnPSc7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgLy90byBhY2NlcHQgYT1TVFJJTkcKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoaW1wdXJpdHlbMF0pICYmIGlzVmFyaWFibGUoaW1wdXJpdHlbMV0pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHlbMl0gPSBpbXB1cml0eVsxXTsKICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHlbMV0gPSAnPSc7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHkuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4gewogICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaFZhcmlhYmxlKGVsZW1lbnQsIHRva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb250aW51ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgLy8gQU5DSE9SIAogICAgICAgICAgICAgICAgICAgICAgICAgLy9Jc3N1ZTogUmlnaHQgbm93LCBvbmx5IGlzTnVtYmVyIGlzIHJlc29sdmVkLCBhPSwgPTIzODI4cXcgYXJlbid0IHJlc29sdmVkLgogICAgICAgICAgICAgICAgICAgICAgICAvL1NvbHV0aW9uOiBXb3JrIG9uIGFsbCB0aGUgbW9kdWxlcwogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hOdW1iZXIoZWxlbWVudCwgdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgLy9BTkNIT1IgCiAgICAgICAgICAgICAgICAgICAgICAgIC8vWW91IG1pZ2h0IGhhdmUgdG8gcmVtb3ZlIHRoaXMgZXh0cmEgZmlsdGVycyBzaW5jZSB5b3UgYXJlIG9ubHkgd29ya2luZyBvbiBudW1iZXJzIChGdXR1cmUgSXNzdWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09wZXJhdG9yKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hPcGVyYXRvcihlbGVtZW50LCB0b2tlbikKICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEtleXdvcmQoZWxlbWVudCkKICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0V4cHJlc3Npb24oZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoRXhwcmVzc2lvbihlbGVtZW50LCB0b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAgICovCiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgIH0gLy9TRUNUSU9OIC0gQ2hlY2tpbmcgZWFjaCB0b2tlbiBhbmQgYWRkaW5nIHRvIHRva2VucyBhcnJheQogICAgICAvLyBQQVJTSU5HIElOSVRJQVRJT04KCgogICAgICBmb3IgKGk7IGkgPCBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICBQYXJzZShjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICB9IC8vQU5DSE9SIAogICAgICAvL0NMRUFOSU5HIFVQIFRIRSBUT0tFTlMgQVJSQVkKICAgICAgLy9SZW1vdmluZyB0b2tlbnMgd2l0aCB2YWx1ZSA9ICcnLCBJdCB3YXMgZ2VuZXJhdGVkIGR1ZSB0byAiIGNsZWFuZWRfc291cmNlZGF0YSA9IGNsZWFuZWRfc291cmNlZGF0YS5yZXBsYWNlKC8oO3xcbnxccikvZ20sICIgIikuc3BsaXQoJyAnKSIKCgogICAgICB0b2tlbnMgPSB0b2tlbnMuZmlsdGVyKGZ1bmN0aW9uIChlbCkgewogICAgICAgIHJldHVybiBlbC52YWx1ZSAhPSAnJzsKICAgICAgfSk7CiAgICAgIGNvbnNvbGUubG9nKCd0b2tlbnM6ICcsIHRva2Vucyk7IC8vU0VDVElPTiAtIFByaW50aW5nIE91dHB1dHMsIGNvbnNpZGVyaW5nIGNvbmRpdGlvbnMsIGZpbmRpbmcgdmFsdWVzIGluIHVwZGF0ZWRfdG9rZW5zCgogICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykgewogICAgICAgIC8vIENoZWNraW5nIGZvciBhc3NpZ25tZW50IG9wZXJhdG9ycwogICAgICAgIHZhciBtdXRhYmxlX3Rva2VucyA9IHRva2VuczsKICAgICAgICB2YXIgdG9rZW4gPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZTsKICAgICAgICB2YXIgdG9rZW5UeXBlID0gbXV0YWJsZV90b2tlbnNbal0udHlwZTsKICAgICAgICB2YXIgU3RyaW5nVmFyID0gW107CiAgICAgICAgdmFyIFZhcldpdGhvdXRicmFja2V0cyA9IFJlbW92ZUJyYWNrZXRzKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlKTsKICAgICAgICBWYXJXaXRob3V0YnJhY2tldHMgPSBWYXJXaXRob3V0YnJhY2tldHMucmVwbGFjZSgvIC9nLCAnJyk7CgogICAgICAgIGlmIChtdXRhYmxlX3Rva2Vuc1tqXS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKSB7CiAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUobXV0YWJsZV90b2tlbnMsIGosIGosIHVwZGF0ZWRfdG9rZW5zLCB0b2tlbnMsIE9yaWdpbmFsSXRlcmF0b3IsIGl0ZXJhdG9yKTsKICAgICAgICB9IGVsc2UgaWYgKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlID09ICc9JykgewogICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMobXV0YWJsZV90b2tlbnMsIGosIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvciwgdGhpcyk7CiAgICAgICAgfSBlbHNlIGlmICh0b2tlblR5cGUgPT0gJ1B1c2hUb0FycmF5JykgewogICAgICAgICAgKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5yZXBsYWNlKCfgpKrgpYHgpLYnLCAnJyk7CiAgICAgICAgICAgIHZhciBTcGxpdCA9IHRva2VuLnNwbGl0KCcuJyk7CiAgICAgICAgICAgIHZhciBBcnJheU5hbWUgPSBTcGxpdFswXTsKICAgICAgICAgICAgdmFyIEVsZW1lbnQgPSBSZW1vdmVCcmFja2V0cyhTcGxpdFsxXSk7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFbGVtZW50OiAnLCBFbGVtZW50KTsKICAgICAgICAgICAgdmFyIEFycmF5VG9rZW4gPSB1cGRhdGVkX3Rva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IEFycmF5TmFtZTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBcnJheVRva2VuOiAnLCBBcnJheVRva2VuKTsKICAgICAgICAgICAgdmFyIEVsZW1lbnR0b1B1c2ggPSB1cGRhdGVkX3Rva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IEVsZW1lbnQ7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBjb25zb2xlLmxvZygnRWxlbWVudHRvUHVzaDogJywgRWxlbWVudHRvUHVzaCk7CgogICAgICAgICAgICBpZiAoRWxlbWVudHRvUHVzaCA9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICBFbGVtZW50ID0gRWxlbWVudC5yZXBsYWNlKC8iL2csICIiKTsKICAgICAgICAgICAgICBFbGVtZW50ID0gRWxlbWVudC5yZXBsYWNlKC8nL2csICIiKTsKICAgICAgICAgICAgICBFbGVtZW50dG9QdXNoID0gRWxlbWVudDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBFbGVtZW50dG9QdXNoID0gRWxlbWVudHRvUHVzaC52YWx1ZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIEVsZW1lbnRJbmRleCA9IHVwZGF0ZWRfdG9rZW5zLmluZGV4T2YoQXJyYXlUb2tlbik7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFbGVtZW50SW5kZXg6ICcsIEVsZW1lbnRJbmRleCk7CiAgICAgICAgICAgIHZhciBBcnJheVZhbHVlID0gdXBkYXRlZF90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PSBBcnJheU5hbWU7CiAgICAgICAgICAgIH0pLnZhbHVlOwoKICAgICAgICAgICAgaWYgKEFycmF5VmFsdWUgPT0gJ1tdJykgewogICAgICAgICAgICAgIEFycmF5VmFsdWUgPSBBcnJheVZhbHVlLnNwbGl0KCcsJyk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBcnJheVZhbHVlOiAnLCBBcnJheVZhbHVlKTsKICAgICAgICAgICAgQXJyYXlWYWx1ZS5wdXNoKEVsZW1lbnR0b1B1c2gpOwogICAgICAgICAgICBBcnJheVZhbHVlID0gQXJyYXlWYWx1ZS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVsICE9ICdbXSc7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBjb25zb2xlLmxvZygnQXJyYXlWYWx1ZTogJywgQXJyYXlWYWx1ZSk7CiAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zW0VsZW1lbnRJbmRleF0udmFsdWUgPSBBcnJheVZhbHVlOwogICAgICAgICAgICBjb25zb2xlLmxvZygndXBkYXRlZF90b2tlbnM6ICcsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgIH0pKCk7CiAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PSAn4KSF4KSo4KWN4KSv4KSl4KS+JykgewogICAgICAgICAgdmFyIHJlc3VsdCA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2VucywgaiwgcmVzdWx0KTsKICAgICAgICAgIHZhciBTdGFydG9mQmxvY2sgPSBtdXRhYmxlX3Rva2Vuc1tqICsgMV0uc3RhcnRJbmRleDsKICAgICAgICAgIHZhciBFbmRvZkJsb2NrID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLkVuZEluZGV4OyAvL2xldCBEb2VzQW55VHJ1ZUNvbmRpdGlvbkV4aXN0cz0gdGhpcy5MYXN0Q29uZGl0aW9uVmFsdWUuZmluZChlbD0+ZWw9PXRydWUpCgogICAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHRoaXMuTGFzdENvbmRpdGlvblZhbHVlLnBvcCgpOwoKICAgICAgICAgIGlmIChsYXN0VmFsdWUgPT0gdHJ1ZSkgewogICAgICAgICAgICBqID0gRW5kb2ZCbG9jazsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHlwZSA9PSAnQWNjZXB0SW5wdXQnKSB7CiAgICAgICAgICB2YXIgU2V0SW5wdXRWYWx1ZUFzID0gbXV0YWJsZV90b2tlbnNbal0uQWNjZXB0QXM7CiAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9tcHQoJ0VudGVyIFZhbHVlIGZvciAnICsgU2V0SW5wdXRWYWx1ZUFzKTsKICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICBuYW1lOiBTZXRJbnB1dFZhbHVlQXMsCiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZQogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmICh0b2tlblR5cGUgPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgdmFyIGZ1bmN0aW9uU291cmNlRGF0YSA9IFtdOwoKICAgICAgICAgIHZhciBfcmVzdWx0ID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBqICsgMSwgZnVuY3Rpb25Tb3VyY2VEYXRhKTsKCiAgICAgICAgICBmdW5jdGlvblNvdXJjZURhdGEgPSBfcmVzdWx0LlN0b3JlUmVzdWx0OwogICAgICAgICAgZnVuY3Rpb25Tb3VyY2VEYXRhLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgIGVsLmNvbnRleHQgPSAnZnVuY3Rpb24nOwogICAgICAgICAgfSk7CiAgICAgICAgICBtdXRhYmxlX3Rva2Vuc1tqXS5Tb3VyY2VEYXRhID0gZnVuY3Rpb25Tb3VyY2VEYXRhOwogICAgICAgIH0gZWxzZSBpZiAodG9rZW5UeXBlID09ICdmdW5jdGlvbkV4ZWN1dGlvbicpIHsKICAgICAgICAgIHZhciBDb21wbGV0ZVRva2VuVmFsdWVMaXN0OwogICAgICAgICAgdmFyIHZhbHVlOwogICAgICAgICAgdmFyIEZsYWdQcmltYWxMb29wOwogICAgICAgICAgdmFyIFNvdXJjZWRhdGFUb2tlbnM7CiAgICAgICAgICB2YXIgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0OwogICAgICAgICAgdmFyIEN5Y2xlOwogICAgICAgICAgdmFyIE9yaWdpbmFsSXRlcmF0b3I7CiAgICAgICAgICB2YXIgSXRlcmF0aW9uU3RhcnQ7CiAgICAgICAgICB2YXIgaXRlcmF0b3I7CiAgICAgICAgICB2YXIgZWxlbWVudDsKICAgICAgICAgIHZhciBlbGVtZW50VmFsdWU7CiAgICAgICAgICB2YXIgTmVzdGVkRmxhZ1ByaW1hbExvb3A7CiAgICAgICAgICB2YXIgTmVzdGVkU291cmNlZGF0YVRva2VuczsKICAgICAgICAgIHZhciBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQ7CiAgICAgICAgICB2YXIgTmVzdGVkQ3ljbGU7CiAgICAgICAgICB2YXIgTmVzdGVkT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgIHZhciBOZXN0ZWRJdGVyYXRpb25TdGFydDsKICAgICAgICAgIHZhciBOZXN0ZWRpdGVyYXRvcjsKICAgICAgICAgIHZhciBOZXN0ZWRlbGVtZW50OwogICAgICAgICAgdmFyIE5lc3RlZGVsZW1lbnRWYWx1ZTsKICAgICAgICAgIHZhciB2YWx1ZTsKICAgICAgICAgIHZhciB2YWx1ZTsKCiAgICAgICAgICAoZnVuY3Rpb24gKCkgewogICAgICAgICAgICAvL2NoZWNraW5nIGlmIGZ1bmN0aW9uIGlzIGludm9rZWQgc29tZXdoZXJlIGxhdGVyIGluIHRoZSBwcm9ncmFtCiAgICAgICAgICAgIHZhciBmdW5jdGlvblNvdXJjZURhdGEgPSBbXTsKICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlOwogICAgICAgICAgICB2YXIgcGFzc2VkVmFsdWVzID0gbXV0YWJsZV90b2tlbnNbal0ucGFzc2VkVmFsdWVzOwogICAgICAgICAgICB2YXIgZnVuY3Rpb25Ub2tlbiA9IG11dGFibGVfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVsLnZhbHVlID09IGZ1bmN0aW9uTmFtZTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHZhciBmdW5jdGlvbkFyZ3VtZW50cyA9IGZ1bmN0aW9uVG9rZW4uYXJndW1lbnRzOwogICAgICAgICAgICBmdW5jdGlvblNvdXJjZURhdGEgPSBmdW5jdGlvblRva2VuLlNvdXJjZURhdGE7IC8vQ3JlYXRpbmcgYSBzZXBlcmF0ZSBleGVjdXRpb24gY29udGV4dCBhbmQgc2V0dGluZyBmdWNudGlvbiBjb250ZXh0IG5hbWU6dmFsdWUgcGFpciBpbiAnZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMnCgogICAgICAgICAgICBmdW5jdGlvbkFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHsKICAgICAgICAgICAgICB2YXIgdmFsID0gcGFzc2VkVmFsdWVzW2luZGV4XTsKICAgICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvIi9nLCAiIik7CiAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoLycvZywgIiIpOwogICAgICAgICAgICAgIHBhc3NlZFZhbHVlc1tpbmRleF0gPSB2YWw7IC8vaW4gdGhpcyBjb2RlIHdlIGFyZSBmaWx0ZXJpbmcgb3V0IGFyZ3VtZW50cyBwYXNzZWQgYmFzZWQgb24gd2hldGhlciB0aGV5IGFscmVhZHkgZXhpc3QgaW4gdXBkYXRlZCB0b2tlbnMgb3Igbm90CgogICAgICAgICAgICAgIHZhciBGaW5kSW5VcGRhdGVkVG9rZW5zID0gdXBkYXRlZF90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IHZhbDsKICAgICAgICAgICAgICB9KTsgLy9Gb3IgcGFzc2luZyBzYW1lIGFyZ3VtZW50IGFuZCBzYW1lIHZhbHVlIHRvIGZ1bmN0aW9uICBlLmcgZnVuY3Rpb24gZm9vIChmaWJvbmFjY2kpIGFuZCBmaWJvbmFjY2k9W10gaXMgYWxyZWFkeSBkZWNsYXJlZAoKICAgICAgICAgICAgICBpZiAoRmluZEluVXBkYXRlZFRva2VucyA9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICBuYW1lOiBlbCwKICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbCwKICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiArIGluZGV4LAogICAgICAgICAgICAgICAgICB0eXBlOiAndmFsdWUnLAogICAgICAgICAgICAgICAgICBjb250ZXh0OiAnRnVuY3Rpb25FeGVjdXRpb25Db250ZXh0JwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfSAvL0ZvciBwYXNzaW5nIGRpZmZlcmVudCBhcmd1bWVudCBhbmQgdmFsdWUgdG8gZnVuY3Rpb24gIGUuZyBmdW5jdGlvbiBmb28gKGFycikgYW5kIGFyciBkb2Vzbid0IGV4aXN0IGFueXdoZXJlIGluIHRva2Vucy4KICAgICAgICAgICAgICBlbHNlIGlmIChlbCAhPSBGaW5kSW5VcGRhdGVkVG9rZW5zLm5hbWUgJiYgRmluZEluVXBkYXRlZFRva2VucyAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgbmFtZTogZWwsCiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEZpbmRJblVwZGF0ZWRUb2tlbnMudmFsdWUsCiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiArIGluZGV4LAogICAgICAgICAgICAgICAgICAgIHR5cGU6IEZpbmRJblVwZGF0ZWRUb2tlbnMudHlwZSwKICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiAnRnVuY3Rpb25FeGVjdXRpb25Db250ZXh0JywKICAgICAgICAgICAgICAgICAgICBJbnRoZUVuZFNldFZhbHVldG86IHZhbAogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsLAogICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWwsCiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiArIGluZGV4LAogICAgICAgICAgICAgICAgICAgIHR5cGU6IEZpbmRJblVwZGF0ZWRUb2tlbnMudHlwZSwKICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiAnRnVuY3Rpb25FeGVjdXRpb25Db250ZXh0JywKICAgICAgICAgICAgICAgICAgICBJbnRoZUVuZFNldFZhbHVldG86IHZhbAogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QgPSBbXS5jb25jYXQodXBkYXRlZF90b2tlbnMsIF90b0NvbnN1bWFibGVBcnJheShmdW5jdGlvbkNvbnRleHR1cGRhdGVkX3Rva2VucykpOwoKICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGZ1bmN0aW9uU291cmNlRGF0YS5sZW5ndGg7IF9pKyspIHsKICAgICAgICAgICAgICB2YXIgZWwgPSBmdW5jdGlvblNvdXJjZURhdGFbX2ldOwoKICAgICAgICAgICAgICBpZiAoZWwudmFsdWUgPT0gJ+CkquCljeCksOCkv+CkguCknycpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmdW5jdGlvblNvdXJjZURhdGEsQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaitpLDogJywgZnVuY3Rpb25Tb3VyY2VEYXRhLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBqICsgX2kpOwogICAgICAgICAgICAgICAgSWZUb2tlblByaW50KGZ1bmN0aW9uU291cmNlRGF0YSwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgX2ksIF90aGlzKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsLnZhbHVlID09ICc9JykgewogICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoZnVuY3Rpb25Tb3VyY2VEYXRhLCBfaSwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IsIF90aGlzKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT0gJ0FjY2VwdElucHV0JykgewogICAgICAgICAgICAgICAgdmFyIF9TZXRJbnB1dFZhbHVlQXMgPSBmdW5jdGlvblNvdXJjZURhdGFbX2ldLkFjY2VwdEFzOwogICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9tcHQoJ0VudGVyIFZhbHVlIGZvcicgKyBfU2V0SW5wdXRWYWx1ZUFzKTsKICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICBuYW1lOiBfU2V0SW5wdXRWYWx1ZUFzLAogICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PSAnY29uZGl0aW9uJykgewogICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50NCA9IGZ1bmN0aW9uU291cmNlRGF0YVtfaV0udmFsdWU7IC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBjYWxjdWxhdGUgdmFsdWUgb2Ygb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCgogICAgICAgICAgICAgICAgdmFyIENvbmRpdGlvblZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoX2VsZW1lbnQ0LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBfaSk7CgogICAgICAgICAgICAgICAgX3RoaXMuTGFzdENvbmRpdGlvblZhbHVlLnB1c2goQ29uZGl0aW9uVmFsdWUpOyAvLyAgY29uc29sZS5sb2coJ2o6ICcsaik7CiAgICAgICAgICAgICAgICAvL2lmIHZhbHVlIGlzIGZhbHNlLCBqdXN0IHNraXAgdGhlIGlmIGxvb3AgY29udGV4dCwgaWYgbm90IGl0IHdpbGwgYmUgcmFuIGluIGZpbmFsIHByaW50IG1vZHVsZQoKCiAgICAgICAgICAgICAgICBpZiAoQ29uZGl0aW9uVmFsdWUgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgdmFyIEluaXRpYWxpemVMb29wID0gdG9rZW5zLmluZGV4T2YoZnVuY3Rpb25Tb3VyY2VEYXRhW19pXSk7IC8vSGFuZGxlIEJsb2NrcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGNhcmUgb2YgbmVzdGVkIGJsb2NrIGJ5IHRha2luZyBjYXJlIG9mIG5lc3RlZCB7IGFuZCB9IGJyYWNrZXRzCiAgICAgICAgICAgICAgICAgIC8vaXQgdXNlcyB0aGUgc3RhY2sgdG8gcHVzaCBhbmQgcG9wIGJyYWNrZXRzIHRvIGFjY3VyYXRlbHkgaWRlbnRpZnkgc3RhcnQgYW5kIHRoZSBlbmQgb2YgdGhlIGJsb2NrCgogICAgICAgICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MoZnVuY3Rpb25Tb3VyY2VEYXRhLCBfaSk7CiAgICAgICAgICAgICAgICAgIF9pID0gUmV0dXJudmFsdWUuaTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IC8vSGFuZGxpbmcgc2V0IGFycmF5IGVsZW1lbnQgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAogICAgICAgICAgICAgIGVsc2UgaWYgKGZ1bmN0aW9uU291cmNlRGF0YVtfaV0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikgewogICAgICAgICAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUoZnVuY3Rpb25Tb3VyY2VEYXRhLCBfaSwgaiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uU291cmNlRGF0YVtfaV0udHlwZSA9PSAnRm9yTG9vcFN0YXJ0JykgewogICAgICAgICAgICAgICAgICB2YXIgZ2V0U291cmNlZGF0YSA9IGZ1bmN0aW9uIGdldFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgZnVuY3Rpb25Tb3VyY2VEYXRhLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdGFydEluZGV4LCBmdW5jdGlvblNvdXJjZURhdGEsIGNoZWNrLCBTdG9yZVJlc3VsdDogJywgc3RhcnRJbmRleCwgZnVuY3Rpb25Tb3VyY2VEYXRhLCBjaGVjaywgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgICAgICAgIHZhciBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhmdW5jdGlvblNvdXJjZURhdGEsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KTsKICAgICAgICAgICAgICAgICAgICBTdG9yZVJlc3VsdCA9IFJldHVybnZhbHVlLlN0b3JlUmVzdWx0OwogICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICAgIEZsYWdQcmltYWxMb29wID0gMDsKICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2VucyA9IFtdOyAvL2NvbnNvbGUubG9nKCd1cGRhdGVkX3Rva2VuczogJywgdXBkYXRlZF90b2tlbnMpOwoKICAgICAgICAgICAgICAgICAgdmFyIEZvckxvb3BNZXRhRGF0YSA9IEZvckxvb3BTZXRNZXRhZGF0YShmdW5jdGlvblNvdXJjZURhdGEsIF9pLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0KTsKICAgICAgICAgICAgICAgICAgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gRm9yTG9vcE1ldGFEYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydDsKICAgICAgICAgICAgICAgICAgQ3ljbGUgPSBGb3JMb29wTWV0YURhdGEuQ3ljbGU7CiAgICAgICAgICAgICAgICAgIE9yaWdpbmFsSXRlcmF0b3IgPSBGb3JMb29wTWV0YURhdGEuT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgICAgICAgICAgSXRlcmF0aW9uU3RhcnQgPSBGb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQ7CiAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gRm9yTG9vcE1ldGFEYXRhLml0ZXJhdG9yOwogICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRm9yTG9vcE1ldGFEYXRhLmVsZW1lbnQ7CiAgICAgICAgICAgICAgICAgIGVsZW1lbnRWYWx1ZSA9IEZvckxvb3BNZXRhRGF0YS5lbGVtZW50VmFsdWU7CiAgICAgICAgICAgICAgICAgIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KGZ1bmN0aW9uU291cmNlRGF0YSwgX2ksICd7JywgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsgLy8KCiAgICAgICAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRTb3VyY2VkYXRhKEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgZnVuY3Rpb25Tb3VyY2VEYXRhLCAnfScsIFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgZWwuaXNOZXN0ZWRMb29wID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB2YXIgRmluZE5lc3RlZExvb3AgPSBTb3VyY2VkYXRhVG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnR5cGUgPT0gJ0Zvckxvb3BTdGFydCc7CiAgICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgICAgaWYgKEZpbmROZXN0ZWRMb29wICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRMb29waW5kZXggPSBTb3VyY2VkYXRhVG9rZW5zLmluZGV4T2YoRmluZE5lc3RlZExvb3ApICsgMjsKICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkTG9vcGxlbmd0aCA9IFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5FbmRJbmRleCAtIFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5zdGFydEluZGV4ICsgMTsKCiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IE5lc3RlZExvb3BpbmRleDsgeCA8IE5lc3RlZExvb3BpbmRleCArIE5lc3RlZExvb3BsZW5ndGg7IHgrKykgewogICAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2Vuc1t4XS5pc05lc3RlZExvb3AgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5jbHVkZXMoJygnKSAmJiBlbGVtZW50LmluY2x1ZGVzKCcsJykpIHsKICAgICAgICAgICAgICAgICAgICBGbGFnUHJpbWFsTG9vcCA9IDE7CiAgICAgICAgICAgICAgICAgIH0gLy8gY29uc29sZS5sb2coJ0N5Y2xlOiAnLCBDeWNsZSxJdGVyYXRpb25TdGFydCk7CiAgICAgICAgICAgICAgICAgIC8vSXRlcmF0aW5nIG92ZXIgZm9ybG9vcCBzb3VyY2VkYXRhCiAgICAgICAgICAgICAgICAgIC8vdGhpcyBsaW5lICdpdGVyYXRvciA8PSBDeWNsZScgZGV0ZXJtaW5lcyBzdGFydCBvZiB0aGUgbG9vcCBhbmQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsb29wCgoKICAgICAgICAgICAgICAgICAgZm9yIChpdGVyYXRvciA9IEl0ZXJhdGlvblN0YXJ0OyBpdGVyYXRvciA8PSBDeWNsZTsgaXRlcmF0b3IrKykgewogICAgICAgICAgICAgICAgICAgIHZhciBmb3Jsb29waW5kZXggPSBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PSBPcmlnaW5hbEl0ZXJhdG9yOwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIGZvcmxvb3BpbmRleC52YWx1ZSA9IGl0ZXJhdG9yOyAvL2NvbnNvbGUubG9nKCdDb21wbGV0ZVRva2VuVmFsdWVMaXN0OiAnLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0KTsKICAgICAgICAgICAgICAgICAgICAvL2ZsYWcgdG8gYXZvaWQgcnVubmluZyB0aGlzIGNvZGUgaWYgbG9vcCBpcyBwcmltYWwgYmVjYXVzZSB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBjb21wZWx0ZWx5IGRpZmZlcmVudAoKICAgICAgICAgICAgICAgICAgICBpZiAoRmxhZ1ByaW1hbExvb3AgPSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBGb3JMb29wQXJyYXlvclN0cmluZ091dHB1dChlbGVtZW50VmFsdWUsIGl0ZXJhdG9yLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBfdGhpcyk7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBpc05lc3RlZCA9IFNvdXJjZWRhdGFUb2tlbnNbX2kyXS5pc05lc3RlZExvb3A7CgogICAgICAgICAgICAgICAgICAgICAgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2kyXS50eXBlID09ICdGb3JMb29wU3RhcnQnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZ2V0U291cmNlZGF0YSA9IGZ1bmN0aW9uIF9nZXRTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdDogJywgc3RhcnRJbmRleCwgU291cmNlZGF0YVRva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MoU291cmNlZGF0YVRva2Vucywgc3RhcnRJbmRleCwgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gUmV0dXJudmFsdWUuU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0OwogICAgICAgICAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkRmxhZ1ByaW1hbExvb3AgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zID0gW107CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRGb3JMb29wTWV0YURhdGEgPSBGb3JMb29wU2V0TWV0YWRhdGEoU291cmNlZGF0YVRva2VucywgX2kyLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0KTsgLy8gIGNvbnNvbGUubG9nKCdOZXN0ZWRGb3JMb29wTWV0YURhdGE6ICcsIE5lc3RlZEZvckxvb3BNZXRhRGF0YSk7CgogICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0OwogICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRDeWNsZSA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5DeWNsZSArIDE7CiAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkSXRlcmF0aW9uU3RhcnQgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQ7CiAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZGl0ZXJhdG9yID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkl0ZXJhdGlvblN0YXJ0OwogICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRlbGVtZW50ID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLmVsZW1lbnQ7CiAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZGVsZW1lbnRWYWx1ZSA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5lbGVtZW50VmFsdWU7CiAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgJ3snLCBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpOwogICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zID0gX2dldFNvdXJjZWRhdGEoTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBTb3VyY2VkYXRhVG9rZW5zLCAnfScsIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMpOyAvL2NvbnNvbGUubG9nKCdOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zOiAnLCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoTmVzdGVkaXRlcmF0b3I7IE5lc3RlZGl0ZXJhdG9yIDwgTmVzdGVkQ3ljbGU7IE5lc3RlZGl0ZXJhdG9yKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IE5lc3RlZGl0ZXJhdG9yOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZGZvcmxvb3BpbmRleCA9IENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT0gTmVzdGVkT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyAvL2NvbnNvbGUubG9nKCdmb3Jsb29waW5kZXg6ICcsIGZvcmxvb3BpbmRleCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkZm9ybG9vcGluZGV4LnZhbHVlID0geTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgTmVzdGVkU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IGluZGV4KyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lbCA9IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9lbC52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmVG9rZW5QcmludChOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpbmRleCwgX3RoaXMsIHksIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9lbC52YWx1ZSA9PSAnPScgJiYgX2VsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hc3NpZ25pbmcgdmFsdWVzIHRvIHZhcmlhYmxlcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsIGluZGV4LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCB5LCBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yLCBfdGhpcyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2VsLnR5cGUgPT0gJ2NvbmRpdGlvbicgJiYgX2VsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2Vuc1tpXTogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ29uZGl0aW9uU3RhcnRJbmRleCA9IGluZGV4OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4XS52YWx1ZTsgLy9IYW5kbGVDb25kaXRpb25zIGV2YWx1YXRlcyBjb25kaXRpb24gYW5kIHJldHVybiB0aGUgaW5kZXggb2YgZnJvbSB3aGVyZSBwcmludGluZyBzaG91bGQgcmVzdW1lCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSBvZiBpIGRlcGVuZHMgb24gdGhlIGNvbmRpdGlvbnMKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbi5pbmNsdWRlcygnfHwnKSB8fCBjb25kaXRpb24uaW5jbHVkZXMoJyYmJykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShjb25kaXRpb24sIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGluZGV4KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaChfdmFsdWUpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdmFsdWUgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEJsb2NrTGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEJsb2NrU3RhcnQgPSAwOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdLnZhbHVlICE9ICd7JykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4ICsgMV0udmFsdWUgPT0gJ3snKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCbG9ja0xlbmd0aCA9IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXggKyAxXS5FbmRJbmRleCAtIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXggKyAxXS5zdGFydEluZGV4OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBCbG9ja0xlbmd0aCArIGluZGV4ICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF94ID0gSGFuZGxlQ29uZGl0aW9ucyhOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCBpbmRleCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF94ICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IF94OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBDb25kaXRpb25TdGFydEluZGV4OyAvL2NvbnNvbGUubG9nKCdpOiAnLCBpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9jb25zb2xlLmxvZygnaTogJywgaSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGkgPSBpICsgTmVzdGVkU291cmNlZGF0YVRva2Vucy5sZW5ndGgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9lbC50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiICYmIF9lbC5pc05lc3RlZExvb3AgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgaiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pMl0udHlwZSA9PSAnQWNjZXB0SW5wdXQnICYmIGlzTmVzdGVkID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfU2V0SW5wdXRWYWx1ZUFzMiA9IFNvdXJjZWRhdGFUb2tlbnNbX2kyXS50eXBlLkFjY2VwdEFzOwogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb21wdCgnRW50ZXIgVmFsdWUgZm9yJyArIF9TZXRJbnB1dFZhbHVlQXMyKTsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3ZhbHVlOiAnLCB2YWx1ZSk7CiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF9TZXRJbnB1dFZhbHVlQXMyLAogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTJdLnZhbHVlID09ICc9JyAmJiBpc05lc3RlZCA9PSBmYWxzZSkgewogICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IsIF90aGlzKTsKICAgICAgICAgICAgICAgICAgICAgIH0gLy9IYW5kbGluZyBwcmludCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pMl0udmFsdWUgPT0gJ+CkquCljeCksOCkv+CkguCknycgJiYgaXNOZXN0ZWQgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZvciBsb29vcCBwcmludHM6ICcsIGZ1bmN0aW9uU291cmNlRGF0YVtpXSxpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQoU291cmNlZGF0YVRva2VucywgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgX2kyLCBfdGhpcywgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IpOyAvLwogICAgICAgICAgICAgICAgICAgICAgICB9IC8vSGFuZGxpbmcgc2V0IGFycmF5IGVsZW1lbnQgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pMl0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgaiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTJdLnR5cGUgPT0gJ2NvbmRpdGlvbicpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2Vuc1tpXTogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9Db25kaXRpb25TdGFydEluZGV4ID0gX2kyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbmRpdGlvbiA9IFNvdXJjZWRhdGFUb2tlbnNbX2kyXS52YWx1ZTsgLy9IYW5kbGVDb25kaXRpb25zIGV2YWx1YXRlcyBjb25kaXRpb24gYW5kIHJldHVybiB0aGUgaW5kZXggb2YgZnJvbSB3aGVyZSBwcmludGluZyBzaG91bGQgcmVzdW1lCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb2YgaSBkZXBlbmRzIG9uIHRoZSBjb25kaXRpb25zCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbmRpdGlvbi5pbmNsdWRlcygnfHwnKSB8fCBfY29uZGl0aW9uLmluY2x1ZGVzKCcmJicpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF92YWx1ZTIgPSBHZXRDb25kaXRpb25WYWx1ZShfY29uZGl0aW9uLCB1cGRhdGVkX3Rva2VucywgX2kyKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuTGFzdENvbmRpdGlvblZhbHVlLnB1c2goX3ZhbHVlMik7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdmFsdWUyID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX0Jsb2NrTGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfQmxvY2tTdGFydCA9IDA7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFNvdXJjZWRhdGFUb2tlbnNbX2kyXS52YWx1ZSAhPSAneycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2kyICsgMV0udmFsdWUgPT0gJ3snKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX0Jsb2NrTGVuZ3RoID0gU291cmNlZGF0YVRva2Vuc1tfaTIgKyAxXS5FbmRJbmRleCAtIFNvdXJjZWRhdGFUb2tlbnNbX2kyICsgMV0uc3RhcnRJbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTIgPSBfQmxvY2tMZW5ndGggKyBfaTIgKyAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTIrKzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kyID0gX2kyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTIgPSBIYW5kbGVDb25kaXRpb25zKFNvdXJjZWRhdGFUb2tlbnMsIF9pMiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTIgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTIgPSBfaTI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pMiA9IF9Db25kaXRpb25TdGFydEluZGV4OyAvL2NvbnNvbGUubG9nKCdpOiAnLCBpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gLy9jb25zb2xlLmxvZygnajogJywgaik7CgoKICAgICAgICAgICAgICAgICAgX2kgPSBfaSArIFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyAvL2NvbnNvbGUubG9nKCdqOiAnLCBqKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25Tb3VyY2VEYXRhW19pXS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKSB7CiAgICAgICAgICAgICAgICAgIFNldEFycmF5SW5kZXhWYWx1ZShTb3VyY2VkYXRhVG9rZW5zLCBfaSwgaiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uU291cmNlRGF0YVtfaV0udHlwZSA9PSAnV2hpbGVMb29wU3RhcnQnKSB7CiAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIGdldFdoaWxlTG9vcFNvdXJjZWRhdGEgPSBmdW5jdGlvbiBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIGZ1bmN0aW9uU291cmNlRGF0YSwgY2hlY2ssIFN0b3JlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgICAgICBTdG9yZVJlc3VsdCA9IEhhbmRsZUJsb2NrcyhmdW5jdGlvblNvdXJjZURhdGEsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KTsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgICAgICB2YXIgVG9rZW5zQ3VycmVudEluZGV4ID0gX2kgKyAzOwogICAgICAgICAgICAgICAgICAgIHZhciBDb25kaXRpb25WYWx1ZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZnVuY3Rpb25Tb3VyY2VEYXRhW19pICsgMV0udmFsdWU7CiAgICAgICAgICAgICAgICAgICAgdmFyIEV4dHJhdGNlZFZhcmlhYmxlID0gW107CiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gJyc7CiAgICAgICAgICAgICAgICAgICAgdmFyIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgICB2YXIgV2hpbGVMb29wU291cmNlZGF0YVRva2VucyA9IFtdOwoKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlbGVtZW50Lmxlbmd0aDsgX2kzKyspIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBfeDIgPSBlbGVtZW50LmNoYXJBdChfaTMpOwoKICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKF94MikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZSArIF94MjsKICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFyaWFibGUoZWxlbWVudC5jaGFyQXQoX2kzICsgMSkpICYmIGlzVmFyaWFibGUoX3gyKSkgewogICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Rva2VuMyA9IENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PSB2YXJpYWJsZTsKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICAgICAgICBFeHRyYXRjZWRWYXJpYWJsZS5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZTogdmFyaWFibGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF90b2tlbjMudmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gJyc7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KGZ1bmN0aW9uU291cmNlRGF0YSwgX2ksICd7JywgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQpOyAvLwoKICAgICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gZ2V0V2hpbGVMb29wU291cmNlZGF0YShXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgZnVuY3Rpb25Tb3VyY2VEYXRhLCAnfScsIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMpLlN0b3JlUmVzdWx0OyAvL2NvbnN0YW50bHkgYWNjZXNzaW5nIHRoZSBjb25kaXRpb252YWx1ZQoKICAgICAgICAgICAgICAgICAgICB3aGlsZSAoR2V0Q29uZGl0aW9uVmFsdWUoZWxlbWVudCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaiArIDEpKSB7CiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgX2k0KyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgLy9TRUNUSU9OIHdoaWxlIGxvb3AgY29udGV4dAogICAgICAgICAgICAgICAgICAgICAgICBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTRdLnZhbHVlID09ICc9JykgewogICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pNCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7IC8vCiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTRdLnR5cGUgPT0gJ0FjY2VwdElucHV0JykgewogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfU2V0SW5wdXRWYWx1ZUFzMyA9IFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2k0XS50eXBlLkFjY2VwdEFzOwogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvbXB0KCdFbnRlciBWYWx1ZSBmb3InICsgX1NldElucHV0VmFsdWVBczMpOwogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd2YWx1ZTogJywgdmFsdWUpOwogICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogX1NldElucHV0VmFsdWVBczMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2k0XS50eXBlID09ICdjb25kaXRpb24nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2luZGV4ID0gSGFuZGxlQ29uZGl0aW9ucyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaW5kZXggIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNCA9IF9pbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNCA9IF9pNDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2k0XS52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWZUb2tlblByaW50KFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIF9pNCwgX3RoaXMpOyAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pNF0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pNCwgaiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgX2kgPSBfaSArIDEgKyBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aCArIDE7CiAgICAgICAgICAgICAgICAgIH0pKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gLy9za2lwcGluZyBwYXJzaW5nIGluZGV4IHNvIHRoYXQgZnVuY3Rpb24gY29udGV4dCBpcyBydW4gYnkgc2luZ2xlIGVudGl0eSBhbmQgZ2xvYmFsIGV4ZWN1dGlvbiBkb2Vzbid0IHJ1biB0aGlzIGNvZGUgdG9vCiAgICAgICAgICAgIC8vICBqID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLkVuZEluZGV4CiAgICAgICAgICAgIC8vSWYgd2UgcGFzcyBmdW5jdGlvbiBmb28oYXJyKSB3aGVyZSBhcnIgaXMgKHN1cHBvc2UpIGZpYm9uYWNjaT1bXSBkZWNsYXJlZCBpbiB0aGUgZ2xvYmFsIGV4ZSBjb250ZXh0KHVwZGF0ZWRfdG9rZW5zKS4gQnV0IG9wZXJhdGlvbiB3aWxsIGJlIHBlcmZvcm1lZCBvbgogICAgICAgICAgICAvL2FyciBpbiBmdW5jdGlvbkNvbnRleHR1cGRhdGVkX3Rva2Vucy4gc28gYXQgdGhlIGVuZCBvZiBmdWNudGlvbiBleGVjdXRpb24gd2Ugc2V0IHRoZSB2YWx1ZSB0byBpdCdzIHJpZ2h0IG93bmVyLgoKCiAgICAgICAgICAgIHZhciB0b2tlbiA9IGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVsLkludGhlRW5kU2V0VmFsdWV0byAhPSAnJzsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHZhciBHaXZlUG93ZXJzVG8gPSB1cGRhdGVkX3Rva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IHRva2VuLkludGhlRW5kU2V0VmFsdWV0bzsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIEdpdmVQb3dlcnNUby52YWx1ZSA9IHRva2VuLnZhbHVlOyAvL0kgaGF2ZSB0byBlbXB0eSBpdCBiZWNhdXNlIGZ1bmN0aW9uIGNvbnRleHQgaGFzIHRvIHJlbWFpbiBlbXB0eSBvdGhlciB3aXNlIGZ1bmN0aW9uIGFyZ3VtZW50cyB3aWxsIGtlZXAgb24gYWNjZXB0aW5nIG5ldyB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBrZXkKICAgICAgICAgICAgLy9mb3IgZS5nPSBQcmludEZ1bGxOYW1lKEZpcnN0TmFtZSxMYXN0TmFtZSkgYW5kIFByaW50RnVsbE5hbWUoRmlyc3ROYW0sTGFzdE5hbSkgbmVlZHMgdHdvIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dCBoZW5jZSBmaXJzdCBvbmUgbmVlZHMgdG8gbWFrZSBzcGFjZSBmb3IgbGF0ZXIKCiAgICAgICAgICAgIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zID0gW107CiAgICAgICAgICB9KSgpOwogICAgICAgIH0gZWxzZSBpZiAodG9rZW5UeXBlID09ICdjb25kaXRpb24nKSB7CiAgICAgICAgICB2YXIgX2VsZW1lbnQ1ID0gbXV0YWJsZV90b2tlbnNbal0udmFsdWU7IC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBjYWxjdWxhdGUgdmFsdWUgb2Ygb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCgogICAgICAgICAgdmFyIENvbmRpdGlvblZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoX2VsZW1lbnQ1LCB1cGRhdGVkX3Rva2Vucywgaik7CiAgICAgICAgICB0aGlzLkxhc3RDb25kaXRpb25WYWx1ZS5wdXNoKENvbmRpdGlvblZhbHVlKTsgLy8gY29uc29sZS5sb2coJ0NvbmRpdGlvblZhbHVlOiAnLCBDb25kaXRpb25WYWx1ZSk7CiAgICAgICAgICAvLyAgY29uc29sZS5sb2coJ2o6ICcsaik7CiAgICAgICAgICAvL2lmIHZhbHVlIGlzIGZhbHNlLCBqdXN0IHNraXAgdGhlIGlmIGxvb3AgY29udGV4dCwgaWYgbm90IGl0IHdpbGwgYmUgcmFuIGluIGZpbmFsIHByaW50IG1vZHVsZQoKICAgICAgICAgIGlmIChDb25kaXRpb25WYWx1ZSA9PSBmYWxzZSkgewogICAgICAgICAgICB2YXIgSW5pdGlhbGl6ZUxvb3AgPSB0b2tlbnMuaW5kZXhPZihtdXRhYmxlX3Rva2Vuc1tqXSk7IC8vSGFuZGxlIEJsb2NrcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGNhcmUgb2YgbmVzdGVkIGJsb2NrIGJ5IHRha2luZyBjYXJlIG9mIG5lc3RlZCB7IGFuZCB9IGJyYWNrZXRzCiAgICAgICAgICAgIC8vaXQgdXNlcyB0aGUgc3RhY2sgdG8gcHVzaCBhbmQgcG9wIGJyYWNrZXRzIHRvIGFjY3VyYXRlbHkgaWRlbnRpZnkgc3RhcnQgYW5kIHRoZSBlbmQgb2YgdGhlIGJsb2NrCgogICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIGopOwogICAgICAgICAgICBqID0gUmV0dXJudmFsdWUuajsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIG11dGFibGVfdG9rZW5zW2pdLmNvbnRleHQgIT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgSWZUb2tlblByaW50KG11dGFibGVfdG9rZW5zLCB1cGRhdGVkX3Rva2VucywgaiwgdGhpcyk7IC8vZm9yIG9wZXJhdGlvbnMgbGlrZSBwcmludChhcnJheVszXSkKICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHlwZSA9PSAnV2hpbGVMb29wU3RhcnQnKSB7CiAgICAgICAgICB2YXIgdmFsdWU7CgogICAgICAgICAgKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdmFyIGdldFdoaWxlTG9vcFNvdXJjZWRhdGEgPSBmdW5jdGlvbiBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICBTdG9yZVJlc3VsdCA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2Vucywgc3RhcnRJbmRleCwgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIHZhciBUb2tlbnNDdXJyZW50SW5kZXggPSBqICsgMzsKICAgICAgICAgICAgdmFyIENvbmRpdGlvblZhbHVlID0gZmFsc2U7CiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlOwogICAgICAgICAgICB2YXIgRXh0cmF0Y2VkVmFyaWFibGUgPSBbXTsKICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gJyc7CiAgICAgICAgICAgIHZhciBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IDA7CiAgICAgICAgICAgIHZhciBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gW107CgogICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBlbGVtZW50Lmxlbmd0aDsgX2k1KyspIHsKICAgICAgICAgICAgICB2YXIgeCA9IGVsZW1lbnQuY2hhckF0KF9pNSk7CgogICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKHgpKSB7CiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlICsgeDsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGlmICghaXNWYXJpYWJsZShlbGVtZW50LmNoYXJBdChfaTUgKyAxKSkgJiYgaXNWYXJpYWJsZSh4KSkgewogICAgICAgICAgICAgICAgdmFyIF90b2tlbjQgPSB1cGRhdGVkX3Rva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PSB2YXJpYWJsZTsKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIEV4dHJhdGNlZFZhcmlhYmxlLnB1c2goewogICAgICAgICAgICAgICAgICB2YXJpYWJsZTogdmFyaWFibGUsCiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdG9rZW40LnZhbHVlCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gJyc7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsgLy8KCiAgICAgICAgICAgIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBtdXRhYmxlX3Rva2VucywgJ30nLCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zKS5TdG9yZVJlc3VsdDsKICAgICAgICAgICAgY29uc29sZS5sb2coJ1doaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnM6ICcsIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMpOyAvL2NvbnN0YW50bHkgYWNjZXNzaW5nIHRoZSBjb25kaXRpb252YWx1ZQoKICAgICAgICAgICAgd2hpbGUgKEdldENvbmRpdGlvblZhbHVlKGVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBqICsgMSkpIHsKICAgICAgICAgICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgX2k2KyspIHsKICAgICAgICAgICAgICAgIC8vU0VDVElPTiB3aGlsZSBsb29wIGNvbnRleHQKICAgICAgICAgICAgICAgIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pNl0udmFsdWUgPT0gJz0nKSB7CiAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pNiwgdXBkYXRlZF90b2tlbnMpOyAvLwogICAgICAgICAgICAgICAgICAvLyAKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTZdLnR5cGUgPT0gJ0FjY2VwdElucHV0JykgewogICAgICAgICAgICAgICAgICB2YXIgX1NldElucHV0VmFsdWVBczQgPSBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pNl0udHlwZS5BY2NlcHRBczsKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9tcHQoJ0VudGVyIFZhbHVlIGZvcicgKyBfU2V0SW5wdXRWYWx1ZUFzNCk7CiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd2YWx1ZTogJywgdmFsdWUpOwogICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICBuYW1lOiBfU2V0SW5wdXRWYWx1ZUFzNCwKICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9IC8vIEhhbmRsaW5nIENPTkRJVElPTkFMIHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgIGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2k2XS50eXBlID09ICdjb25kaXRpb24nKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gSGFuZGxlQ29uZGl0aW9ucyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTYsIHVwZGF0ZWRfdG9rZW5zKTsKCiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgX2k2ID0gaW5kZXg7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgIF9pNiA9IF9pNjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTZdLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKSB7CiAgICAgICAgICAgICAgICAgICAgSWZUb2tlblByaW50KFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIHVwZGF0ZWRfdG9rZW5zLCBfaTYsIF90aGlzKTsgLy9mb3Igb3BlcmF0aW9ucyBsaWtlIHByaW50KGFycmF5WzNdKQogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2k2XS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKSB7CiAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pNiwgaiwgdXBkYXRlZF90b2tlbnMsIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9KSgpOwogICAgICAgIH0gZWxzZSBpZiAodG9rZW5UeXBlID09ICdGb3JMb29wU3RhcnQnKSB7CiAgICAgICAgICB2YXIgZ2V0U291cmNlZGF0YSA9IGZ1bmN0aW9uIGdldFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgbXV0YWJsZV90b2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdGFydEluZGV4LCBtdXRhYmxlX3Rva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0OiAnLCBzdGFydEluZGV4LCBtdXRhYmxlX3Rva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KTsKICAgICAgICAgICAgdmFyIFJldHVybnZhbHVlID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCk7CiAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gUmV0dXJudmFsdWUuU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgIH07CgogICAgICAgICAgdmFyIEZsYWdQcmltYWxMb29wID0gMDsKICAgICAgICAgIHZhciBTb3VyY2VkYXRhVG9rZW5zID0gW107IC8vY29uc29sZS5sb2coJ3VwZGF0ZWRfdG9rZW5zOiAnLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgdmFyIEZvckxvb3BNZXRhRGF0YSA9IEZvckxvb3BTZXRNZXRhZGF0YShtdXRhYmxlX3Rva2VucywgaiwgdXBkYXRlZF90b2tlbnMpOwogICAgICAgICAgY29uc29sZS5sb2coJ0Zvckxvb3BNZXRhRGF0YTogJywgRm9yTG9vcE1ldGFEYXRhKTsKICAgICAgICAgIHZhciBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBGb3JMb29wTWV0YURhdGEuRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0OwogICAgICAgICAgdmFyIEN5Y2xlID0gRm9yTG9vcE1ldGFEYXRhLkN5Y2xlOwogICAgICAgICAgdmFyIE9yaWdpbmFsSXRlcmF0b3IgPSBGb3JMb29wTWV0YURhdGEuT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgIHZhciBJdGVyYXRpb25TdGFydCA9IEZvckxvb3BNZXRhRGF0YS5JdGVyYXRpb25TdGFydDsKICAgICAgICAgIHZhciBpdGVyYXRvciA9IEZvckxvb3BNZXRhRGF0YS5pdGVyYXRvcjsKICAgICAgICAgIHZhciBlbGVtZW50ID0gRm9yTG9vcE1ldGFEYXRhLmVsZW1lbnQ7CiAgICAgICAgICB2YXIgZWxlbWVudFZhbHVlID0gRm9yTG9vcE1ldGFEYXRhLmVsZW1lbnRWYWx1ZTsKICAgICAgICAgIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCk7IC8vCgogICAgICAgICAgU291cmNlZGF0YVRva2VucyA9IGdldFNvdXJjZWRhdGEoRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBtdXRhYmxlX3Rva2VucywgJ30nLCBTb3VyY2VkYXRhVG9rZW5zKTsgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2VuczogJywgU291cmNlZGF0YVRva2Vucyk7CgogICAgICAgICAgU291cmNlZGF0YVRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICBlbC5pc05lc3RlZExvb3AgPSBmYWxzZTsKICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIEZpbmROZXN0ZWRMb29wID0gU291cmNlZGF0YVRva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICByZXR1cm4gZWwudHlwZSA9PSAnRm9yTG9vcFN0YXJ0JzsKICAgICAgICAgIH0pOwoKICAgICAgICAgIGlmIChGaW5kTmVzdGVkTG9vcCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgdmFyIE5lc3RlZExvb3BpbmRleCA9IFNvdXJjZWRhdGFUb2tlbnMuaW5kZXhPZihGaW5kTmVzdGVkTG9vcCkgKyAzOwogICAgICAgICAgICB2YXIgTmVzdGVkTG9vcGxlbmd0aCA9IFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5FbmRJbmRleCAtIFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5zdGFydEluZGV4ICsgMjsKCiAgICAgICAgICAgIGZvciAodmFyIHggPSBOZXN0ZWRMb29waW5kZXg7IHggPCBOZXN0ZWRMb29waW5kZXggKyBOZXN0ZWRMb29wbGVuZ3RoOyB4KyspIHsKICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zW3hdLmlzTmVzdGVkTG9vcCA9IHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygnKCcpICYmIGVsZW1lbnQuaW5jbHVkZXMoJywnKSkgewogICAgICAgICAgICBGbGFnUHJpbWFsTG9vcCA9IDE7CiAgICAgICAgICB9IC8vIGNvbnNvbGUubG9nKCdDeWNsZTogJywgQ3ljbGUsSXRlcmF0aW9uU3RhcnQpOwogICAgICAgICAgLy9JdGVyYXRpbmcgb3ZlciBmb3Jsb29wIHNvdXJjZWRhdGEKICAgICAgICAgIC8vdGhpcyBsaW5lICdpdGVyYXRvciA8PSBDeWNsZScgZGV0ZXJtaW5lcyBzdGFydCBvZiB0aGUgbG9vcCBhbmQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsb29wCgoKICAgICAgICAgIGZvciAoaXRlcmF0b3IgPSBJdGVyYXRpb25TdGFydDsgaXRlcmF0b3IgPD0gQ3ljbGU7IGl0ZXJhdG9yKyspIHsKICAgICAgICAgICAgdmFyIGZvcmxvb3BpbmRleCA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT0gT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGZvcmxvb3BpbmRleC52YWx1ZSA9IGl0ZXJhdG9yOyAvL2NvbnNvbGUubG9nKCd1cGRhdGVkX3Rva2VuczogJywgdXBkYXRlZF90b2tlbnMpOwogICAgICAgICAgICAvL2ZsYWcgdG8gYXZvaWQgcnVubmluZyB0aGlzIGNvZGUgaWYgbG9vcCBpcyBwcmltYWwgYmVjYXVzZSB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBjb21wZWx0ZWx5IGRpZmZlcmVudAoKICAgICAgICAgICAgaWYgKEZsYWdQcmltYWxMb29wID0gMCkgewogICAgICAgICAgICAgIEZvckxvb3BBcnJheW9yU3RyaW5nT3V0cHV0KGVsZW1lbnRWYWx1ZSwgaXRlcmF0b3IsIHVwZGF0ZWRfdG9rZW5zLCB0aGlzKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pNysrKSB7CiAgICAgICAgICAgICAgdmFyIGlzTmVzdGVkID0gU291cmNlZGF0YVRva2Vuc1tfaTddLmlzTmVzdGVkTG9vcDsKCiAgICAgICAgICAgICAgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2k3XS50eXBlID09ICdGb3JMb29wU3RhcnQnKSB7CiAgICAgICAgICAgICAgICB2YXIgX2dldFNvdXJjZWRhdGEyID0gZnVuY3Rpb24gX2dldFNvdXJjZWRhdGEyKHN0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdGFydEluZGV4LCBTb3VyY2VkYXRhVG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQ6ICcsIHN0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCk7CiAgICAgICAgICAgICAgICAgIHZhciBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhTb3VyY2VkYXRhVG9rZW5zLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCk7CiAgICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gUmV0dXJudmFsdWUuU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgICAgdmFyIE5lc3RlZEZsYWdQcmltYWxMb29wID0gMDsKICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zID0gW107CiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRm9yTG9vcE1ldGFEYXRhID0gRm9yTG9vcFNldE1ldGFkYXRhKFNvdXJjZWRhdGFUb2tlbnMsIF9pNywgdXBkYXRlZF90b2tlbnMpOyAvLyAgY29uc29sZS5sb2coJ05lc3RlZEZvckxvb3BNZXRhRGF0YTogJywgTmVzdGVkRm9yTG9vcE1ldGFEYXRhKTsKCiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydDsKICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRDeWNsZSA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5DeWNsZSArIDE7CiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkT3JpZ2luYWxJdGVyYXRvciA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5PcmlnaW5hbEl0ZXJhdG9yOwogICAgICAgICAgICAgICAgdmFyIE5lc3RlZEl0ZXJhdGlvblN0YXJ0ID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkl0ZXJhdGlvblN0YXJ0OwogICAgICAgICAgICAgICAgdmFyIE5lc3RlZGl0ZXJhdG9yID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkl0ZXJhdGlvblN0YXJ0OwogICAgICAgICAgICAgICAgdmFyIE5lc3RlZGVsZW1lbnQgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuZWxlbWVudDsKICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRlbGVtZW50VmFsdWUgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuZWxlbWVudFZhbHVlOwogICAgICAgICAgICAgICAgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQoU291cmNlZGF0YVRva2VucywgX2k3LCAneycsIE5lc3RlZEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCk7IC8vY29uc29sZS5sb2coJ0Zvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydDogJywgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsKCiAgICAgICAgICAgICAgICBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zID0gX2dldFNvdXJjZWRhdGEyKE5lc3RlZEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgU291cmNlZGF0YVRva2VucywgJ30nLCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zKTsgLy9jb25zb2xlLmxvZygnTmVzdGVkU291cmNlZGF0YVRva2VuczogJywgTmVzdGVkU291cmNlZGF0YVRva2Vucyk7CgogICAgICAgICAgICAgICAgZm9yIChOZXN0ZWRpdGVyYXRvcjsgTmVzdGVkaXRlcmF0b3IgPCBOZXN0ZWRDeWNsZTsgTmVzdGVkaXRlcmF0b3IrKykgewogICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBOZXN0ZWRpdGVyYXRvcjsKICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkZm9ybG9vcGluZGV4ID0gdXBkYXRlZF90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IE5lc3RlZE9yaWdpbmFsSXRlcmF0b3I7CiAgICAgICAgICAgICAgICAgICAgfSk7IC8vY29uc29sZS5sb2coJ2Zvcmxvb3BpbmRleDogJywgZm9ybG9vcGluZGV4KTsKCiAgICAgICAgICAgICAgICAgICAgTmVzdGVkZm9ybG9vcGluZGV4LnZhbHVlID0geTsKCiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4XTsKCiAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudmFsdWUgPT0gJ+CkquCljeCksOCkv+CkguCknycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgSWZUb2tlblByaW50KE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsIHVwZGF0ZWRfdG9rZW5zLCBpbmRleCwgdGhpcywgeSwgTmVzdGVkT3JpZ2luYWxJdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsLnZhbHVlID09ICc9JyAmJiBlbC5pc05lc3RlZExvb3AgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsIGluZGV4LCB1cGRhdGVkX3Rva2VucywgeSwgTmVzdGVkT3JpZ2luYWxJdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT0gJ2NvbmRpdGlvbicgJiYgZWwuaXNOZXN0ZWRMb29wID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2Vuc1tpXTogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIENvbmRpdGlvblN0YXJ0SW5kZXggPSBpbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdLnZhbHVlOyAvL0hhbmRsZUNvbmRpdGlvbnMgZXZhbHVhdGVzIGNvbmRpdGlvbiBhbmQgcmV0dXJuIHRoZSBpbmRleCBvZiBmcm9tIHdoZXJlIHByaW50aW5nIHNob3VsZCByZXN1bWUKICAgICAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSBvZiBpIGRlcGVuZHMgb24gdGhlIGNvbmRpdGlvbnMKCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdmFsdWUzID0gR2V0Q29uZGl0aW9uVmFsdWUoY29uZGl0aW9uLCB1cGRhdGVkX3Rva2VucywgaW5kZXgpOwoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaChfdmFsdWUzKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdmFsdWUzID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgLyogIGlmICh2YWx1ZSA9PSBmYWxzZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQmxvY2tMZW5ndGggPSAwCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCbG9ja1N0YXJ0ID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdLnZhbHVlICE9ICd7JykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleCArIDFdLnZhbHVlID09ICd7JykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCbG9ja0xlbmd0aCA9IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXggKyAxXS5FbmRJbmRleCAtIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXggKyAxXS5zdGFydEluZGV4CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gQmxvY2tMZW5ndGggKyBpbmRleCArIDEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih2YWx1ZT09dHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlbCxOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLGluZGV4KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAqLwoKICAgICAgICAgICAgICAgICAgICAgIH0gLy8gaSA9IGkgKyBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aAogICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiICYmIGVsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsIF9pNywgaiwgdXBkYXRlZF90b2tlbnMsIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pN10udmFsdWUgPT0gJz0nICYmIGlzTmVzdGVkID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCiAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhTb3VyY2VkYXRhVG9rZW5zLCBfaTcsIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcik7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pN10udHlwZSA9PSAnUHVzaFRvQXJyYXknKSB7CiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBTb3VyY2VkYXRhVG9rZW5zW19pN10udmFsdWU7CiAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW4ucmVwbGFjZSgn4KSq4KWB4KS2JywgJycpOwogICAgICAgICAgICAgICAgICB2YXIgU3BsaXQgPSB0b2tlbi5zcGxpdCgnLicpOwogICAgICAgICAgICAgICAgICB2YXIgQXJyYXkgPSBTcGxpdFswXTsKICAgICAgICAgICAgICAgICAgdmFyIEVsZW1lbnR0b1B1c2ggPSBSZW1vdmVCcmFja2V0cyhTcGxpdFsxXSk7CiAgICAgICAgICAgICAgICAgIEVsZW1lbnR0b1B1c2ggPSB1cGRhdGVkX3Rva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IEVsZW1lbnR0b1B1c2g7CiAgICAgICAgICAgICAgICAgIH0pLnZhbHVlOwogICAgICAgICAgICAgICAgICB2YXIgQXJyYXlFbCA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT0gQXJyYXk7CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB2YXIgQXJyYXlWYWx1ZSA9IEFycmF5RWwudmFsdWU7CgogICAgICAgICAgICAgICAgICBpZiAoQXJyYXlWYWx1ZSA9PSAnW10nKSB7CiAgICAgICAgICAgICAgICAgICAgQXJyYXlWYWx1ZSA9IEFycmF5VmFsdWUuc3BsaXQoJywnKTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgQXJyYXlWYWx1ZS5wdXNoKEVsZW1lbnR0b1B1c2gpOwogICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB1cGRhdGVkX3Rva2Vucy5pbmRleE9mKEFycmF5RWwpOwogICAgICAgICAgICAgICAgICBBcnJheVZhbHVlID0gQXJyYXlWYWx1ZS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9ICdbXSc7CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vuc1tpbmRleF0udmFsdWUgPSBBcnJheVZhbHVlOwogICAgICAgICAgICAgICAgfSkoKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2k3XS50eXBlID09ICdBY2NlcHRJbnB1dCcpIHsKICAgICAgICAgICAgICAgIHZhciBfU2V0SW5wdXRWYWx1ZUFzNSA9IFNvdXJjZWRhdGFUb2tlbnNbX2k3XS50eXBlLkFjY2VwdEFzOwogICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvbXB0KCdFbnRlciBWYWx1ZSBmb3InICsgX1NldElucHV0VmFsdWVBczUpOwogICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgIG5hbWU6IF9TZXRJbnB1dFZhbHVlQXM1LAogICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0gLy9IYW5kbGluZyBwcmludCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTddLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIGlzTmVzdGVkID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgIC8vZm9yIG9wZXJhdGlvbnMgbGlrZSBwcmludChhcnJheVszXSkKICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZvciBsb29vcCBwcmludHM6ICcsIFNvdXJjZWRhdGFUb2tlbnNbaV0saSk7CiAgICAgICAgICAgICAgICAgIElmVG9rZW5QcmludChTb3VyY2VkYXRhVG9rZW5zLCB1cGRhdGVkX3Rva2VucywgX2k3LCB0aGlzLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcik7IC8vCiAgICAgICAgICAgICAgICB9IC8vSGFuZGxpbmcgc2V0IGFycmF5IGVsZW1lbnQgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAogICAgICAgICAgICAgICAgZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTddLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIpIHsKICAgICAgICAgICAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUoU291cmNlZGF0YVRva2VucywgX2k3LCBqLCB1cGRhdGVkX3Rva2VucywgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgIH0gLy8gSGFuZGxpbmcgQ09ORElUSU9OQUwgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAogICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pN10udHlwZSA9PSAnY29uZGl0aW9uJykgewogICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2Vuc1tpXTogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKICAgICAgICAgICAgICAgICAgICAgIHZhciBfQ29uZGl0aW9uU3RhcnRJbmRleDIgPSBfaTc7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbmRpdGlvbjIgPSBTb3VyY2VkYXRhVG9rZW5zW19pN10udmFsdWU7IC8vSGFuZGxlQ29uZGl0aW9ucyBldmFsdWF0ZXMgY29uZGl0aW9uIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mIGZyb20gd2hlcmUgcHJpbnRpbmcgc2hvdWxkIHJlc3VtZQogICAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSBvZiBpIGRlcGVuZHMgb24gdGhlIGNvbmRpdGlvbnMKCiAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbmRpdGlvbjIuaW5jbHVkZXMoJ3x8JykgfHwgX2NvbmRpdGlvbjIuaW5jbHVkZXMoJyYmJykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF92YWx1ZTQgPSBHZXRDb25kaXRpb25WYWx1ZShfY29uZGl0aW9uMiwgdXBkYXRlZF90b2tlbnMsIF9pNyk7CgogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkxhc3RDb25kaXRpb25WYWx1ZS5wdXNoKF92YWx1ZTQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF92YWx1ZTQgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQmxvY2tMZW5ndGggPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBCbG9ja1N0YXJ0ID0gMDsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFNvdXJjZWRhdGFUb2tlbnNbX2k3XS52YWx1ZSAhPSAneycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pNyArIDFdLnZhbHVlID09ICd7JykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCbG9ja0xlbmd0aCA9IFNvdXJjZWRhdGFUb2tlbnNbX2k3ICsgMV0uRW5kSW5kZXggLSBTb3VyY2VkYXRhVG9rZW5zW19pNyArIDFdLnN0YXJ0SW5kZXg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNyA9IEJsb2NrTGVuZ3RoICsgX2k3ICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2k3Kys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIF9pNyA9IF9pNzsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgX2k3ID0gSGFuZGxlQ29uZGl0aW9ucyhTb3VyY2VkYXRhVG9rZW5zLCBfaTcsIHVwZGF0ZWRfdG9rZW5zKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTcgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgX2k3ID0gX2k3OwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgIF9pNyA9IF9Db25kaXRpb25TdGFydEluZGV4MjsgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gLy9jb25zb2xlLmxvZygnajogJywgaik7CgoKICAgICAgICAgIGogPSBqICsgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IC8vY29uc29sZS5sb2coJ2o6ICcsIGopOwogICAgICAgIH0gLy9FTkQgRk9SIExPT1AgRVhFQ1VUSU9OCgogICAgICB9IC8vVG8gZmluZCB1bmRlZmluZWQgdmFyaWFibGVzCiAgICAgIC8vCgoKICAgICAgZnVuY3Rpb24gb25seVVuaXF1ZSh2YWx1ZSwgaW5kZXgsIHNlbGYpIHsKICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7CiAgICAgIH0KCiAgICAgIHZhciBhc3NpZ25lZF92YXJpYWJsZXMgPSBhc3NpZ25lZF92YXJpYWJsZXMuZmlsdGVyKG9ubHlVbmlxdWUpOwogICAgICB2YXIgZGlmZmVyZW5jZSA9IHZhcmlhYmxlc19hcnJheS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsKICAgICAgICByZXR1cm4gIWFzc2lnbmVkX3ZhcmlhYmxlcy5pbmNsdWRlcyh4KTsKICAgICAgfSk7CgogICAgICBpZiAoZGlmZmVyZW5jZS5sZW5ndGggPiAwKSB7CiAgICAgICAgZGlmZmVyZW5jZS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgX3RoaXMuZXJyb3IucHVzaCgnVmFyaWFibGUgJyArIGVsICsgJyBpcyB1bmRlZmluZWQgJyk7CiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmVycm9yLmxlbmd0aCA+IDApIHsKICAgICAgICB0aGlzLmxpbmVieWxpbmVPdXRwdXQgPSB0aGlzLmVycm9yOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMubGluZWJ5bGluZU91dHB1dCA9IHRoaXMub3V0cHV0LnNwbGl0KCdcbicpOwogICAgICB9CgogICAgICB2YXIgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTsKCiAgICAgIGlmICh0aGlzLmxpbmVieWxpbmVPdXRwdXQgIT0gJycgJiYgdGhpcy5lcnJvci5sZW5ndGggPT0gMCkgewogICAgICAgIHRoaXMuVGltZVRha2VuID0gIkNvbXBpbGVkIFN1Y2Nlc2Z1bGx5IGluICIgKyAodDEgLSB0MCkudG9QcmVjaXNpb24oNCkgKyAiIG1zLiI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5pc0Vycm9yID0gdHJ1ZTsKICAgICAgICB0aGlzLlRpbWVUYWtlbiA9ICJDb21waWxhdGlvbiBFcnJvcjogQ2hlY2sgZm9yIGFzc2lnbmVtZW50IGFuZCBkZWNsYXJhdGlvbiBtaXN0eXBpbmciOwogICAgICB9CgogICAgICB0aGlzLmxpbmVieWxpbmVPdXRwdXQgPSB0aGlzLmxpbmVieWxpbmVPdXRwdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgcmV0dXJuIGl0ZW0gIT09ICIiOwogICAgICB9KTsgLy9TRUNUSU9OIC0gQ2FsY3VsYXRpbmcgcmVtYWluaW5nIHZhbHVlcwogICAgICAvL3NvIHRoYXQgcmVwbGFjZSB4IHdpdGggdmFsdWVzCgogICAgICAvKgogICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewogICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZWwudmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmluZyB0aGUgIigiIiBhbmQgIikiCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDbGVhbmVkRWxlbWVudCA9IFJlbW92ZUJyYWNrZXRzKGVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gJycKICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2h5IHB1cmVldmFsPwogICAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9ucyBsaWtlIDUwKzYwIHdlcmUgc2V0IGFzIFs1LDAsKyw2LDBdIGluc3RlYWQgb2YgWzUwLCssNjBdLiBiYXNpY2FsbHkgZGlyZWN0IGNhbGN1bGF0aW9uIHdhcyBub3Qgd29ya2luZwogICAgICAgICAgICAgICAgICAgICAgLy9wdXJlZXZhbCBmaW5kcyBzdWNoIHB1cmUgb3BlcmF0aW9ucyBhbmQgdGhlbiBjYWxjdWxhdGUgdGhlbSB0byBkaXJlY3RseSBzZXQgdGhlaXIgdmFsdWUKICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBzaGl0IGlzIG9ubHkgZm9yIHB1cmVvcGVyYXRpb25zCiAgICAgICAgICAgICAgICAgICAgICBsZXQgcHVyZXZhbCA9IC9eKFstK10/WzAtOV0qXC4/WzAtOV0rW1wvXCtcLVwqXSkrKFstK10/WzAtOV0qXC4/WzAtOV0rKSokL2dtLnRlc3QoQ2xlYW5lZEVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB1cmV2YWwgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zW2ldLnZhbHVlID0gZXZhbCh1cGRhdGVkX3Rva2Vuc1tpXS52YWx1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGN1bGF0aW9uKENsZWFuZWRFbGVtZW50KSA9PSB0cnVlICYmICFwdXJldmFsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1zID0gQ2xlYW5lZEVsZW1lbnQuc3BsaXQoJycpCiAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zCiAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewogICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleHRvQ2hhbmdlID0gJycgLy90byBrbm93IHdoaWNoIHZhbHVlIHRvIHJlcGxhY2UgbGlrZSAiYW5uYStkYWRhLWJhZCIgd2l0aCAiNSs2LTciCiAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsLnZhbHVlIC8vIHJlYWRpbmcgdGhlIGN1cnJlbnQgdmFsdWUsIGZvciBsb24gc3RyaW5nIHZhcmlhYmxlIG5hbWVzIGl0J3Mgc3RpbGwgbGlrZSAiYW5uYStkYWRhLWJhZCIKICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnRvU3RyaW5nKCkKICAgICAgICAgICAgICAgICAgICAgIHZhciBTdHJpbmdWYXIgPSBbXQogICAgICAgICAgICAgICAgICAgICAgLy8gCiAgICAgICAgICAgICAgICAgICAgICAgbGV0IHB1cmV2YWwgPSAvXihbLStdP1thLXpdKlwuP1thLXpdK1tcL1wrXC1cKl0pKyhbLStdP1thLXpdKlwuP1thLXpdKykqJC9nbS50ZXN0KGVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygnPicpIHx8IGVsZW1lbnQuaW5jbHVkZXMoJzwnKSB8fCBlbGVtZW50LmluY2x1ZGVzKCc9PScpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3BsaXRFbGVtZW50c0FycmF5KGVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU2V0VmFsdWVzKFN0cmluZ1ZhciwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGVVcGRhdGVkX3Rva2Vuc3dpdGhWYWx1ZXMoU3RyaW5nVmFyLCBpLCB1cGRhdGVkX3Rva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmluZGluZyBvcGVyYXRpb25zIGxpa2UgYStiLWMKICAgICAgICAgICAgICAgICAgICAgIGlmIChwdXJldmFsID09IHRydWUgfHwgZWxlbWVudC5jaGFyQXQoMCkgPT0gIigiKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3BsaXRFbGVtZW50c0FycmF5KGVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU2V0VmFsdWVzKFN0cmluZ1ZhciwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRlVXBkYXRlZF90b2tlbnN3aXRoVmFsdWVzKFN0cmluZ1ZhciwgaSwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAvKgogICAgICAgICAgICAgICAgICAgUmVJbnRpYWxpemVkVmFyaWFibGVzLmZvckVhY2goZWw9PnsKICAgICAgICAgICAgICAgICAgIGxldCBmbGFnPTAKICAgICAgICAgICAgICAgICAgbGV0IFNraXBJbmRleD0wCiAgICAgICAgICAgICAgICAgICBmb3IobGV0IG09MDttPHVwZGF0ZWRfdG9rZW5zLmxlbmd0aDttKyspCiAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICBpZihlbC5uYW1lPT11cGRhdGVkX3Rva2Vuc1ttXS5uYW1lICYmIGZsYWc9PTApCiAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBpZihlbC52YWx1ZS5jaGFyQXQoMCk9PSciJykKICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBsZXQgQnVpbHRTdHJpbmc9IEJ1aWxkU3RyaW5nKGVsLnZhbHVlLCApCiAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZmxhZz0xOwogICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vuc1ttXS52YWx1ZT1lbC52YWx1ZTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgIFNraXBJbmRleD1tCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgIGlmKCBtIT1Ta2lwSW5kZXggJiYgZmxhZz09MSAmJiBlbC5uYW1lPT11cGRhdGVkX3Rva2Vuc1ttXS5uYW1lKQogICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMuc3BsaWNlKG0sMSkKICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAqLwogICAgICAvL1NFQ1RJT04gLSBJdGVyYXRpbmcgb3ZlciB0b2tlbnMgYW5kIHRoZW4gUFJJTlRJTkcgRklOQUwgdXNpbmcgdmFsdWVzIHN0b3JlZCBpbiB1cGRhdGVkIHRva2VucwoKICAgICAgLyogICAgICAgIAogICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykgewogICAgICAgIHZhciBtdXRhYmxlX3Rva2VucyA9IHRva2VucwogICAgICB2YXIgdG9rZW4gPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZQogICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gJ+CkquCljeCksOCkv+CkguCknycgKQogICAgICAgewogICAgICAgICAgIHZhciBiID0gUmVtb3ZlQnJhY2tldHMobXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZSkKICAgICAgICAgICAgICB2YXJpYWJsZXNfYXJyYXkucHVzaChiKQogICAgICAgICAgIAogICAgICAgIAogICAgICAgICAgLy9TRUNUSU9OIC0gT3V0cHV0dGluZyB0aGUgY29kZQogICAgICAgICAgLy8gZmluZGluZyB0aGUgcmVsdmFudCB2YWx1ZSBhbmQgdGhlbiBvdXRwdXQgaXQgYXMgSFRNTAogICAgICAgICAgdXBkYXRlZF90b2tlbnMuZm9yRWFjaCgoZWwsIGkpID0+IHsKICAgICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gYiApIHsKICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dCArIGVsLnZhbHVlICsgIlxuIjsKICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsLm5hbWUpOwogICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAvLyB3b3JrIHRvIGJlIGNvbnRpbnVlZAogICAgICAgICAgIH0pCiAgICAgICAgICAgCiAgICAgICAgICAgCiAgICAgICB9CiAgICAgICAgLy9IYW5kbGluZyBDb25kaXRpb25zCiAgICAgICBpZihtdXRhYmxlX3Rva2Vuc1tqXS50eXBlPT0iY29uZGl0aW9uIikKICAgICAgewogICAgICAgICAgICAKICAgICAgICAgICBsZXQgdG9rZW49IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZWw9PiBlbC5vcmlnaW5hbHZhbHVlPT1tdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSkKICAgICAgICAgICAgIGxldCBDb25kaXRpb25WYWx1ZT10b2tlbi52YWx1ZQogICAgICAgICAKICAgICAgICAgIGlmKENvbmRpdGlvblZhbHVlPT1mYWxzZSkKICAgICAgICAgewogICAgICBsZXQgSW5pdGlhbGl6ZUxvb3A9IHRva2Vucy5pbmRleE9mKG11dGFibGVfdG9rZW5zW2pdKQogICAgICB3aGlsZShtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlIT0nfScgKQogICAgICB7CiAgICAgIGxldCB4PSBtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlLmxlbmd0aAogICAgICB0b2tlbnMuc3BsaWNlKGorMSwgMSk7CiAgICAgIGorKzsKICAgICAgfQogICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZih0b2tlbiA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJyAmJiAvXihbLStdP1swLTldKlwuP1swLTldK1tcL1wrXC1cKl0pKyhbLStdP1swLTldKlwuP1swLTldKykqJC9nbS50ZXN0KG11dGFibGVfdG9rZW5zW2orMV0udmFsdWUpICkKICAgICAgewogICAgICAgIGxldCBhPSBldmFsKG11dGFibGVfdG9rZW5zW2orMV0udmFsdWUpCiAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0ICsgIlxuIiArIGEgKyAiXG4iCiAgICAgICB9CiAgICAgICAKICAgICAgICAgICAgICAKICAgICAgLy8gdGhpcyBpcyB0byBoYW5kbGUg4KSq4KWN4KSw4KS/4KSC4KSfICgiQWdlIGlzIisgQWdlKSBldGMuCiAgICAgICBpZihpc1N0cmluZ2FuZFZhbHVlKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlKSkKICAgICAgewogICAgICAgICAgICAgICAgICAgICAgbGV0IHg9bXV0YWJsZV90b2tlbnNbal0udmFsdWUKICAgICAgICAgIGxldCBzdHJpbmc9JycKICAgICAgICAgIGxldCBuZXdlbD0nJwogICAgICAgICAgIHg9UmVtb3ZlQnJhY2tldHMoeCkKICAgICAgICAgICAKICAgICAgICAgIC8veCA9IHgucmVwbGFjZSgvIC9nLCcnKQogICAgICAgICAgIHg9eC5zcGxpdCgiKyIpCiAgICAgICAgICAgCiAgICAgICAgICAgeC5mb3JFYWNoKGVsZW1lbnQgPT4gewogICAgICAgICAgICAgIAogICAgICAgICAgICAgICAKICAgICAgICAgICAgICBpZihlbGVtZW50LmNoYXJBdCgwKT09ICIgIiB8fCBlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aC0xKT09IiAiICYmICEoZWxlbWVudC5pbmNsdWRlcygnIicpKSl7CiAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICBuZXdlbD0gZWxlbWVudC5yZXBsYWNlKC9ccy9nLCAnJyk7CiAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVsc2V7CiAgICAgICAgICAgICAgICAgICBuZXdlbD1lbGVtZW50CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGxldCB5PSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsPT4gZWwubmFtZT09IG5ld2VsKQogICAgICAgICAgICAgCiAgICAgICAgICAgICAKICAgICAgLy8KICAgICAgICAgICAgIGlmKHkhPXVuZGVmaW5lZCkKICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHN0cmluZz1zdHJpbmcgKyAnICcgKyB5LnZhbHVlCiAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICB9CiAgICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICBlbGVtZW50PSBlbGVtZW50LnJlcGxhY2UoLyIvZywgJycpOwogICAgICAgICAgICAgICAgIHN0cmluZz1zdHJpbmcrICcgJyArIGVsZW1lbnQKICAgICAgICAgICAgIH0KICAgICAgICAgICAgIAogICAgICAgICAgICAgIAogICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQgKyAiXG4iICsgc3RyaW5nICsgIlxuIgogICAgICB9CiAgICAgIC8vVEhJUyBJUyB0byBoYW5kbGUgb3BlcmF0aW9ucyBsaWtlIOCkquCljeCksOCkv+CkguCknyAoIk5hbWUgaXMgR09BVCIpLCDgpKrgpY3gpLDgpL/gpILgpJ8gKCJHb29kYnllIikKICAgICAgZWxzZXsKICAgICAgICAgICBsZXQgdmFsdWU9IFJlbW92ZUJyYWNrZXRzKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlKQogICAgICAgLy8gCiAgICAgICAgIAogICAgICAgICAgbGV0IENsZWFuZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyAvZywnJykKICAgICAgICAgICAKICAgICAgICAgICBpZigvXihbLStdP1swLTldKlwuP1swLTldK1tcL1wrXC1cKl0pKyhbLStdP1swLTldKlwuP1swLTldKykqJC9nbS50ZXN0KENsZWFuZWRWYWx1ZSkhPXRydWUpCiAgICAgICAgICB7CiAgICAgICAgLy8gCiAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8iL2csICIiKTsKICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvJy9nLCAiIik7CiAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dCArICJcbiIgKyB2YWx1ZSArICJcbiIgCiAgICAgIH0KICAgICAgICAgICAgICAKICAgICAgfQogICAgICB9CiAgICAgICAgICAgICAgICB9KQogICAgICB9CiAgICAgICovCiAgICB9CiAgfQp9Ow=="},{"version":3,"sources":["Practise.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"hello\">\n   \n <Header/>\n\n   <div id=\"compiler\">\n\n\n   <div id=\"textarea\">\n\n\n\n\n   <!-- <textarea  onkeydown=\"if(event.keyCode===9){var v=this.value,s=this.selectionStart,e=this.selectionEnd;this.value=v.substring(0, s)+'\\t'+v.substring(e);this.selectionStart=this.selectionEnd=s+1;return false;}\" ref=\"textareaID\" placeholder=\"Welcome To Kalaam, This is your Code cm.\" v-model=\"code\" type=\"text\" name=\"code\" id=\"codearea\"></textarea>-->\n\n  <no-ssr placeholder=\"Codemirror Loading...\">\n\n  <codemirror id=\"codearea\" style=\"text-align:left;\" ref=\"myCm\"\n              :value=\"code\" \n              placeholder=\"Welcome To Kalaam, This is your Code Editor.\"\n              :options=\"cmOptions\"\n              @ready=\"onCmReady\"\n              @focus=\"onCmFocus\"\n              @input=\"onCmCodeChange\">\n  </codemirror>\n  </no-ssr>\n\n    <button style=\"background: linear-gradient(to right, #11998e, #12ff6b);\n    border: none;\n    font-weight: 600;\" id=\"subm\" @click=\"RUN()\">RUN</button>\n        <button id=\"subm\" @click=\"Add('()')\"></button>\n<button id=\"subm\" @click=\"Add('')\"></button>\n    <button id=\"subm\" @click=\"Add('()')\"></button>\n\n    <button id=\"subm\" @click=\"Add('()')\"></button>\n\n    <button id=\"subm\" @click=\"Add(' x  y ')\"> </button>\n    <button id=\"subm\" @click=\"Add('()')\"></button>\n    <button id=\"subm\" @click=\"Add('.()')\">.</button>\n    <button id=\"subm\" @click=\"Add('.()')\">.</button>\n    <button id=\"subm\" @click=\"Add('')\"></button>\n    \n\n   \n   </div>\n\n    <div id=\"output\">\n\n<div id=\"bharatDIV\">\n\n<p id=\"version\">Kalam v1.0.0</p>\n<p id=\"CodeStatus\" v-if=\"this.isError==false\">{{TimeTaken}}</p>\n        \n<p id=\"CodeStatus\" v-if=\"this.isError==true\" >{{TimeTaken}}</p>\n        \n\n<div id=\"printOutput\">\n\n<p style=\"white-space: pre; \"  id=\"linebylineOutput\" v-for=\"(output,index) in this.linebylineOutput\" :key=\"index\">\n\n\n {{output}} \n\n\n\n</p>\n</div>\n</div>\n\n\n\n\n    </div>\n</div>\n  \n\n    \n      \n  </div>\n</template>\n\n<script>\nimport Header from '../components/Header'\n\nimport { codemirror } from 'vue-codemirror'\n \n// require styles\nimport 'codemirror/lib/codemirror.css'\n   import {\n    SourceDataReplaceforEasyParsing\n} from '../FunctionScripts/functions'\nimport * as TypeCheck from '../FunctionScripts/TypeChecking'\nimport * as AdvancedTypeCheck from '../FunctionScripts/AdvancedTypeChecking'\nimport * as BuildOperation from '../FunctionScripts/BuildOperations'\nimport {\n    PushArray,\n    PushCalculation,\n    PushConditionalKeyword,\n    PushCondition,\n    PushForLoop,\n    PushWhileLoop,\n    PushWhileLoopCondition,\n    PushForLoopAruguments,\n    PushExpression,\n    PushKeyword,\n    PushNumber,\n    PushOperator,\n    PushRealTimePrintOperation,\n    PushString,\n    PushStringandValueOperation,\n    PushVariable,\n    PushVariableValue,\n    PushFunctionData,\n    PushFunctionExecution,\n    PushToArray,\n    PushInput\n\n} from '../FunctionScripts/PushFunctions'\nimport {\n    RemoveBrackets,\n    Count,\n    ResetValue,\n    isArrayOperation,\n    CreateArrayElement,\n    CalculateValues,\n    GetArrayorStringElement,\n    SetArrayorStringElement,\n    PrintArrayElement,\n    handlemultConditions,\n    HandleBlocks,\n    SplitElementsArray,\n    SetValues,\n    PushSetArrayIndexValue,\n    PushGetArrayIndexValue,\n    UpdateUpdated_tokenswithValues,\n    GetConditionValue,\n    ForLoopArrayorStringOutput,\n    AssignorUpdateValues,\n    HandleConditions,\n    getLoopIndexStart,\n    ForLoopSetMetadata,\n    SetArrayIndexValue\n} from '../FunctionScripts/MiscImportantFunctions'\n\nimport { mapState } from 'vuex'\n\n\n\nexport default {\n    name: \"HelloWorld\",\n    props: {\n        msg: String\n    },\n\n   \n      computed: mapState(['CurrentCode']),\n\n\n    data() {\n        return {\n            code:'',\nCodeinuse:'',\n           \n \n            output: '',\n            cm:'',\n            error: [],\n            OperationObjects: [],\n            linebylineOutput: '',\n            TimeTaken: '',\n            inputIndexes: [],\n            input: '',\n            isError:'',\n            LastConditionValue:[],\n            LineByLineCode:[],\n            cmOptions: {\n        // codemirror options\n        tabSize: 4,\n        lineNumbers: true,\n        line: true,\n        theme:''\n      }\n\n        };\n    },\n      components: {\n    codemirror,\n    Header\n  },\n\n mounted() {\n    console.log('this is current codemirror object', this.codemirror)\n    // you can use this.codemirror to do something...\n  },\n\n    created(){\n\n\n\nlet m=this.$store.state.CurrentCode.replace('&lt;','<')\nm=m.replace('&gt;','>')\nthis.code=m\n\n\n\n/*\nthis.Codeinuse=m\n\n\nif(this.code.length>0)\n{\n\nthis.LineByLineCode=this.code.split(\"\\n\")\n\nthis.LineByLineCode.forEach((el,index)=>{\n    \n\n\nel= (index+1) + '  ' + el\n\nthis.LineByLineCode[index]=el + '\\n'\n\n\n})\n\n \n this.LineByLineCode=this.LineByLineCode.join('\\n')\n\n this.code=this.LineByLineCode\n\n}\n \n*/\n\n    },\n\n    methods: {\n\n\n onCmReady(cm) {\n      console.log('the editor is readied!', cm)\n\n     \n\nthis.cm=cm;\n\nif(screen.width<420)\n{\n\n this.cm.setSize('100%', 300);\n\n}\nelse{\n\n this.cm.setSize('100%', 500);\n}\n\n\n    },\n    onCmFocus(cm) {\n    \n\n\n      //this.cm=cm\n    },\n    onCmCodeChange(newCode) {\n      //console.log('this is new code', newCode)\n      this.code = newCode\n    },\n\nAdd:function(insert)\n\n{\n\nvar doc = this.cm.getDoc();\n\n    var cursor = doc.getCursor();\n    doc.replaceRange(insert, cursor);\n \n\n\n\n}\n,\n        RUN: function() {\n\n\n\n                var t0 = performance.now()\n\n                this.isError=false\n\n                //to stop accumulating output on succesive RUN\n                this.output = ''\n                this.input = '',\n                    this.linebylineOutput = this.output.split(\"\\n\")\n                this.inputIndexes = []\n                this.error = []\n                this.OperationObjects = []\n                var sourcedata = this.code;\n                var cleaned_sourcedata = []\n                var i = 0;\n                var tokens = [];\n                var mixedimpurity = []\n                var updated_tokens = []\n                var functionContextupdated_tokens = []\n                var variables_array = []\n                var assigned_variables = []\n                var terms = []\n                var terms2 = []\n                var operation = ''\n                var CalculationStack = []\n                var foundToken = ''\n                var ReIntializedVariables = []\n                var tempthis=this\n\n                //emptying accumulatedvalue stored for operations like Name= Name+Array[i]\n                //See AssignorUpdateValues fuction for more\n                ResetValue()\n\n\n               \n\n                function AddOutput(tempthis,value)\n                {\n\n\n\n                tempthis.output = tempthis.output + value + \"\\n\";\n                \n                \n\n\n\n                }\n\n\n                //preparing sourcedata for easy parsing by handling new lines, enters etc.\n                //cleaning up the data to get my version of sourcedata. it's better to get version suitable for me because users can type what they wish but I need to maintain \n                //integrity of program in every possible conditio. So. I created my own condition below\n\n                function GetCleanSourcedata(sourcedata, cleaned_sourcedata, impurities) {\n\n                    sourcedata = SourceDataReplaceforEasyParsing(sourcedata)\n\n                    sourcedata.forEach((element, i) => {\n\n\n                        //finding the elements which has =\" in it so that to seprate them e.g. anna=\"swanand\" also finding the elements which starts with =. e.g \"=78787890\"\n\n\n\n                        if (!element.includes('==') && (element.indexOf('=\"') > -1 || element.indexOf('=') > 0 || element.charAt(0) == \"=\") && element != '==')\n\n\n                        {\n\n\n\n                            impurities.push(element) //push such element as impurity in impurities\n\n\n\n                            let elements = element.split(\"=\")\n                            let index = cleaned_sourcedata.length\n\n\n                            cleaned_sourcedata[index] = (elements[0])\n                            cleaned_sourcedata[index + 1] = (\"=\")\n                            cleaned_sourcedata[index + 2] = (elements[1])\n\n\n\n                        }\n\n                       \n\n                        //as long as element is pure, push it to new and clean version of sourcedata\n                        if (!impurities.includes(element)) {\n\n\n\n                            cleaned_sourcedata.push(element)\n\n                        }\n\n                        //\n\n                    })\n\n\n                    //removing empty \"\" values for final version of sourcedata\n                    //SECTION FInal sourcedata cleaning\n\n                    cleaned_sourcedata = cleaned_sourcedata.filter(function(item) {\n\n                        return item !== \"\"\n                    })\n\n\n\n                    return cleaned_sourcedata;\n\n                }\n\n\n                let Result = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity)\n\n                cleaned_sourcedata = Result\n                console.log('cleaned_sourcedata: ', cleaned_sourcedata);\n\n\n\n\n                //SECTION - Checking for type of characters\n\n\n                const isVariable = TypeCheck.isVariable()\n                const isNumber = TypeCheck.isNumber()\n\n                const isOperator = TypeCheck.isOperator()\n\n                const isKeyword = TypeCheck.isKeyword()\n                const isConditionalKeyword = TypeCheck.isConditionalKeyword()\n                const isForLoop = TypeCheck.isForLoop()\n                const isWhileLoop = TypeCheck.isWhileLoop()\n                const isFunction = TypeCheck.isFunction()\n                //needs work\n                const isExpression = TypeCheck.isExpression()\n\n                const isArray = TypeCheck.isArray()\n                const isInput = TypeCheck.isInput()\n\n                const isSetArrayIndexValue = TypeCheck.isSetArrayIndexValue()\n\n                // const isEmptyArrayInit = TypeCheck.isEmptyArrayInit()\n\n                const isString = TypeCheck.isString()\n                const isEmptyStringorChar = TypeCheck.isEmptyStringorChar()\n\n                const isPureEval = AdvancedTypeCheck.isPureEval()\n\n                //if parser encounters anything like (\" or (, then that's a realtime print. \n                //buildstring will be applied now to create a string and push it into tokens\n\n                const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString()\n\n\n\n                const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n                const isCalculation = AdvancedTypeCheck.isCalculation()\n\n                const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n\n\n\n\n                //SECTION Build Operations \n\n\n                const BuildString = BuildOperation.BuildString()\n\n                const BuildArray = BuildOperation.BuildArray()\n\n                //this function is the first step to handlle operations like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n\n                const BuildCondition = BuildOperation.BuildCondition()\n\n\n\n                //This will run for every print statement encountered in the program, not just for loops\n\n                function IfTokenPrint(Tokens, updated_tokens, j, global, iterator, OriginalIterator)\n\n\n\n\n                {\n\n\n                    var token = Tokens[j].value\n                    \n\n\n\n                    var NextTokenValue = Tokens[j + 1].value\n                    \n                    \n                    \n                    //NextTokenValue = NextTokenValue.replace(\"+\", ' + ')\n                    \n\n\n\n\n                    var StringVar = []\n\n                    var b = RemoveBrackets(NextTokenValue)\n                    \n                    \n                    \n\n                    if (isVariable(b) && !variables_array.includes(b)) {\n\n                        variables_array.push(b)\n                        // \n\n                    }\n\n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n\n                    //This loop is only for printing direct values like print(name), print(array)\n                    updated_tokens.forEach((el, i) => {\n                        \n                        \n                        \n                        \n                        \n\n\n                        if (el.name == b) {\n                            \n                            \n\n                            //for calculations like x=ageone+agetwo\n\n                            //If we have already caluculated value, use that or else move forward\n\n\n\n\n                            if (assigned_variables.includes(el)||assigned_variables.includes(el.name) ) {\n\n\n                                \n\n                                AddOutput(global, el.value)\n\n\n\n                            } else {\n\n\n                                if (isNumber(el.value)) {\n                                    \n                                    \n\n\n\n                                     AddOutput(global, el.value)\n\nassigned_variables.push(el.name);\n\n\n\n\n                                }\n\n                                //operations like age=2020-1996\n                                else if (isPureEval(el.value)) {\n\n\n\n\n                                    let outputpure = eval(el.value)\n\n\n\n                                    el.value = outputpure\n\n\n                                     AddOutput(global, el.value)\n\n                                    assigned_variables.push(el.name);\n\n                                }\n\n\n\n                                //operations like name=\"swanand kadam\", variable assignments as strings\n                                else if (!isPureEval(el.value) && !isNumber(el.value))\n                                \n\n\n                                {\n\n\n\n                                    if (!(el.name.includes(']') && el.name.includes('['))) {\n\n\n                                        if(el.type=='Array')\n                                        {\n\n\nif (el.value.includes('[')==false)\n\n{\n\nel.value='['+el.value.toString()+']'\n\n\n\n}\n\n                                        }\n\n                                        AddOutput(global, el.value)\n                                        \n                                        \n\n\n\n                                        assigned_variables.push(el.name);\n                                    }\n\n\n\n\n                                }\n\n\n                            }\n\n                        }\n\n\n\n\n                        // work to be continued\n                    })\n\n\n                    //ANCHOR - CONDITION 2\n                    if (Tokens[j + 1].type == 'Array')\n\n\n\n\n                    {\n\n                        //To run only if iterator is present\n\n                        //This runs on for loop - Print(Array[a]) etc\n\n                        //this runs only if for(i) and in the loop, array[i], not on array[x]. Iterator and index should be same\n\n                        if (iterator != undefined && Tokens[j + 1].IndexInput == OriginalIterator)\n\n                        {\n\n\n\n                            let Value = NextTokenValue\n                            // console.log('Value: ', Value);\n\n                            let ArrayElement = CreateArrayElement(Value, iterator)\n\n\n                            let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                            AddOutput(global, output)\n\n\n                            assigned_variables.push(Tokens[j + 1]);\n\n\n                        }\n\n\n                        //This runs to Print(Array[2]) like specific array values\n                        else if (Tokens[j+1].IndexInput != OriginalIterator)\n                        \n\n\n                        {\n\n                            //\n\n                            let Value = NextTokenValue\n\n                            let IndexToChange = Tokens[j + 1].IndexInput\n\n\n                            let ArrayElement = CreateArrayElement(Value, IndexToChange)\n\n\n                            let element = ArrayElement.replace(']', '')\n\n\n                            let Split = element.split('[')\n\n\n\n\n                            if (Split[1].includes('-') || Split[1].includes('+')) {\n\n\n                                let output = CalculateValues(Split[1], j, updated_tokens)\n\n                                Split[1] = output\n\n                                Split = Split.join('[') + ']'\n                                ArrayElement = Split\n                                //console.log('ArrayElement: ', ArrayElement);\n\n\n                            }\n\n\n                            let token = updated_tokens.find(el => el.name == Split[1])\n\n                            if (token != undefined && OriginalIterator != Split[1]) {\n\n                                Split[1] = token.value\n\n                                Split = Split.join('[') + ']'\n                                ArrayElement = Split\n\n\n                            } else {\n\n                                ArrayElement = ArrayElement\n                                //console.log('ArrayElement: ', ArrayElement);\n\n                            }\n\n\n                            let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                                        AddOutput(global, output)\n                             console.log('output: ', output);\n\n\n\n\n                        }\n\n\n                    }\n\n\n\n\n                    //printing direct numbers and direct calcultions like print(10), print(10*10)\n                    else if (token == '' && (isPureEval(RemoveBrackets(NextTokenValue)) || isNumber(RemoveBrackets(NextTokenValue)))) {\n\n\n                        NextTokenValue=RemoveBrackets(NextTokenValue)\n                        \n\nif(isNumber(NextTokenValue) && Tokens[j+1].type!='Calculation')\n\n\n{\n   \nAddOutput(global, NextTokenValue)\n\n}\n\nelse{\n\n\nlet a = eval(NextTokenValue)\nconsole.log('a: ', a);\n\n                          AddOutput(global, a)\n\n}\n                        \n                        \n\n                                     \n\n                    }\n\n\n\n\n                    //foroperations like print('you live, you learn')\n                    else if (Tokens[j + 1].mode == \"RealTimePrint\" && !NextTokenValue.includes('+') && !NextTokenValue.includes('='))\n\n                    {\n\n\n                        let output = RemoveBrackets(NextTokenValue)\n\n                        output = output.replace(/\"/g, '');\n                        output = output.replace(/'/g, '');\n\n\n                                        AddOutput(global, output+\"\\n\")\n\n\n\n                    }\n\n                    //operations like print(Age + 'is young age')\n                    else if (Tokens[j + 1].mode == \"RealTimePrint\" && NextTokenValue.includes('+')) {\n\n\n\n                        let x = SplitElementsArray(NextTokenValue)\n\n\n\n\n                        StringVar = SetValues(x, updated_tokens)\n\n\n\n\n                        StringVar = StringVar.join('')\n                        StringVar = StringVar.split(\"+\")\n\n                        let output = StringVar.join(' ')\n                        output = RemoveBrackets(output)\n\n                        AddOutput(global, output+\"\\n\")\n\n\n\n                    } else if ( isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != \"RealTimePrint\")\n                    \n\n\n                    {\n\nNextTokenValue=RemoveBrackets(NextTokenValue)\n\n                        let output = CalculateValues(NextTokenValue, j, updated_tokens)\n\n                        AddOutput(global, output+\"\\n\")\n\n\n                    }\n                    \n\n\n\n\n                }\n\n\n                //END OF Functions and Imported Functions\n\n\n\n                //SECTION - Parsing STARTS here\n\n                //SECTION - Checking each token and adding to tokens array\n\n\n\n            \n                let variableArray = [] //TO REMOVE DUPLICATE VARIABLES, SEE 482\n\n                function Parse(cleaned_sourcedata, i) {\n\n                    var element = cleaned_sourcedata[i];\n\n\n                    var string = []\n\n\n\n\n                    if (isVariable(element) == true) {\n                        \n\n\n\n                        if (cleaned_sourcedata[i + 1] == '=') {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            if (variableArray.includes(element)) {\n\n                                // let UpdateElementValue = element\n\n                                let x = tokens.find(el => el.value == element)\n\n                                let index = tokens.indexOf(x)\n\n\n                                ReIntializedVariables.push({\n                                    name: element\n                                })\n\n                                //\n\n                                //tokens[index+2].value= cleaned_sourcedata[i+2]\n\n\n\n                            }\n\n                            variableArray.push(element)\n\n\n\n\n                        } else if (cleaned_sourcedata[i - 1] == '=') {\n\n\nconsole.log('element: ', element);\n                            PushVariableValue(element, tokens)\n                            \n\n                        }\n\n                    } \n                    \n                    else if (isNumber(element) == true) {\n\n                        PushNumber(element, tokens)\n\n                    } \n\n                    else if(isEmptyStringorChar(element)==true){\n\n\n\n                         if(element.length>1 && (element.charAt(0)==\"'\"||element.charAt(0)=='\"')){\n                             \n\nelement=element.replace(/['\"]+/g, '')\n\n        \n\n    }\n\n    else{\n\n        element=\" \"\n    }\n\n                        \nPushVariableValue(element,tokens)\n\n\n\n\n\n                    }\n                    \n                    else if (isInput(element) == true)\n                    \n\n                    {\n\n                        PushInput(element, tokens, cleaned_sourcedata, i)\n\n\n\n\n                    } \n                    \n                    else if (isOperator(element) == true) {\n                        \n                        PushOperator(element, tokens)\n\n                    } \n                    \n                    else if (isKeyword(element) == true) {\n\n                        PushKeyword(element, tokens)\n\n                    } \n                    \n                    else if (isFunction(element) == true) {\n\n                        PushFunctionData(element, tokens, cleaned_sourcedata, i)\n\n                    }\n\n                    //check if it accpets Arry[2a] as index : \n                    else if (isArray(element) == true) {\n\n\n\n\n                        if (element.charAt(element.length - 1) == ']') {\n\n\n\n                            PushArray(element, tokens)\n\n                        } else {\n\n\n                            let BuiltArray = BuildArray(element, i, cleaned_sourcedata)\n\n                            PushArray(BuiltArray, tokens)\n\n\n\n                        }\n                    }\n\n                    //for Numbers[a]=x\n                    else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == true) {\n\n\n\n\n                        PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n\n\n\n                    }\n\n\n\n                    //for x=Numbers[a]\n                    else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == false) {\n\n\n\n                        PushGetArrayIndexValue(element, tokens, cleaned_sourcedata, i)\n\n\n\n\n                    }\n\n                \n                    else if (isConditionalKeyword(element) == true) {\n\n\n\n                        if (isWhileLoop(element) == true) {\n\n                            PushWhileLoop(element, tokens, cleaned_sourcedata, i)\n                            // PushWhileLoopCondition(element, cleaned_sourcedata, i, tokens)\n\n\n                        } else {\n\n                            PushConditionalKeyword(element, tokens)\n                        }\n\n\n                        let foundcondition = BuildCondition(element, i, cleaned_sourcedata)\n                        // console.log('foundcondition: ', foundcondition);\n\n\n\n                        PushCondition(foundcondition, tokens)\n\n\n\n\n                    } \n\n                    else if(element.includes(''))\n    \n{\n\n   PushToArray(element, tokens)\n\n\n                    }\n                    \n                    \n                    else if (isForLoop(element) == true) {\n\n                        PushForLoop(element, tokens)\n                        PushForLoopAruguments(element, cleaned_sourcedata, i, tokens)\n\n                        updated_tokens.push({\n\n                            name: cleaned_sourcedata[i + 1],\n                            value: 0,\n                            type: 'ForLoopIterator'\n\n                        })\n\n\n                    } \n                    \n                    \n                    else if (isCalculation(element) == true) {\n\n\n                        let element = ''\n\n                        if (cleaned_sourcedata[i + 1] != undefined) {\n\n\n\n                            // this is to perform long operations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n\n                            while (isCalculation(cleaned_sourcedata[i]))\n\n\n\n                            {\n\n\n                                element = element + cleaned_sourcedata[i];\n\n\n                                i++;\n\n                            }\n\n\n\n\n                        }\n\n\n                        //PushCalculation(element,tokens)\n\n\n\n\n                        //  \n                        terms = element.split('')\n\n                        //removing the \"(\"\" and \")\"\n\n                        var CleanedElement = RemoveBrackets(element)\n\n\n                        // to stop prevention of expressions like is\"+ getting added as a calculation\n                        if (!(CleanedElement.includes('\"')) && element.charAt(0) != '/' && element.charAt(0) != '*' && element.charAt(0) != \"'\") {\n\n                            PushCalculation(element, tokens, cleaned_sourcedata, i)\n\n\n\n                        }\n\n                    }\n\n                    //finding operations like print(\"swanand\"). The realtimeprint operations\n                    else if (isRealTimePrintMultipleString(element) == true) {\n\n\n\n                        //\n                        let foundString = ''\n\n                        let k = i\n                        //  console.log('element: ', element);\n                        let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n                        //console.log('conditionEnd: ', conditionEnd);\n\n\n                        var flag = 0;\n\n\n\n\n                        for (k; k < cleaned_sourcedata.length; k++) {\n\n                            let element = cleaned_sourcedata[k]\n                            let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n\n                            if (element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || cleaned_sourcedata[k + 1] == '=' || element == '}') {\n\n\n                                //foundString=foundString+  ' '+ cleaned_sourcedata[k]\n\n                                //\n                                break;\n\n\n                            }\n\n                            if (conditionEnd == ')\"')\n\n                            {\n\n                                foundString = foundString + ' ' + cleaned_sourcedata[k];\n                                break;\n\n                            } else if (flag == 1) {\n\n                                foundString = foundString + ' ' + cleaned_sourcedata[k]\n\n                            } else if (flag == 0) {\n\n                                foundString = cleaned_sourcedata[k];\n\n                                flag = 1;\n\n                            }\n\n\n\n\n                        }\n\n\n\n                        if ((!foundString.includes(\">\")) && (!foundString.includes('/')) && (!foundString.includes('*')) && (!foundString.includes('<')) && (!foundString.includes('==')))\n\n\n                        {\n\n                            //console.log('foundString: ', foundString);\n                            PushRealTimePrintOperation(foundString, tokens)\n\n                        }\n\n\n\n\n                    }\n\n\n\n\n                    //storing only the string values to tokens ( not the strings in print statements)\n                    else if (isString(element))\n                    \n\n\n                    {\n\n\nconsole.log('element: ', element);\n\n                        let calculatedString = BuildString(element, i, cleaned_sourcedata)\n                        console.log('calculatedString: ', calculatedString);\n\n\n\n                        calculatedString = calculatedString.replace(/['\"]+/g, '')\n\n                        if (!(calculatedString.includes(\"\")))\n\n                            PushString(calculatedString, tokens)\n\n                        \n\n\n\n                    }\n\n\n\n\n                    //Found Solution using regexp- print(a) without space is getting accepted as expression\n                    else if (/^(?=.*?)(?=.*[a-z])/.test(element)) {\n\n                        PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n\n\n                        PushExpression(element.slice(6), tokens) //Pushing remaining expression like (a), (gagaks) etc\n                    }\n\n\n                    //error prone change made here- Pushing expression in here\n                    else if (isExpression(element) == true && !isCalculation(element) && !element.includes('[') && !element.includes(']') && (!isConditionalKeyword(cleaned_sourcedata[i - 1])) && (cleaned_sourcedata[i - 1] != '' && cleaned_sourcedata[i - 1] != '')) {\n\n\n\n                       \n\n                            let CheckFunctionExpression = element.split('(')\n                            \n\n\n                            let passedValues = RemoveBrackets(CheckFunctionExpression[1])\n                            passedValues = passedValues.split(',')\n                            let token = tokens.find(el => el.value == CheckFunctionExpression[0])\n\n                            if(token!=undefined)\n                            {\n\n\n\n\n\n\n                           \n\n\nPushFunctionExecution(element,tokens,cleaned_sourcedata,i,passedValues)\n\n                            }\n\n\n                        \n\n                        else{\n\n                        PushExpression(element,tokens)\n                        }\n\n\n\n\n\n                    } \n                    \n                    else if (isExpression(element) == true && element.includes('[') && element.includes(']')) {\n\n                        PushArray(element, tokens)\n\n                    } \n                    \n                    else if (!isKeyword(element) && !isNumber(element) && !isVariable(element) && !isExpression(element) && !isOperator(element))\n                {\n\n\n                        //ANCHOR \n                        /*Hnadling Impurity error-The main problem is figuring out how to solve \"=7000\" like things\n                    instead asking developers to add space manually\n                    Handling Alphanumeric strings to solve issues like ' anna=2362934'\n\n                    let impurity = element.split('=')\n\n                    let findString = impurity[1]\n\n\n                    //to accept long numbers i.e a=749374593745937\n\n                    if (isVariable(impurity[0]) && isNumber(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n                    //to accept a=STRING\n                    if (isVariable(impurity[0]) && isVariable(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n\n\n                    impurity.forEach((element, i) => {\n\n                        if (isVariable(element) == true) {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            //continue;\n                        }\n\n                        // ANCHOR \n\n                        //Issue: Right now, only isNumber is resolved, a=, =23828qw aren't resolved.\n                        //Solution: Work on all the modules\n\n\n                        if (isNumber(element) == true) {\n\n\n                            PushNumber(element, tokens)\n\n                        }\n\n                        //ANCHOR \n                        //You might have to remove this extra filters since you are only working on numbers (Future Issue)\n                        if (isOperator(element) == true) {\n                            PushOperator(element, token)\n\n                        }\n\n\n\n                        if (isKeyword(element) == true) {\n\n                            PushKeyword(element)\n\n                        }\n\n                        if (isExpression(element) == true) {\n\n\n                            PushExpression(element, tokens)\n\n                        }\n\n\n\n\n                    })\n */\n\n                    }\n\n\n\n\n                }\n\n\n\n\n\n\n\n\n\n\n\n\n\n                //SECTION - Checking each token and adding to tokens array\n                // PARSING INITIATION\n\n\n                for (i; i < cleaned_sourcedata.length; i++) {\n\n\n                    Parse(cleaned_sourcedata, i)\n                }\n\n                //ANCHOR \n                //CLEANING UP THE TOKENS ARRAY\n                //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n                tokens = tokens.filter(el => el.value != '')\n                console.log('tokens: ', tokens);\n\n\n\n\n               \n\n\n                //SECTION - Printing Outputs, considering conditions, finding values in updated_tokens\n\n\n\n\n                for (var j = 0; j < tokens.length; j++) {\n\n                    // Checking for assignment operators\n\n\n                    let mutable_tokens = tokens\n                    var token = mutable_tokens[j].value\n                    let tokenType = mutable_tokens[j].type\n\n\n\n                    var StringVar = []\n\n                    let VarWithoutbrackets = RemoveBrackets(mutable_tokens[j].value)\n\n                    VarWithoutbrackets = VarWithoutbrackets.replace(/ /g, '')\n\n\n                    if (mutable_tokens[j].type == \"SetArrayIndexValue\")\n\n\n\n                    {\n\n                       \n                       SetArrayIndexValue(mutable_tokens,j,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                       } else if (mutable_tokens[j].value == '=') {\n                           \n\n                      \n                      \n                      \n     AssignorUpdateValues(mutable_tokens, j, updated_tokens, iterator, OriginalIterator,this)\n\n                      \n                  \n\n\n                    } \n                    else if(tokenType=='PushToArray' )\n                    {\n\ntoken=token.replace('','')\nlet Split=token.split('.')\nlet ArrayName=Split[0]\n\nlet Element=RemoveBrackets(Split[1])\nconsole.log('Element: ', Element);\n\nlet ArrayToken=updated_tokens.find(el=>el.name==ArrayName)\nconsole.log('ArrayToken: ', ArrayToken);\n\nlet ElementtoPush=updated_tokens.find(el=>el.name==Element)\n\nconsole.log('ElementtoPush: ', ElementtoPush);\n\nif(ElementtoPush==undefined)\n{\n Element = Element.replace(/\"/g, \"\");\n                                Element = Element.replace(/'/g, \"\");\n                                \n\nElementtoPush=Element\n\n\n}\nelse{\n\n\n    ElementtoPush=ElementtoPush.value\n}\nlet ElementIndex=updated_tokens.indexOf(ArrayToken)\nconsole.log('ElementIndex: ', ElementIndex);\n\n\nlet ArrayValue=updated_tokens.find(el=>el.name==ArrayName).value\n\n\n\n\nif(ArrayValue=='[]')\n{\n\nArrayValue= ArrayValue.split(',')\n\n\n}\n\nconsole.log('ArrayValue: ', ArrayValue);\nArrayValue.push(ElementtoPush)\nArrayValue=ArrayValue.filter(el=> el!='[]') \nconsole.log('ArrayValue: ', ArrayValue);\n\nupdated_tokens[ElementIndex].value=ArrayValue\nconsole.log('updated_tokens: ', updated_tokens);\n\n\n                    }\n                    \n                    else if(token=='')\n                    \n                    {\n\n\n                let result = HandleBlocks(mutable_tokens, j, result)\nlet StartofBlock= mutable_tokens[j+1].startIndex\nlet EndofBlock= mutable_tokens[j+1].EndIndex\n\n//let DoesAnyTrueConditionExists= this.LastConditionValue.find(el=>el==true)\n\nlet lastValue=this.LastConditionValue.pop()\n\n\n\n\nif(lastValue==true)\n\n\n{\n\n\nj=EndofBlock\n\n\n}\n\n\n\n\n\n                    }\n                    \n                    else if (tokenType == 'AcceptInput') {\n\n                        let SetInputValueAs = mutable_tokens[j].AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for ' + SetInputValueAs)\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n                    else if (tokenType == 'function') {\n\n\n\n                            let functionSourceData = []\n\n                            let result = HandleBlocks(mutable_tokens, j+1, functionSourceData)\n\n                            functionSourceData = result.StoreResult\n\n                            functionSourceData.forEach(el=>{\n\n                                el.context='function'\n                            })\n\n                            mutable_tokens[j].SourceData=functionSourceData\n\n\n                    }\n\n                    \n                    \n                    \n                    else if (tokenType == 'functionExecution') {\n\n                        //checking if function is invoked somewhere later in the program\n\n\n\n                       \n                            let functionSourceData = []\n                             \n                            let functionName = mutable_tokens[j].value\n\n                            let passedValues = mutable_tokens[j].passedValues\n                            \n\n                            let functionToken=mutable_tokens.find(el=>el.value==functionName)\n                            let functionArguments = functionToken.arguments\n                            \n\n\n                            \n\n                            functionSourceData = functionToken.SourceData\n\n                           \n\n\n\n                            //Creating a seperate execution context and setting fucntion context name:value pair in 'functionContextupdated_tokens'\n                            functionArguments.forEach((el, index) => {\n\n\n\n\n                                let val = passedValues[index]\n\n\n\n                                val = val.replace(/\"/g, \"\");\n                                val = val.replace(/'/g, \"\");\n                                \n                               \n\n                                passedValues[index] = val\n                                \n\n                                \n                               \n                                //in this code we are filtering out arguments passed based on whether they already exist in updated tokens or not\n\n                                let FindInUpdatedTokens= updated_tokens.find(el=>el.name==val)\n                                \n                                \n\n//For passing same argument and same value to function  e.g function foo (fibonacci) and fibonacci=[] is already declared\n                                if(FindInUpdatedTokens==undefined)\n                                {\n\nfunctionContextupdated_tokens.push({\n\n\n\n\n                                    name: el,\n\n                                    value: val,\n\n                                    identifier: j + index,\n                                    type: 'value',\n                                    context: 'FunctionExecutionContext'\n\n\n\n\n                                })\n\n\n                                }\n\n                                //For passing different argument and value to function  e.g function foo (arr) and arr doesn't exist anywhere in tokens.\n\n\n                                else if(el!=FindInUpdatedTokens.name && FindInUpdatedTokens!=undefined) {\n\n\n                                    functionContextupdated_tokens.push({\n\n\n\n\n                                    name: el,\n\n                                    value: FindInUpdatedTokens.value,\n\n                                    identifier: j + index,\n                                    type: FindInUpdatedTokens.type,\n                                    context: 'FunctionExecutionContext',\n                                    IntheEndSetValueto:val\n\n\n\n\n                                })\n\n\n\n                                }\n\n                                else{\n\n\nfunctionContextupdated_tokens.push({\n\n\n\n\n                                    name: el,\n\n                                    value: val,\n\n                                    identifier: j + index,\n                                    type: FindInUpdatedTokens.type,\n                                    context: 'FunctionExecutionContext',\n                                    IntheEndSetValueto:val\n\n\n\n\n                                })\n\n\n\n\n                                }\n\n\n                                \n                                \n\n                             \n\n\n\n\n                            });\n\n                            var CompleteTokenValueList = [...updated_tokens, ...functionContextupdated_tokens]\n                            \n                            \n                            \n                            \n                            \n                            \n                            \n                            \n\n\n                            for (let i = 1; i < functionSourceData.length; i++)\n\n                            {\n\n\n                                let el = functionSourceData[i]\n\n\n\n\n                                if (el.value == '')\n                                \n\n                                {\n\n                                   \n                                console.log('functionSourceData,CompleteTokenValueList, j+i,: ', functionSourceData,CompleteTokenValueList, j+i,);\n\n                                 IfTokenPrint(functionSourceData,CompleteTokenValueList, i, this)\n                                 \n                                    \n\n                                  \n\n                                    \n\n\n                                \n                                } \n                                else if (el.value == '=') {\n                                    \n\n                      \n                      \n                      \n     AssignorUpdateValues(functionSourceData, i, CompleteTokenValueList, iterator, OriginalIterator,this)\n\n                      \n                  \n\n\n                    }\n                                 else if (el.type == 'AcceptInput') {\n\n                        let SetInputValueAs =functionSourceData[i].AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    } else if (el.type == 'condition')\n\n                                {\n\n\n\n\n                                    let element = functionSourceData[i].value\n\n                                    //this function is the first step to calculate value of operations like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n                                    let ConditionValue = GetConditionValue(element, CompleteTokenValueList, i)\n                                    this.LastConditionValue.push(ConditionValue)\n                                    //  console.log('j: ',j);\n\n\n\n\n                                    //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                                    if (ConditionValue == false) {\n\n                                        let InitializeLoop = tokens.indexOf(functionSourceData[i])\n\n                                        //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                                        //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                                        let Returnvalue = HandleBlocks(functionSourceData, i)\n\n                                        i = Returnvalue.i\n                                    }\n\n\n\n\n                                }\n\n\n\n\n                                //Handling set array element statements in for loop\n                                else if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n                                    SetArrayIndexValue(functionSourceData,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n\n                                } else if (functionSourceData[i].type == 'ForLoopStart')\n\n\n\n                                {\n\n                                    var FlagPrimalLoop = 0\n\n                                    var SourcedataTokens = []\n\n\n                                    //console.log('updated_tokens: ', updated_tokens);\n\n                                    let ForLoopMetaData = ForLoopSetMetadata(functionSourceData, i, CompleteTokenValueList)\n\n\n                                    var ForLoopSourcedataIndexStart = ForLoopMetaData.ForLoopSourcedataIndexStart\n                                    var Cycle = ForLoopMetaData.Cycle\n                                    var OriginalIterator = ForLoopMetaData.OriginalIterator\n                                    var IterationStart = ForLoopMetaData.IterationStart\n                                    var iterator = ForLoopMetaData.iterator\n                                    var element = ForLoopMetaData.element\n                                    var elementValue = ForLoopMetaData.elementValue\n\n                                    function getSourcedata(startIndex, functionSourceData, check, StoreResult) {\n                                        //console.log('startIndex, functionSourceData, check, StoreResult: ', startIndex, functionSourceData, check, StoreResult);\n\n\n\n                                        let Returnvalue = HandleBlocks(functionSourceData, startIndex, StoreResult)\n                                        StoreResult = Returnvalue.StoreResult\n\n\n                                        return StoreResult\n\n\n                                    }\n\n\n\n\n                                    ForLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', ForLoopSourcedataIndexStart)\n\n                                    //\n\n                                    SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, functionSourceData, '}', SourcedataTokens)\n                                    \n                                    \n\n\n\n                                    SourcedataTokens.forEach(el => {\n\n                                        el.isNestedLoop = false\n\n                                    })\n\n\n                                    let FindNestedLoop = SourcedataTokens.find(el => el.type == 'ForLoopStart')\n                                    if (FindNestedLoop != undefined) {\n\n                                        let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 2\n                                        let NestedLooplength = (SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex) + 1\n\n\n                                        for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n\n\n                                            SourcedataTokens[x].isNestedLoop = true\n\n                                        }\n\n\n                                    }\n\n\n\n\n                                    if (element.includes('(') && element.includes(','))\n\n\n                                    {\n\n                                        FlagPrimalLoop = 1\n\n\n                                    }\n\n\n\n\n                                    // console.log('Cycle: ', Cycle,IterationStart);\n\n\n                                    //Iterating over forloop sourcedata\n                                    //this line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                                    for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n\n\n\n                                        let forloopindex = CompleteTokenValueList.find(el => el.name == OriginalIterator)\n\n\n\n\n                                        forloopindex.value = iterator\n\n                                        //console.log('CompleteTokenValueList: ', CompleteTokenValueList);\n\n                                        //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                                        if (FlagPrimalLoop = 0) {\n                                            ForLoopArrayorStringOutput(elementValue, iterator, CompleteTokenValueList, this)\n\n                                        }\n\n\n                                        for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                                        {\n\n\n                                            let isNested = SourcedataTokens[i].isNestedLoop\n\n\n\n\n                                            if (SourcedataTokens[i].type == 'ForLoopStart') {\n                                                \n\n                                                var NestedFlagPrimalLoop = 0\n\n                                                var NestedSourcedataTokens = []\n\n                                                let NestedForLoopMetaData = ForLoopSetMetadata(SourcedataTokens, i, CompleteTokenValueList)\n\n                                                //  console.log('NestedForLoopMetaData: ', NestedForLoopMetaData);\n\n                                                var NestedForLoopSourcedataIndexStart = NestedForLoopMetaData.ForLoopSourcedataIndexStart\n                                                var NestedCycle = NestedForLoopMetaData.Cycle + 1\n                                                var NestedOriginalIterator = NestedForLoopMetaData.OriginalIterator\n                                                var NestedIterationStart = NestedForLoopMetaData.IterationStart\n                                                var Nestediterator = NestedForLoopMetaData.IterationStart\n                                                \n                                                var Nestedelement = NestedForLoopMetaData.element\n                                                var NestedelementValue = NestedForLoopMetaData.elementValue\n\n\n                                                function getSourcedata(startIndex, SourcedataTokens, check, StoreResult) {\n                                                    //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n\n\n                                                    let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                                                    StoreResult = Returnvalue.StoreResult\n\n\n                                                    return StoreResult\n\n\n                                                }\n\n\n\n\n                                                NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n\n\n\n                                                NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                                                //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n\n\n\n\n                                                for (Nestediterator; Nestediterator < NestedCycle; Nestediterator++) {\n                                                    {\n\n                                                        let y = Nestediterator\n\n\n                                                        let Nestedforloopindex = CompleteTokenValueList.find(el => el.name == NestedOriginalIterator)\n                                                        //console.log('forloopindex: ', forloopindex);\n\n\n\n                                                        Nestedforloopindex.value = y\n\n\n                                                        for (let index = 0; index < NestedSourcedataTokens.length; index++) {\n\n\n                                                            let el = NestedSourcedataTokens[index]\n\n                                                            if (el.value == '')\n\n                                                            {\n\n\n\n                                                                IfTokenPrint(NestedSourcedataTokens, CompleteTokenValueList, index, this, y, NestedOriginalIterator)\n\n\n                                                            } else if (el.value == '=' && el.isNestedLoop == true) {\n\n\n                                                                //assigning values to variables\n\n\n                                                                AssignorUpdateValues(NestedSourcedataTokens, index, CompleteTokenValueList, y, NestedOriginalIterator,this)\n\n                                                            } else if (el.type == 'condition' && el.isNestedLoop == true)\n\n\n\n                                                            {\n\n\n\n\n                                                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                                let ConditionStartIndex = index\n                                                                let condition = NestedSourcedataTokens[index].value\n                                                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                                //value of i depends on the conditions\n\n                                                                if (condition.includes('||') || condition.includes('&&'))\n\n                                                                {\n\n\n                                                                    let value = GetConditionValue(condition, CompleteTokenValueList, index)\n                                                                this.LastConditionValue.push(value)\n\n\n\n\n                                                                    if (value == false) {\n\n\n\n                                                                        let BlockLength = 0\n                                                                        let BlockStart = 0\n\n                                                                        while (NestedSourcedataTokens[index].value != '{')\n\n                                                                        {\n\n                                                                            if (NestedSourcedataTokens[index + 1].value == '{')\n\n                                                                            {\n\n\n                                                                                BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                                                                index = BlockLength + index + 1\n\n\n\n\n                                                                                break;\n\n                                                                            }\n\n\n\n                                                                            index++\n                                                                        }\n\n                                                                    } else {\n\n\n                                                                        index = index\n\n\n                                                                    }\n\n\n\n\n                                                                } else {\n\n\n                                                                    let x = HandleConditions(NestedSourcedataTokens, index, CompleteTokenValueList);\n\n\n\n\n                                                                    if (x != undefined) {\n\n\n                                                                        index = x\n\n\n\n                                                                    } else {\n                                                                        index = ConditionStartIndex\n                                                                        //console.log('i: ', i);\n                                                                    }\n\n                                                                }\n\n\n\n\n\n                                                            }\n\n\n\n                                                            //console.log('i: ', i);\n\n                                                            // i = i + NestedSourcedataTokens.length\n                                                            //console.log('i: ', i);\n                                                            else if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop == true)\n\n\n\n\n                                                            {\n                                                                        SetArrayIndexValue(NestedSourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n                                                            }\n\n\n\n\n                                                        }\n\n\n\n\n                                                    }\n\n\n\n\n                                                }\n\n\n\n\n                                            } \n\n                                             else if (SourcedataTokens[i].type== 'AcceptInput' && isNested == false) {\n\n                                       let SetInputValueAs =SourcedataTokens[i].type.AcceptAs\n\n\n\n\n                                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n                                            \n                                            else if (SourcedataTokens[i].value == '=' && isNested == false) {\n\n                                                //assigning values to variables\n\n\n                                                AssignorUpdateValues(SourcedataTokens, i, CompleteTokenValueList, iterator, OriginalIterator,this)\n\n\n\n\n                                            }\n\n\n\n\n                                            //Handling print statements in for loop\n                                            else if (SourcedataTokens[i].value == '' && isNested == false)\n\n\n\n\n                                            {\n\n\n                                                //for operations like print(array[3])\n\n                                                // console.log('for looop prints: ', functionSourceData[i],i);\n\n\n                                                IfTokenPrint(SourcedataTokens, CompleteTokenValueList, i, this, iterator, OriginalIterator)\n\n                                                //\n\n\n                                            }\n\n\n\n                                            //Handling set array element statements in for loop\n                                            else if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                            {\n\n\n\n                                                    SetArrayIndexValue(SourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n                                            }\n\n\n\n                                            // Handling CONDITIONAL statements in for loop\n                                            else if (SourcedataTokens[i].type == 'condition')\n\n\n\n                                            {\n\n\n\n\n                                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                let ConditionStartIndex = i\n                                                let condition = SourcedataTokens[i].value\n                                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                //value of i depends on the conditions\n\n                                                if (condition.includes('||') || condition.includes('&&'))\n\n                                                {\n\n\n                                                    let value = GetConditionValue(condition, updated_tokens, i)\n                                                                this.LastConditionValue.push(value)\n\n\n\n\n                                                    if (value == false) {\n\n\n\n                                                        let BlockLength = 0\n                                                        let BlockStart = 0\n\n                                                        while (SourcedataTokens[i].value != '{')\n\n                                                        {\n\n                                                            if (SourcedataTokens[i + 1].value == '{')\n\n                                                            {\n\n\n                                                                BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                                                                i = BlockLength + i + 1\n\n\n\n\n                                                                break;\n\n                                                            }\n\n\n\n                                                            i++\n                                                        }\n\n                                                    } else {\n\n\n                                                        i = i\n\n\n                                                    }\n\n\n\n\n                                                } else {\n\n\n                                                    i = HandleConditions(SourcedataTokens, i, CompleteTokenValueList);\n\n\n\n                                                    if (i != undefined) {\n\n\n                                                        i = i\n\n\n                                                    } else {\n                                                        i = ConditionStartIndex\n                                                        //console.log('i: ', i);\n                                                    }\n\n                                                }\n\n\n\n\n                                            }\n\n\n                                        }\n\n\n\n                                    }\n                                    //console.log('j: ', j);\n\n                                    i = i + SourcedataTokens.length\n                                    //console.log('j: ', j);\n\n\n                                } else if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n\n\nSetArrayIndexValue(SourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n                                } else if (functionSourceData[i].type == 'WhileLoopStart') {\n\n\n                                    let TokensCurrentIndex = i + 3\n\n\n\n                                    let ConditionValue = false\n\n                                    let element = functionSourceData[i + 1].value\n\n                                    let ExtratcedVariable = []\n\n                                    let variable = ''\n                                    let WhileLoopSourcedataIndexStart = 0\n                                    let WhileLoopSourcedataTokens = []\n\n\n\n                                    for (let i = 0; i < element.length; i++) {\n                                        let x = element.charAt(i)\n\n\n                                        if (isVariable(x))\n\n                                        {\n\n                                            variable = variable + x\n\n\n\n                                        }\n                                        if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n\n                                            let token = CompleteTokenValueList.find(el => el.name == variable)\n\n                                            ExtratcedVariable.push({\n                                                variable: variable,\n                                                value: token.value\n\n                                            })\n\n\n                                            variable = ''\n\n\n                                        }\n\n                                    }\n\n\n\n\n                                    function getWhileLoopSourcedata(startIndex, functionSourceData, check, StoreResult) {\n\n\n\n                                        StoreResult = HandleBlocks(functionSourceData, startIndex, StoreResult)\n\n\n\n                                        return StoreResult\n\n\n\n\n                                    }\n\n\n\n\n                                    WhileLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', WhileLoopSourcedataIndexStart)\n                                    //\n                                    WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, functionSourceData, '}', WhileLoopSourcedataTokens).StoreResult\n\n\n\n\n                                    //constantly accessing the conditionvalue\n\n                                    while (GetConditionValue(element, CompleteTokenValueList, j + 1)) {\n\n                                        for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n\n\n\n\n                                            //SECTION while loop context\n\n                                            if (WhileLoopSourcedataTokens[i].value == '=') {\n\n\n\n\n                                                AssignorUpdateValues(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                                                //\n\n                                                // \n\n\n                                            }\n\n                                               else if (WhileLoopSourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =WhileLoopSourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                            // Handling CONDITIONAL statements in for loop\n                                            else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                                            {\n\n\n\n\n                                                let index = HandleConditions(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                                                if (index != undefined) {\n                                                    i = index\n\n\n                                                } else {\n                                                    i = i\n                                                }\n\n\n\n\n                                            } else if (WhileLoopSourcedataTokens[i].value == '')\n\n\n\n\n                                            {\n\n\n                                                IfTokenPrint(WhileLoopSourcedataTokens, CompleteTokenValueList, i, this) //for operations like print(array[3])\n\n\n\n\n                                            } else if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                            {\n\n SetArrayIndexValue(WhileLoopSourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n\n                                            }\n\n\n\n                                        }\n\n\n                                    }\n\n                                    i = i + 1 + WhileLoopSourcedataTokens.length + 1\n                                  \n\n                                }\n\n\n\n\n                            }\n\n\n\n\n                        \n\n\n                        //skipping parsing index so that function context is run by single entity and global execution doesn't run this code too\n                      //  j = mutable_tokens[j + 1].EndIndex\n\n\n//If we pass function foo(arr) where arr is (suppose) fibonacci=[] declared in the global exe context(updated_tokens). But operation will be performed on\n//arr in functionContextupdated_tokens. so at the end of fucntion execution we set the value to it's right owner.\n                        let token=functionContextupdated_tokens.find(el=>el.IntheEndSetValueto!='')\n                        let GivePowersTo= updated_tokens.find(el=>el.name==token.IntheEndSetValueto)\n                        \n                        GivePowersTo.value=token.value\n\n//I have to empty it because function context has to remain empty other wise function arguments will keep on accepting new values with the same key\n//for e.g= PrintFullName(FirstName,LastName) and PrintFullName(FirstNam,LastNam) needs two different execution context hence first one needs to make space for later\n\n                        functionContextupdated_tokens=[]\n\n\n\n                    } else if (tokenType == 'condition')\n\n                    {\n\n\n\n\n                        let element = mutable_tokens[j].value\n\n                        //this function is the first step to calculate value of operations like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n                        let ConditionValue = GetConditionValue(element, updated_tokens, j)\n                         this.LastConditionValue.push(ConditionValue)\n\n                        // console.log('ConditionValue: ', ConditionValue);\n                        //  console.log('j: ',j);\n\n\n\n\n                        //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                        if (ConditionValue == false) {\n\n                            let InitializeLoop = tokens.indexOf(mutable_tokens[j])\n\n                            //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                            //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                            let Returnvalue = HandleBlocks(mutable_tokens, j)\n\n                            j = Returnvalue.j\n                        }\n\n\n\n\n                    } else if (token == '' && mutable_tokens[j].context!='function')\n                    \n\n\n                    {\n\n\n\n                        IfTokenPrint(mutable_tokens, updated_tokens, j, this) //for operations like print(array[3])\n\n\n\n                    } else if (tokenType == 'WhileLoopStart') {\n\n\n                        let TokensCurrentIndex = j + 3\n\n                        let ConditionValue = false\n\n                        let element = mutable_tokens[j + 1].value\n\n                        let ExtratcedVariable = []\n\n                        let variable = ''\n                        let WhileLoopSourcedataIndexStart = 0\n                        let WhileLoopSourcedataTokens = []\n\n\n\n                        for (let i = 0; i < element.length; i++) {\n                            let x = element.charAt(i)\n\n\n                            if (isVariable(x))\n\n                            {\n\n                                variable = variable + x\n\n\n\n                            }\n                            if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n\n                                let token = updated_tokens.find(el => el.name == variable)\n\n                                ExtratcedVariable.push({\n                                    variable: variable,\n                                    value: token.value\n\n                                })\n\n\n                                variable = ''\n\n\n                            }\n\n                        }\n\n\n\n\n                        function getWhileLoopSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n\n\n\n                            StoreResult = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n\n\n\n                            return StoreResult\n\n\n\n\n                        }\n\n\n\n\n                        WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart)\n                        //\n                        WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, '}', WhileLoopSourcedataTokens).StoreResult\n                        console.log('WhileLoopSourcedataTokens: ', WhileLoopSourcedataTokens);\n\n\n\n\n                        //constantly accessing the conditionvalue\n\n                        while (GetConditionValue(element, updated_tokens, j + 1)) {\n\n                            for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n\n\n\n\n                                //SECTION while loop context\n\n                                if (WhileLoopSourcedataTokens[i].value == '=') {\n\n\n\n\n                                    AssignorUpdateValues(WhileLoopSourcedataTokens, i, updated_tokens)\n\n                                    //\n\n                                    // \n\n\n                                }\n\n                                  else if (WhileLoopSourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =WhileLoopSourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                // Handling CONDITIONAL statements in for loop\n                                else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                                {\n\n\n\n\n                                    let index = HandleConditions(WhileLoopSourcedataTokens, i, updated_tokens)\n                                 \n\n\n                                    if (index != undefined) {\n                                        i = index\n\n\n                                    } else {\n                                        i = i\n                                    }\n\n\n\n\n                                } else if (WhileLoopSourcedataTokens[i].value == '')\n\n\n\n\n                                {\n\n\n                                    IfTokenPrint(WhileLoopSourcedataTokens, updated_tokens, i, this) //for operations like print(array[3])\n\n\n\n\n                                } else if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n SetArrayIndexValue(WhileLoopSourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n\n                                }\n\n\n\n                            }\n\n\n                        }\n                    } else if (tokenType == 'ForLoopStart')\n\n\n\n                    {\n\n                        var FlagPrimalLoop = 0\n\n                        var SourcedataTokens = []\n\n\n                        //console.log('updated_tokens: ', updated_tokens);\n\n                        let ForLoopMetaData = ForLoopSetMetadata(mutable_tokens, j, updated_tokens)\n\n                        console.log('ForLoopMetaData: ', ForLoopMetaData);\n\n                        var ForLoopSourcedataIndexStart = ForLoopMetaData.ForLoopSourcedataIndexStart\n                        var Cycle = ForLoopMetaData.Cycle\n                        \n                        var OriginalIterator = ForLoopMetaData.OriginalIterator\n                        var IterationStart = ForLoopMetaData.IterationStart\n                        var iterator = ForLoopMetaData.iterator\n                        var element = ForLoopMetaData.element\n                        var elementValue = ForLoopMetaData.elementValue\n\n                        function getSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n                            //console.log('startIndex, mutable_tokens, check, StoreResult: ', startIndex, mutable_tokens, check, StoreResult);\n\n\n\n                            let Returnvalue = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n                            StoreResult = Returnvalue.StoreResult\n\n\n                            return StoreResult\n\n\n                        }\n\n\n\n\n                        ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart)\n\n                        //\n\n                        SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, '}', SourcedataTokens)\n                        //console.log('SourcedataTokens: ', SourcedataTokens);\n\n\n\n                        SourcedataTokens.forEach(el => {\n\n                            el.isNestedLoop = false\n\n                        })\n\n\n                        let FindNestedLoop = SourcedataTokens.find(el => el.type == 'ForLoopStart')\n                        \n                        \n                        if (FindNestedLoop != undefined) {\n\n                            let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 3\n                            let NestedLooplength = (SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex) + 2\n                            \n                            \n\n\n                            for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n\n\n                                SourcedataTokens[x].isNestedLoop = true\n                                \n                                \n\n                            }\n\n\n                        }\n\n\n\n\n                        if (element.includes('(') && element.includes(','))\n\n\n                        {\n\n                            FlagPrimalLoop = 1\n\n\n                        }\n\n\n\n                        // console.log('Cycle: ', Cycle,IterationStart);\n\n\n                        //Iterating over forloop sourcedata\n                        //this line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                        for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n\n\n\n                            let forloopindex = updated_tokens.find(el => el.name == OriginalIterator)\n\n\n\n\n                            forloopindex.value = iterator\n\n                            //console.log('updated_tokens: ', updated_tokens);\n\n                            //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                            if (FlagPrimalLoop = 0) {\n                                ForLoopArrayorStringOutput(elementValue, iterator, updated_tokens, this)\n\n                            }\n\n\n                            for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                            {\n\n\n                                let isNested = SourcedataTokens[i].isNestedLoop\n\n\n                                if (SourcedataTokens[i].type == 'ForLoopStart') {\n                                    \n\n                                    var NestedFlagPrimalLoop = 0\n\n                                    var NestedSourcedataTokens = []\n\n                                    let NestedForLoopMetaData = ForLoopSetMetadata(SourcedataTokens, i, updated_tokens)\n\n                                    //  console.log('NestedForLoopMetaData: ', NestedForLoopMetaData);\n\n                                    var NestedForLoopSourcedataIndexStart = NestedForLoopMetaData.ForLoopSourcedataIndexStart\n                                    var NestedCycle = NestedForLoopMetaData.Cycle + 1\n                                    var NestedOriginalIterator = NestedForLoopMetaData.OriginalIterator\n                                    var NestedIterationStart = NestedForLoopMetaData.IterationStart\n                                    var Nestediterator = NestedForLoopMetaData.IterationStart\n                                    var Nestedelement = NestedForLoopMetaData.element\n                                    var NestedelementValue = NestedForLoopMetaData.elementValue\n\n\n                                    function getSourcedata(startIndex, SourcedataTokens, check, StoreResult) {\n                                        //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n\n\n                                        let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                                        StoreResult = Returnvalue.StoreResult\n\n\n                                        return StoreResult\n\n\n                                    }\n\n\n\n\n                                    NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n                                    //console.log('ForLoopSourcedataIndexStart: ', ForLoopSourcedataIndexStart);\n\n\n\n                                    NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                                    //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n\n\n\n\n                                    for (Nestediterator; Nestediterator < NestedCycle; Nestediterator++) {\n                                        {\n\n                                            let y = Nestediterator\n\n\n                                            let Nestedforloopindex = updated_tokens.find(el => el.name == NestedOriginalIterator)\n                                            //console.log('forloopindex: ', forloopindex);\n\n\n\n                                            Nestedforloopindex.value = y\n\n\n                                            for (let index = 0; index < NestedSourcedataTokens.length; index++) {\n\n\n                                                let el = NestedSourcedataTokens[index]\n\n                                                if (el.value == '')\n\n                                                {\n\n\n\n                                                    IfTokenPrint(NestedSourcedataTokens, updated_tokens, index, this, y, NestedOriginalIterator)\n\n\n                                                } else if (el.value == '=' && el.isNestedLoop == true) {\n\n\n                                                    //assigning values to variables\n\n\n                                                    AssignorUpdateValues(NestedSourcedataTokens, index, updated_tokens, y, NestedOriginalIterator)\n\n                                                } else if (el.type == 'condition' && el.isNestedLoop == true)\n\n\n\n                                                {\n\n\n\n\n                                                    //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                    let ConditionStartIndex = index\n                                                    let condition = NestedSourcedataTokens[index].value\n                                                    //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                    //value of i depends on the conditions\n\n                                                   \n\n                                                        let value = GetConditionValue(condition, updated_tokens, index)\n                                                        \n                                                                this.LastConditionValue.push(value)\n\n\n\nif(value==false)\n{\n\n    break\n\n\n\n\n}\n\n\n\n\n\n                                                      /*  if (value == false) {\n\n\n\n                                                            let BlockLength = 0\n                                                            let BlockStart = 0\n\n                                                            while (NestedSourcedataTokens[index].value != '{')\n\n                                                            {\n\n                                                                if (NestedSourcedataTokens[index + 1].value == '{')\n\n                                                                {\n\n\n                                                                    BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                                                    index = BlockLength + index + 1\n\n\n\n\n                                                                    break;\n\n                                                                }\n\n\n\n                                                                index++\n                                                            }\n\n                                                        } else if(value==true) {\n\n\nconsole.log(el,NestedSourcedataTokens,index);\n\n                                                        }\n\n\n\n\n*/\n                                                  \n\n\n\n                                                }\n\n\n\n                                               \n\n                                                // i = i + NestedSourcedataTokens.length\n                                                //console.log('i: ', i);\n                                                else if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop == true)\n\n\n\n\n                                                {\n\n                                                    \n\n                                                        SetArrayIndexValue(NestedSourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                                                }\n\n\n\n\n                                            }\n\n\n\n\n                                        }\n\n\n\n\n                                    }\n\n\n\n\n                                } else if (SourcedataTokens[i].value == '=' && isNested == false) {\n                                    \n\n                                    //assigning values to variables\n\n\n\n                                    AssignorUpdateValues(SourcedataTokens, i, updated_tokens, iterator, OriginalIterator)\n\n                                }\n\n else if(SourcedataTokens[i].type=='PushToArray')\n \n                    {\n\nlet token=SourcedataTokens[i].value\n\ntoken=token.replace('','')\nlet Split=token.split('.')\nlet Array=Split[0]\nlet ElementtoPush=RemoveBrackets(Split[1])\nElementtoPush=updated_tokens.find(el=>el.name==ElementtoPush).value\n\nlet ArrayEl=updated_tokens.find(el=>el.name==Array)\n\n\nlet ArrayValue=ArrayEl.value\nif(ArrayValue=='[]')\n{\nArrayValue= ArrayValue.split(',')\n}\nArrayValue.push(ElementtoPush)\n\n\nlet index=updated_tokens.indexOf(ArrayEl)\n\nArrayValue=ArrayValue.filter(el=> el!='[]')\n\n\n\n\n\n\n\nupdated_tokens[index].value=ArrayValue\n \n\n\n                    }\n\n\n  else if (SourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =SourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                //Handling print statements in for loop\n                                else if (SourcedataTokens[i].value == '' && isNested == false)\n\n\n\n\n                                {\n\n                                    //for operations like print(array[3])\n\n                                    // console.log('for looop prints: ', SourcedataTokens[i],i);\n\n\n                                    IfTokenPrint(SourcedataTokens, updated_tokens, i, this, iterator, OriginalIterator)\n\n                                    //\n\n\n                                }\n\n\n\n                                //Handling set array element statements in for loop\n                                else if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n                                   SetArrayIndexValue(SourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                                }\n\n\n\n                                // Handling CONDITIONAL statements in for loop\n                                else if (SourcedataTokens[i].type == 'condition')\n\n\n\n                                {\n\n\n\n\n                                    //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                    let ConditionStartIndex = i\n                                    let condition = SourcedataTokens[i].value\n                                    //HandleConditions evaluates condition and return the index of from where printing should resume\n                                    //value of i depends on the conditions\n\n                                    if (condition.includes('||') || condition.includes('&&'))\n\n                                    {\n\n\n                                        let value = GetConditionValue(condition, updated_tokens, i)\n\n                                                                this.LastConditionValue.push(value)\n\n\n                                        if (value == false) {\n\n\n\n                                            let BlockLength = 0\n                                            let BlockStart = 0\n\n                                            while (SourcedataTokens[i].value != '{')\n\n                                            {\n\n                                                if (SourcedataTokens[i + 1].value == '{')\n\n                                                {\n\n\n                                                    BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                                                    i = BlockLength + i + 1\n\n\n\n\n                                                    break;\n\n                                                }\n\n\n\n                                                i++\n                                            }\n\n                                        } else {\n\n\n                                            i = i\n\n\n                                        }\n\n\n\n\n                                    } else {\n\n\n                                        i = HandleConditions(SourcedataTokens, i, updated_tokens);\n\n\n\n                                        if (i != undefined) {\n\n\n                                            i = i\n\n\n                                        } else {\n                                            i = ConditionStartIndex\n                                            //console.log('i: ', i);\n                                        }\n\n                                    }\n\n\n\n\n                                }\n\n\n                            }\n\n\n\n                        }\n                        //console.log('j: ', j);\n\n                        j = j + SourcedataTokens.length\n                        //console.log('j: ', j);\n\n\n                    }\n\n                    //END FOR LOOP EXECUTION\n\n\n\n\n                }\n\n\n\n\n                \n\n\n //To find undefined variables\n               \n                //\n\n\n\n\nfunction onlyUnique(value, index, self) { \n    return self.indexOf(value) === index;\n}\n\nvar assigned_variables=assigned_variables.filter(onlyUnique)\n\nlet difference= variables_array.filter(x=> !assigned_variables.includes(x))\n\n                if (difference.length > 0)\n\n                {\n\n                    difference.forEach(el=>{\n\n\n                    this.error.push('Variable ' + el + ' is undefined ')\n\n\n                    })\n                    \n\n                }\n\n              if(this.error.length>0)\n              {\n\nthis.linebylineOutput=this.error\n\n\n              }\n\nelse{\n\n                this.linebylineOutput = this.output.split('\\n')\n                \n}\n\n\n\n\nvar t1 = performance.now()\n                if (this.linebylineOutput!= '' && this.error.length==0) {\n                    this.TimeTaken = \"Compiled Succesfully in \" + (t1 - t0).toPrecision(4) + \" ms.\"\n\n                }\n\n                else{\n\n                    this.isError = true\n\n                    this.TimeTaken = \"Compilation Error: Check for assignement and declaration mistyping\" \n\n\n                }\n\n\n               \n               this.linebylineOutput = this.linebylineOutput.filter(function(item) {\n                   \n                   \n                    return item !== \"\"\n                })\n\n\n                //SECTION - Calculating remaining values\n\n\n                //so that replace x with values\n\n                /*\n                            updated_tokens.forEach((el, i) => {\n                                \n\n\n                                let element = el.value\n\n\n                                //removing the \"(\"\" and \")\"\n\n\n                                var CleanedElement = RemoveBrackets(element)\n\n                                operation = ''\n\n\n\n                                //why pureeval?\n                                // operations like 50+60 were set as [5,0,+,6,0] instead of [50,+,60]. basically direct calculation was not working\n                                //pureeval finds such pure operations and then calculate them to directly set their value\n                                //this shit is only for pureoperations\n                                let pureval = /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedElement)\n\n                                if (pureval == true) {\n\n\n\n                                    updated_tokens[i].value = eval(updated_tokens[i].value)\n\n\n                                }\n\n\n\n\n                                if (isCalculation(CleanedElement) == true && !pureval) {\n\n                                    terms = CleanedElement.split('')\n\n\n\n                                }\n\n\n\n\n                            })\n\n\n\n\n                            //\n\n                            // performing calculations\n\n\n\n\n                            updated_tokens.forEach((el, i) => {\n\n                                var indextoChange = '' //to know which value to replace like \"anna+dada-bad\" with \"5+6-7\"\n\n\n\n                                let element = el.value // reading the current value, for lon string variable names it's still like \"anna+dada-bad\"\n                                element = element.toString()\n                                var StringVar = []\n                                // \n\n                                let pureval = /^([-+]?[a-z]*\\.?[a-z]+[\\/\\+\\-\\*])+([-+]?[a-z]*\\.?[a-z]+)*$/gm.test(element)\n\n\n\n                                if (element.includes('>') || element.includes('<') || element.includes('==')) {\n\n\n\n                                    StringVar = SplitElementsArray(element)\n\n\n\n                                    StringVar = SetValues(StringVar, updated_tokens)\n\n\n                                    UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n\n\n                                }\n\n\n                                //finding operations like a+b-c\n                                if (pureval == true || element.charAt(0) == \"(\") {\n\n                                    // \n\n\n                                    StringVar = SplitElementsArray(element)\n                                    StringVar = SetValues(StringVar, updated_tokens)\n                                    UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n                                }\n\n\n\n\n                            })\n\n\n\n\n                            /*\n                             ReIntializedVariables.forEach(el=>{\n\n                            let flag=0\n                            let SkipIndex=0\n\n                            for(let m=0;m<updated_tokens.length;m++)\n                            {\n                                \n                            if(el.name==updated_tokens[m].name && flag==0)\n                            {\n\n\n                            if(el.value.charAt(0)=='\"')\n                            {\n\n\n                                let BuiltString= BuildString(el.value, )\n\n                                \n                            }\n                            flag=1;\n                            updated_tokens[m].value=el.value;\n\n\n                            \n\n                            SkipIndex=m\n\n\n                            }\n\n                            //\n\n                            if( m!=SkipIndex && flag==1 && el.name==updated_tokens[m].name)\n\n                            {\n\n                            updated_tokens.splice(m,1)\n\n                            }\n\n\n                            }\n\n\n\n\n                            })\n                            */\n\n\n\n\n                //SECTION - Iterating over tokens and then PRINTING FINAL using values stored in updated tokens\n\n                /*        \n\n            for (var j = 0; j < tokens.length; j++) {\n\n\n                var mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n             \n\n                if (token == '' )\n\n                {\n\n                    var b = RemoveBrackets(mutable_tokens[j+1].value)\n\n\n\n\n                    variables_array.push(b)\n\n                    \n\n                 \n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n                    updated_tokens.forEach((el, i) => {\n\n                        if (el.name == b ) {\n\n\n\n                            this.output = this.output + el.value + \"\\n\";\n\n                            assigned_variables.push(el.name);\n\n                           \n\n\n                        }\n\n\n\n                        // work to be continued\n\n                    })\n\n                    \n\n                    \n\n                }\n\n\n                //Handling Conditions\n\n                if(mutable_tokens[j].type==\"condition\")\n                {\n\n\n\n                   \n\n                    let token= updated_tokens.find(el=> el.originalvalue==mutable_tokens[j].value)\n\n\n\n                    let ConditionValue=token.value\n\n                  \n\n                   if(ConditionValue==false)\n                   {\n\nlet InitializeLoop= tokens.indexOf(mutable_tokens[j])\n\n\n\n\n\nwhile(mutable_tokens[j+1].value!='}' )\n{\n\n\n\n    let x= mutable_tokens[j+1].value.length\n    \n    \ntokens.splice(j+1, 1);\n \n\n    j++;\n\n\n}\n\n\n\n\n                   }\n\n\n                }\n\n\n                if(token == '' && /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(mutable_tokens[j+1].value) )\n                {\n \n                let a= eval(mutable_tokens[j+1].value)\n\n                this.output = this.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n                \n\n        \n              \n\n\n\n\n      // this is to handle  (\"Age is\"+ Age) etc.\n\n                if(isStringandValue(mutable_tokens[j].value))\n{\n\n\n        \n\n                    let x=mutable_tokens[j].value\n                    let string=''\n                    let newel=''\n\n                    x=RemoveBrackets(x)\n\n                    \n                    //x = x.replace(/ /g,'')\n\n                    x=x.split(\"+\")\n\n                    \n\n                    x.forEach(element => {\n                        \n\n                        \n                        if(element.charAt(0)== \" \" || element.charAt(element.length-1)==\" \" && !(element.includes('\"'))){\n\n                          \n                       newel= element.replace(/\\s/g, '');\n\n                        \n\n\n                        }\n                        else{\n\n                            newel=element\n                        }\n\n                       let y= updated_tokens.find(el=> el.name== newel)\n\n                      \n                       \n//\n                       if(y!=undefined)\n                       {\n\n\n\n                       string=string + ' ' + y.value\n                       //\n\n\n                       }\n                       else{\n\n                           \n                           element= element.replace(/\"/g, '');\n                           string=string+ ' ' + element\n                       }\n                       \n\n                       \n\n                    });\n\n\n\n                        this.output = this.output + \"\\n\" + string + \"\\n\"\n}\n\n\n//THIS IS to handle operations like  (\"Name is GOAT\"),  (\"Goodbye\")\n\nelse{\n\n\n\n                  let value= RemoveBrackets(mutable_tokens[j].value)\n                 // \n\n                  \n\n                   let CleanedValue = value.replace(/ /g,'')\n\n                    \n\n\n                   if(/^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedValue)!=true)\n\n                   {\n\n                 // \n\n                    value = value.replace(/\"/g, \"\");\n                    value = value.replace(/'/g, \"\");\n\n\n\n                        this.output = this.output + \"\\n\" + value + \"\\n\" \n }\n                        \n\n}\n\n\n            }\n\n\n           \n            })\n\n        }\n        */\n\n\n        }\n\n    }\n\n}; \n</script>\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n\n::-webkit-input-placeholder {\n   text-align: center;\n   vertical-align: middle;\n   line-height: 500px;\n}\n\n:-moz-placeholder { /* Firefox 18- */\n   text-align: center;  \n      vertical-align: middle;\n        line-height: 500px;\n\n\n}\n\n\n::-moz-placeholder {  /* Firefox 19+ */\n   text-align: center;  \n      vertical-align: middle;\n         line-height: 500px;\n\n\n}\n\n:-ms-input-placeholder {  \n   text-align: center; \n      vertical-align: middle;\n         line-height: 500px;\n\n\n}\n\nbutton:focus {outline:0;}\n\n#bharatP{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace\n}\n#versionNumber{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace;\n    padding-left: 6%\n}\n\n\n#version{\n\n    margin: 0;\n    float: left;\n    color: #92924c;\n    font-size: 90%;\n\n}\n\n#bharatDIV{\n\n    padding-top: 2%;\n    padding-left: 2%\n\n}\n\n\n#linebylineOutput\n{\n\n\n\nheight: 10px;\n    text-align: left;\n    \n\n\n}\n#errorstack{\n\ntext-align: left;\npadding-left: 2.5%;\npadding-top: 6%;\nfont-weight: bold;\ncolor:rgb(231, 83, 83);\n\n}\n\n#compiler{\n\n  display: flex;\n}\n\n#textarea{\n\n  width: 50%;\n  margin-left: -1%\n\n}\n#output{\n\n  height: 600px;\n  width: 50%;\n  background-color: black;\n    color: white;\n    overflow: auto\n  \n}\nh3 {\n  margin: 40px 0 0;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n\n.hello {\n  display: grid;\n}\n\n\n#codearea {\nwidth: 93%;\n    margin-left: 3.5%;\n    height: 500px;\n    background-color: whitesmoke;\n    font-family: monospace;\n    font-size: medium;\n    border: none;\n    outline: none;\n    resize: none;\n}\n\n#row{\n\ndisplay: flex;\n    width: 2%;\n    margin-top: -12%;\n\n}\n\n#rowdiv{\n\n\n  verflow: hidden;\n    height: 500px;\n    margin-left: 2%;\n    margin-right: 1%;\n    margin-top: 0%;\n    font-size: small;\n\n}\n\n#subm {\n  width: 18.5%;\n  height: 50px;\n      cursor: pointer;\n      border: none\n\n  \n}\n\n#subm:hover{\n\n\n    background-image: radial-gradient( circle 534px at 7.8% 17.6%,  rgba(254,253,112,1) 1.7%, rgba(248,143,111,1) 91.8% );\n}\n\np{\n\n \n  margin-top: 4%\n}\n\n#CodeStatus{\n\n    margin-top: 5%;  \n      text-align: left;\n    color: #2fff2f;\n    font-family: monospace\n\n}\n\n\n\n\n\n/* Smartphones (portrait) ----------- */\n@media only screen\nand (max-width : 480px) {\n\n\n::-webkit-input-placeholder {\n   text-align: center;\n   vertical-align: middle;\n   line-height: 250px;\n   font-size: 90%\n}\n\n:-moz-placeholder { /* Firefox 18- */\n   text-align: center;  \n      vertical-align: middle;\n        line-height: 250px;\n\n   font-size: 90%\n\n}\n\n::-moz-placeholder {  /* Firefox 19+ */\n   text-align: center;  \n      vertical-align: middle;\n         line-height: 250px;\n\n   font-size: 90%\n\n}\n\n:-ms-input-placeholder {  \n   text-align: center; \n      vertical-align: middle;\n         line-height: 250px;\n   font-size: 90%\n\n\n}\n\n#compiler{\n\n\n    display: inline-block\n}\n\n#CodeStatus{\n\ntext-align: left;\n\n}\n\n#linebylineOutput{\n\n\n}\n.hello{\n\n\n    text-align: center;\n    margin-top: 2%\n}\n#textarea{\n\n    width: 100%;\n    margin: 0%\n}\n#codearea{\n\n       height: 310px;\n       width: 99%;\n       margin-left: 0\n\n}\n\n#textarea button{\n\nwidth: 20%;\n    height: 30px;\n    font-size: small;\n}\n\n#output{\n\n\n    width: 100%;\n   height: 330px;\n\n    margin-top: 5%;\n}\n#printOutput{\n\n    width: 100%;\n    float: left\n}\n\n#headerlist{\n\n    list-style-type: none;\n    padding: 0;\n    display: grid;\n  \n    width: 100%;\n    background-color: #9cffff;\n    line-height: 40px;\n}\n\n}\n\n\n\n</style>"],"sourceRoot":"src/views"}]}