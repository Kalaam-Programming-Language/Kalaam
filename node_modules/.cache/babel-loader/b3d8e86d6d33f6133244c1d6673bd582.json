{"remainingRequest":"/Users/jonny/Documents/Work/test/node_modules/babel-loader/lib/index.js!/Users/jonny/Documents/Work/test/src/lib/Compiler/main.js","dependencies":[{"path":"/Users/jonny/Documents/Work/test/src/lib/Compiler/main.js","mtime":1592794541494},{"path":"/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiL1VzZXJzL2pvbm55L0RvY3VtZW50cy9Xb3JrL3Rlc3Qvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKCi8qIQogKiBLYWxhYW0gdjEuMC4wCiAqIChDKSAyMDIwIFN3YW5hbmQgS2FkYW0KICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogKi8KLy9TRUNUSU9OIC0gSW1wb3J0aW5nIGZ1bmN0aW9uIG1vZHVsZXMKLy9UbyBjaGVjayB2YXJpYWJsZSB0eXBlczogTnVtYmVyLCBTdHJpbmcsIEFycmF5IGV0Yy4KaW1wb3J0ICogYXMgVHlwZUNoZWNrIGZyb20gJy4uL1R5cGVDaGVjay9UeXBlQ2hlY2tpbmcnOyAvL1RvIGNoZWNrIG90aGVyIG9wZXJhdGlvbnMgbGlrZSBNdWx0aVN0cmluZywgQXJpdGhtZXRpYyBPcGVyYXRpb24gZXRjLgoKaW1wb3J0ICogYXMgQWR2YW5jZWRUeXBlQ2hlY2sgZnJvbSAnLi4vVHlwZUNoZWNrL0FkdmFuY2VkVHlwZUNoZWNraW5nJzsgLy9UbyBmb3JtYXQgdXNlciBpbnB1dCBpbnRvIGEgcHJvcGVyIFN0cmluZywgQXJyYXkgb3IgQ29uZGl0aW9uLiAKCmltcG9ydCAqIGFzIEJ1aWxkT3BlcmF0aW9uIGZyb20gJy4uL1NjcmlwdHMvQnVpbGRPcGVyYXRpb25zJzsgLy9GdW5jdGlvbnMgaW1wb3J0ZWQgdG8gcHVzaCBhIHBhcnRpY3VsYXIgZGF0YSB0byBvdXIgVG9rZW5zIGFycmF5LiAKLy9Ub2tlbnMgYXJyYXkgaXMgYmFzaWNhbGx5IGEgY2xlYW4sIGZvcm1hdHRlZCBhbmQgYSB3b3JkIGJ5IHdvcmQgdmVyc2lvbiBvZiByYXcgY29kZSBwcm92aWRlZCBieSB1c2VyCgppbXBvcnQgeyBQdXNoQXJyYXksIFB1c2hDYWxjdWxhdGlvbiwgUHVzaENvbmRpdGlvbmFsS2V5d29yZCwgUHVzaENvbmRpdGlvbiwgUHVzaEZvckxvb3AsIFB1c2hXaGlsZUxvb3AsIFB1c2hXaGlsZUxvb3BDb25kaXRpb24sIFB1c2hGb3JMb29wQXJ1Z3VtZW50cywgUHVzaEV4cHJlc3Npb24sIFB1c2hLZXl3b3JkLCBQdXNoTnVtYmVyLCBQdXNoT3BlcmF0b3IsIFB1c2hSZWFsVGltZVByaW50T3BlcmF0aW9uLCBQdXNoU3RyaW5nLCBQdXNoU3RyaW5nYW5kVmFsdWVPcGVyYXRpb24sIFB1c2hWYXJpYWJsZSwgUHVzaFZhcmlhYmxlVmFsdWUsIFB1c2hGdW5jdGlvbkRhdGEsIFB1c2hGdW5jdGlvbkV4ZWN1dGlvbiwgUHVzaFRvQXJyYXksIFB1c2hJbnB1dCB9IGZyb20gJy4uL1B1c2hUb2tlbnMvbWFpbic7IC8vVGhpcyBhcmUgb3RoZXIgaGVscGVyIGZ1bmN0aW9ucyB0aGF0IHdlIG5lZWQgZm9yIGEgcGFydGljdWxhciB0YXNrLiBBbGwgb2YgdGhpcyBmdW5jdGlvbnMgd2lsbCBiZSBleHBsYWluZWQgaW5kZXB0aCBhcyB3ZSBzZWUgdGhlbSBpbiBjb2RlYmFzZS4KCmltcG9ydCB7IEdldENsZWFuU291cmNlZGF0YSwgUmVtb3ZlQnJhY2tldHMsIENvdW50LCBBZGRFbGVtZW50VG9BcnJheSwgUmVzZXRWYWx1ZSwgaXNBcnJheU9wZXJhdGlvbiwgQ3JlYXRlQXJyYXlFbGVtZW50LCBDYWxjdWxhdGVWYWx1ZXMsIEdldEFycmF5b3JTdHJpbmdFbGVtZW50LCBTZXRBcnJheW9yU3RyaW5nRWxlbWVudCwgaGFuZGxlbXVsdENvbmRpdGlvbnMsIEhhbmRsZUJsb2NrcywgU3BsaXRFbGVtZW50c0FycmF5LCBTZXRWYWx1ZXMsIFB1c2hTZXRBcnJheUluZGV4VmFsdWUsIFB1c2hHZXRBcnJheUluZGV4VmFsdWUsIFVwZGF0ZVVwZGF0ZWRfdG9rZW5zd2l0aFZhbHVlcywgR2V0Q29uZGl0aW9uVmFsdWUsIEFjY2VwdElucHV0YW5kU2V0VmFsdWUsIEZvckxvb3BBcnJheW9yU3RyaW5nT3V0cHV0LCBBc3NpZ25vclVwZGF0ZVZhbHVlcywgSGFuZGxlQ29uZGl0aW9ucywgZ2V0TG9vcEluZGV4U3RhcnQsIEZvckxvb3BTZXRNZXRhZGF0YSwgU2V0QXJyYXlJbmRleFZhbHVlIH0gZnJvbSAnLi4vU2NyaXB0cy9tYWluLmpzJzsgLy9XZSB3aWxsIGJlIGltcG9ydGluZyB0aGlzIHdob2xlIGZ1bmN0aW9uIHRvIHByYWN0aXNlLnZ1ZSBhbmQgaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHVzZXIgY2xpY2tzIG9uICdSVU4nCgpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb21waWxlKGthbGFhbSkgewogIC8vJ2thbGFhbScgaXMgb3VyIGdsb2JhbCBvYmplY3QgYW5kIGFjY2VzcyBpdCdzIHZhbHVlIGFzICd0aGlzLiRkYXRhJyBmcm9tIHByYWN0aXNlLnZ1ZSBsb2NhdGVkIGluIHZpZXdzCiAgLy9BbGwgdGhlIGlucHV0IHNvdXJjZWNvZGUsIHRva2Vucywgb3V0cHV0LCBlcnJvciBoYW5kbGluZyBldGMgaXMgc3RvcmVkIGluIGthbGFhbSBvYmplY3QKICAvL3QwIGFsb25nIHdpdGggdDEgdGFrZXMgcmVjb3JkIG9mIFRpbWUgdGFrZW4gdG8gcnVuIHRoZSBjb2RlLiB0MS10MCBnaXZlcyB1cyB0aGUgZXhhY3QgdGltZSB0YWtlbi4KICB2YXIgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy9JZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB3ZSBzZXQgdGhlIHZhbHVlIHRvIHRydWUgYW5kIHB1c2ggdGhlIGVycm9yIHRvIGVycm9ycyBhcnJheS4KCiAga2FsYWFtLmlzRXJyb3IgPSBmYWxzZTsgLy90byBzdG9wIGFjY3VtdWxhdGluZyBvdXRwdXQgb24gc3VjY2VzaXZlIFJVTi4gCgogIGthbGFhbS5vdXRwdXQgPSAnJzsgLy9rYWxhYW0uaW5wdXQgPSAnJywKCiAga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQgPSBrYWxhYW0ub3V0cHV0LnNwbGl0KCJcbiIpOyAvL2thbGFhbS5pbnB1dEluZGV4ZXMgPSBbXQoKICBrYWxhYW0uZXJyb3IgPSBbXTsKICBrYWxhYW0uT3BlcmF0aW9uT2JqZWN0cyA9IFtdOyAvL1NvdXJjZWRhdGEgaXMgdGhlIHJhdyBjb2RlIHByb3ZpZGVkIGJ5IHVzZQoKICB2YXIgc291cmNlZGF0YSA9IGthbGFhbS5jb2RlOyAvL1RoaXMgaXMgd2hlcmUgZm9ybWF0dGVkIGFuZCBjbGVhbmVkIHNvdXJjZWRhdGEgd2lsbCBnby4KCiAgdmFyIGNsZWFuZWRfc291cmNlZGF0YSA9IFtdOwogIHZhciBpID0gMDsgLy9UaGlzIGlzIHdoZXJlIHRva2VucyB3aWxsIGJlIHB1c2hlZCBkZXBlbmRpbmcgdXBvbiB0aGVpciB0eXBlcyBsaWtlIFZhcmlhYmxlLCBmdW5jdGlvbiwgbG9vcHMgZXRjLgoKICB2YXIgdG9rZW5zID0gW107IC8vRXhwZXJpbWVudGFsCgogIHZhciBtaXhlZGltcHVyaXR5ID0gW107IC8vVGhlIHZhcmlhYmxlcyB3aXRoIHRoZWlyIGNhbGN1bGF0ZWQgdmFsdWVzIGFyZSBwdXNoZWQgaGVyZS4gSWYgYz1hK2IsIHVwZGF0ZWRfdG9rZW5zIGlzIHdoZXJlIHlvdSB3aWxsIGZpbmQgdGhlIGNhbGN1bGF0ZWQgdmFsdWUKCiAgdmFyIHVwZGF0ZWRfdG9rZW5zID0gW107IC8vVmFyaWFibGUtdmFsdWUgcGFpcnMgc2ltaWxhciB0byB1cGRhdGVkX3Rva2VucyBidXQgbGltaXRzIGl0c2VsZiB0byBhIHVzZXIgY3JlYXRlZCBmdW5jdGlvbi4KCiAgdmFyIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zID0gW107CiAgdmFyIHZhcmlhYmxlc19hcnJheSA9IFtdOyAvL1B1c2hpbmcgdGhlIHZhcmlhYmxlcyB0aGF0IGFyZSBhc3NpZ25lZCB0byBmaWx0ZXIgb3V0IGRlZmluZWQgYW5kIHVuZGVmaW5lZCB2YXJpYWJsZXMuIFVzZWZ1bCBpbiBlcnJvciBoYW5kbGluZwoKICB2YXIgYXNzaWduZWRfdmFyaWFibGVzID0gW107CiAgdmFyIHRlcm1zID0gW107CiAgdmFyIHRlcm1zMiA9IFtdOwogIHZhciBvcGVyYXRpb24gPSAnJzsKICB2YXIgQ2FsY3VsYXRpb25TdGFjayA9IFtdOwogIHZhciBmb3VuZFRva2VuID0gJyc7CiAgdmFyIFJlSW50aWFsaXplZFZhcmlhYmxlcyA9IFtdOyAvL1RPIFJFTU9WRSBEVVBMSUNBVEUgVkFSSUFCTEVTLCAKCiAgdmFyIHZhcmlhYmxlQXJyYXkgPSBbXTsgLy9BIHRlbXBvcmFyeSBpbnN0YW5jZSBvZiBhIGdsb2JhbCB2YXJpYWJsZS4gVXNlZCBiZWNhdXNlIG9mIHNjb3BpbmcgaXNzdWUsIHRoZXJlIGFyZSBiZXR0ZXIgc291bHRpb25zIGFuZCB3ZSB3aWxsIGRvIHRoYXQuCiAgLy9lbXB0eWluZyBhY2N1bXVsYXRlZCB2YWx1ZSAKICAvL1NlZSBBc3NpZ25vclVwZGF0ZVZhbHVlcyBmdW5jdGlvbiBmb3IgbW9yZQoKICBSZXNldFZhbHVlKCk7IC8vU0VDVElPTiAtIENoZWNraW5nIGZvciB0eXBlIG9mIGNoYXJhY3RlcnMuIFR5cGVDaGVjayBpcyBhbiBvYmplY3Qgd2hpY2ggY29uc2lzdHMgYWxsIHNlbGYgZnVuY3Rpb25zLiBDaGVjayBMaW5lIDEwMgoKICB2YXIgaXNWYXJpYWJsZSA9IFR5cGVDaGVjay5pc1ZhcmlhYmxlKCk7CiAgdmFyIGlzTnVtYmVyID0gVHlwZUNoZWNrLmlzTnVtYmVyKCk7CiAgdmFyIGlzT3BlcmF0b3IgPSBUeXBlQ2hlY2suaXNPcGVyYXRvcigpOwogIHZhciBpc0tleXdvcmQgPSBUeXBlQ2hlY2suaXNLZXl3b3JkKCk7CiAgdmFyIGlzQ29uZGl0aW9uYWxLZXl3b3JkID0gVHlwZUNoZWNrLmlzQ29uZGl0aW9uYWxLZXl3b3JkKCk7CiAgdmFyIGlzRm9yTG9vcCA9IFR5cGVDaGVjay5pc0Zvckxvb3AoKTsKICB2YXIgaXNXaGlsZUxvb3AgPSBUeXBlQ2hlY2suaXNXaGlsZUxvb3AoKTsKICB2YXIgaXNGdW5jdGlvbiA9IFR5cGVDaGVjay5pc0Z1bmN0aW9uKCk7IC8vbmVlZHMgd29yawoKICB2YXIgaXNFeHByZXNzaW9uID0gVHlwZUNoZWNrLmlzRXhwcmVzc2lvbigpOwogIHZhciBpc0FycmF5ID0gVHlwZUNoZWNrLmlzQXJyYXkoKTsKICB2YXIgaXNJbnB1dCA9IFR5cGVDaGVjay5pc0lucHV0KCk7CiAgdmFyIGlzU2V0QXJyYXlJbmRleFZhbHVlID0gVHlwZUNoZWNrLmlzU2V0QXJyYXlJbmRleFZhbHVlKCk7IC8vIGNvbnN0IGlzRW1wdHlBcnJheUluaXQgPSBUeXBlQ2hlY2suaXNFbXB0eUFycmF5SW5pdCgpCgogIHZhciBpc1N0cmluZyA9IFR5cGVDaGVjay5pc1N0cmluZygpOwogIHZhciBpc0VtcHR5U3RyaW5nb3JDaGFyID0gVHlwZUNoZWNrLmlzRW1wdHlTdHJpbmdvckNoYXIoKTsKICB2YXIgaXNQdXJlRXZhbCA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzUHVyZUV2YWwoKTsgLy9pZiBwYXJzZXIgZW5jb3VudGVycyBhbnl0aGluZyBsaWtlICgiIG9yICgsIHRoZW4gdGhhdCdzIGEgcmVhbHRpbWUgcHJpbnQuIAogIC8vYnVpbGRzdHJpbmcgd2lsbCBiZSBhcHBsaWVkIG5vdyB0byBjcmVhdGUgYSBzdHJpbmcgYW5kIHB1c2ggaXQgaW50byB0b2tlbnMuIEJ1aWxkc3RyaW5nIGlzIHVzZWQgdG8gY29tYmluZSBzdHJpbmcgdG9rZW5zIGxpa2UgCiAgLy9bJ2hlbGxvJywgJ0thbGFhbScsICdkZXZlbG9wZXJzJywgIiEiXSBpbnRvICdoZWxsbyBrYWxhYW0gZGV2ZWxvcGVycyEnLgogIC8vSXQncyBiZWNhdXNlIGNsZWFuZWRfc291cmNlZGF0YSBpcyBhbiBhcnJheSBvZiB0b2tlbnMgYW5kIGVhY2ggdG9rZW4gaXMgYW4gaW5kaXZpZHVhbCB3b3JkIGluIGEgcHJvZ3JhbS4KICAvL0l0J3MgcmVjb21tZW5kZWQgdG8gbG9vayBhdCBjbGVhbmVkX3NvdXJjZWRhdGEgb2YgZXZlcnkgcHJvZ3JhbSB0byB1bmRlcnN0YW5kIGhvdyBpdCBjb252ZXJ0cyBwbGFpbiB0ZXh0IGludG8gYXJyYXkgb2YgaW5kaXZpZHVhbCB3b3Jkcy4KCiAgdmFyIGlzUmVhbFRpbWVQcmludE11bHRpcGxlU3RyaW5nID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoKTsKICB2YXIgaXNTdHJpbmdhbmRWYWx1ZSA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzU3RyaW5nYW5kVmFsdWUoKTsKICB2YXIgaXNDYWxjdWxhdGlvbiA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzQ2FsY3VsYXRpb24oKTsKICB2YXIgaXNEaXJlY3RQcmludEFyaXRobWV0aWMgPSBBZHZhbmNlZFR5cGVDaGVjay5pc0RpcmVjdFByaW50QXJpdGhtZXRpYygpOyAvL1NFQ1RJT04gQnVpbGQgT3BlcmF0aW9ucyAKICAvL1RvIGNvbnZlcnQgWydoZWxsbycsICdLYWxhYW0nLCAnZGV2ZWxvcGVycycsICIhIl0gaW50byAnaGVsbG8ga2FsYWFtIGRldmVsb3BlcnMhJy4KCiAgdmFyIEJ1aWxkU3RyaW5nID0gQnVpbGRPcGVyYXRpb24uQnVpbGRTdHJpbmcoKTsgLy9UbyBjb252ZXJ0IFsnWycsICd4JywneScsJ3onLCddJ10gaW50byBbJ3gnLCd5JywneiddCgogIHZhciBCdWlsZEFycmF5ID0gQnVpbGRPcGVyYXRpb24uQnVpbGRBcnJheSgpOyAvL3NlbGYgZnVuY3Rpb24gaXMgdGhlIGZpcnN0IHN0ZXAgdG8gaGFuZGxsZSBvcGVyYXRpb25zIGxpa2Ug4KSF4KSX4KSwIChhZ2VvbmU9PTEwICYmIEF2ZXJhZ2VBZ2U8MTAwMCAmJiBhZ2V0d28+MTAwIHx8IGFnZW9uZT09MTApIE9SIChhZ2VvbmU9PTEwICkKCiAgdmFyIEJ1aWxkQ29uZGl0aW9uID0gQnVpbGRPcGVyYXRpb24uQnVpbGRDb25kaXRpb24oKTsgLy9UaGlzIHdpbGwgcnVuIGZvciBldmVyeSDgpKrgpY3gpLDgpL/gpILgpJ8oKSBzdGF0ZW1lbnQgZW5jb3VudGVyZWQgaW4gdGhlIHByb2dyYW0sIG5vdCBqdXN0IGZvciBsb29wcwogIC8vQVJHVU1FTlRTIFRPIFByaW50RW5naW5lIGFyZToKICAvL1Rva2Vucy0gVG9rZW5zIGFycmF5IAogIC8vdXBkYXRlZF90b2tlbnMtIFZhcmlhYmxlLXZhbHVlIHBhaXJzIG9mIHZhcmlhYmxlcwogIC8vai0gSW5kZXggb2YgYSB0b2tlbiBpbiBUb2tlbnMgYXJyYXkKICAvL2dsb2JhbC0gc2VsZiBvciBzZWxmCiAgLy9pdGVyYXRvciBhbmQgT3JpZ2luYWxJdGVyYXRvciBhcmUgdXNlZCB0byBwcmludCB2YWx1ZXMgaW4gZm9yIGFuZCB3aGlsZSBsb29wcy4KCiAgZnVuY3Rpb24gUHJpbnRFbmdpbmUoVG9rZW5zLCB1cGRhdGVkX3Rva2VucywgaiwgZ2xvYmFsLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcikgewogICAgLy9UcnkgY29uc29sZS5sb2coJ1Rva2VucywgdXBkYXRlZF90b2tlbnMsIGosIGdsb2JhbCwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IpOiAnLCBUb2tlbnMsIHVwZGF0ZWRfdG9rZW5zLCBqLCBnbG9iYWwsIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yKSk7IAogICAgLy9UbyB1bmRlcnN0YW5kIHdoYXQga2luZCBvZiBkYXRhIGlzIG5lY2Vzc2FyeSB0byBwcmludCBhIHZhbHVlIAogICAgLy9HZXR0aW5nIHRoZSBjdXJyZW50IHRva2VuIGFzIHRva2VuIGFuZCB2YWx1ZSB0byBiZSBwcmludGVkIGFzIE5leHRUb2tlblZhbHVlCiAgICAvL2UuZy4gRm9yIOCkquCljeCksOCkv+CkguCknyhOYW1lKSwgTmFtZSBpcyB0aGUgTmV4dFRva2VuVmFsdWUgYW5kIGl0IGlzIHRoZSBvbmUgd2hpY2ggd2Ugd2lsbCBoYXZlIHRvIHByaW50CiAgICB2YXIgdG9rZW4gPSBUb2tlbnNbal0udmFsdWU7CiAgICB2YXIgTmV4dFRva2VuVmFsdWUgPSBUb2tlbnNbaiArIDFdLnZhbHVlOwogICAgdmFyIFN0cmluZ1ZhciA9IFtdOyAvL1JlbW92aW5nIHRoZSBicmFja2V0cywgaWYgYW55LiAKCiAgICB2YXIgVmFyaWFibGVUb1ByaW50ID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOyAvL0FkZGluZyB0aGUgdmFyaWFibGUgdG8gdmFyaWFibGVzX2FycmF5CgogICAgaWYgKGlzVmFyaWFibGUoVmFyaWFibGVUb1ByaW50KSAmJiAhdmFyaWFibGVzX2FycmF5LmluY2x1ZGVzKFZhcmlhYmxlVG9QcmludCkpIHsKICAgICAgdmFyaWFibGVzX2FycmF5LnB1c2goVmFyaWFibGVUb1ByaW50KTsgLy8gCiAgICB9IC8vU0VDVElPTiAtIE91dHB1dHRpbmcgdGhlIGNvZGUKICAgIC8vIGZpbmRpbmcgdGhlIHZhcmlhYmxlIHZhbHVlIGluIHVwZGF0ZWRfdG9rZW5zLiBVcGRhdGVkX3Rva2VucyBpcyB3aGVyZSBvdXIgVmFyaWFibGUtdmFsdWUgcGFpcnMgZXhpc3RzLgogICAgLy9UcnkgY29uc29sZS5sb2codXBkYXRlZF90b2tlbnMpIHRvIHNlZSBob3cgaXQgbG9va3MKICAgIC8vVGhpcyBsb29wIGlzIG9ubHkgZm9yIHByaW50aW5nIGRpcmVjdCB2YWx1ZXMgbGlrZSBwcmludChuYW1lKSwgcHJpbnQoYXJyYXkpCgoKICAgIHVwZGF0ZWRfdG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpKSB7CiAgICAgIC8vSWYgd2UgaGF2ZSBhIHZhcmlhYmxlLXZhbHVlIHBhaXIgc2l0dGluZyBpbiB1cGRhdGVkX3Rva2VucwogICAgICBpZiAoZWwubmFtZSA9PSBWYXJpYWJsZVRvUHJpbnQpIHsKICAgICAgICAvL2ZvciBjYWxjdWxhdGlvbnMgbGlrZSB4PWFnZW9uZSthZ2V0d28KICAgICAgICAvL0lmIHdlIGhhdmUgYWxyZWFkeSBjYWxjdWxhdGVkIHZhbHVlIGluIGFzc2lnbmVkX3ZhcmlhYmxlcywgdXNlIHRoYXQgb3IgZWxzZSBtb3ZlIGZvcndhcmQKICAgICAgICBpZiAoYXNzaWduZWRfdmFyaWFibGVzLmluY2x1ZGVzKGVsKSB8fCBhc3NpZ25lZF92YXJpYWJsZXMuaW5jbHVkZXMoZWwubmFtZSkpIHsKICAgICAgICAgIEFkZE91dHB1dChlbC52YWx1ZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vaWYgdGhlIHZhbHVlIGZvdW5kIGlzIGEgTnVtYmVyCiAgICAgICAgICBpZiAoaXNOdW1iZXIoZWwudmFsdWUpKSB7CiAgICAgICAgICAgIEFkZE91dHB1dChlbC52YWx1ZSk7CiAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsLm5hbWUpOwogICAgICAgICAgfSAvL2lmIHRoZSB2YWx1ZSBmb3VuZCBpcyBvcGVyYXRpb25zIGxpa2UgYWdlPTIwMjAtMTk5NgogICAgICAgICAgZWxzZSBpZiAoaXNQdXJlRXZhbChlbC52YWx1ZSkpIHsKICAgICAgICAgICAgICAvL3dlIGFyZSB1c2luZyBKYXZhc2NyaXB0J3MgZXZhbCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZGlyZWN0IGFyaXRobWV0aWMgb3BlcmF0aW9ucyAKICAgICAgICAgICAgICB2YXIgb3V0cHV0cHVyZSA9IGV2YWwoZWwudmFsdWUpOwogICAgICAgICAgICAgIGVsLnZhbHVlID0gb3V0cHV0cHVyZTsKICAgICAgICAgICAgICBBZGRPdXRwdXQoZWwudmFsdWUpOwogICAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsLm5hbWUpOwogICAgICAgICAgICB9IC8vV2Ugd2lsbCBzaW1wbGlmeSBzZWxmIGNvbmRpdGlvbnMgYXMgd2UgbW92ZSBmb3J3YXJkCiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1B1cmVFdmFsKGVsLnZhbHVlKSAmJiAhaXNOdW1iZXIoZWwudmFsdWUpKSB7CiAgICAgICAgICAgICAgICBpZiAoIShlbC5uYW1lLmluY2x1ZGVzKCddJykgJiYgZWwubmFtZS5pbmNsdWRlcygnWycpKSkgewogICAgICAgICAgICAgICAgICBpZiAoZWwudHlwZSA9PSAnQXJyYXknKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnZhbHVlLmluY2x1ZGVzKCdbJykgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gJ1snICsgZWwudmFsdWUudG9TdHJpbmcoKSArICddJzsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIEFkZE91dHB1dChlbC52YWx1ZSk7CiAgICAgICAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsLm5hbWUpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0pOyAvL1RoaXMgaXMgaG93IHdlIHByaW50IEFycmF5IGluIEthbGFhbQoKICAgIGlmIChUb2tlbnNbaiArIDFdLnR5cGUgPT0gJ0FycmF5JykgewogICAgICAvL1RvIHJ1biBvbmx5IGlmIGl0ZXJhdG9yIGlzIHByZXNlbnQKICAgICAgLy9UaGlzIHJ1bnMgb24gZm9yIGxvb3AgLSDgpKrgpY3gpLDgpL/gpILgpJ8oQXJyYXlbYV0pIGV0YwogICAgICAvL3NlbGYgcnVucyBvbmx5IGlmIGZvcihpKSBhbmQgaW4gdGhlIGxvb3AsIGFycmF5W2ldLCBub3Qgb24gYXJyYXlbeF0uIEZvciBsb29wIEl0ZXJhdG9yIGFuZCBpbmRleCBzaG91bGQgYmUgc2FtZSwgaW4gc2VsZiBjYXNlICdpJwogICAgICBpZiAoaXRlcmF0b3IgIT0gdW5kZWZpbmVkICYmIFRva2Vuc1tqICsgMV0uSW5kZXhJbnB1dCA9PSBPcmlnaW5hbEl0ZXJhdG9yKSB7CiAgICAgICAgdmFyIFZhbHVlID0gTmV4dFRva2VuVmFsdWU7CiAgICAgICAgdmFyIEFycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChWYWx1ZSwgaXRlcmF0b3IpOwogICAgICAgIHZhciBvdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICBBZGRPdXRwdXQob3V0cHV0KTsKICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChUb2tlbnNbaiArIDFdKTsKICAgICAgfSAvL1RoaXMgcnVucyB0byBQcmludChBcnJheVsyXSkgbGlrZSBzcGVjaWZpYyBhcnJheSB2YWx1ZXMKICAgICAgZWxzZSBpZiAoVG9rZW5zW2ogKyAxXS5JbmRleElucHV0ICE9IE9yaWdpbmFsSXRlcmF0b3IpIHsKICAgICAgICAgIHZhciBfVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZTsKICAgICAgICAgIHZhciBJbmRleFRvQ2hhbmdlID0gVG9rZW5zW2ogKyAxXS5JbmRleElucHV0OwoKICAgICAgICAgIHZhciBfQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KF9WYWx1ZSwgSW5kZXhUb0NoYW5nZSk7CgogICAgICAgICAgdmFyIF9lbGVtZW50ID0gX0FycmF5RWxlbWVudC5yZXBsYWNlKCddJywgJycpOwoKICAgICAgICAgIHZhciBTcGxpdCA9IF9lbGVtZW50LnNwbGl0KCdbJyk7CgogICAgICAgICAgaWYgKFNwbGl0WzFdLmluY2x1ZGVzKCctJykgfHwgU3BsaXRbMV0uaW5jbHVkZXMoJysnKSkgewogICAgICAgICAgICB2YXIgX291dHB1dDIgPSBDYWxjdWxhdGVWYWx1ZXMoU3BsaXRbMV0sIGosIHVwZGF0ZWRfdG9rZW5zKTsKCiAgICAgICAgICAgIFNwbGl0WzFdID0gX291dHB1dDI7CiAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpICsgJ10nOwogICAgICAgICAgICBfQXJyYXlFbGVtZW50ID0gU3BsaXQ7CiAgICAgICAgICB9CgogICAgICAgICAgdmFyIF90b2tlbiA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IFNwbGl0WzFdOwogICAgICAgICAgfSk7CgogICAgICAgICAgaWYgKF90b2tlbiAhPSB1bmRlZmluZWQgJiYgT3JpZ2luYWxJdGVyYXRvciAhPSBTcGxpdFsxXSkgewogICAgICAgICAgICBTcGxpdFsxXSA9IF90b2tlbi52YWx1ZTsKICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykgKyAnXSc7CiAgICAgICAgICAgIF9BcnJheUVsZW1lbnQgPSBTcGxpdDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIF9BcnJheUVsZW1lbnQgPSBfQXJyYXlFbGVtZW50OyAvL2NvbnNvbGUubG9nKCdBcnJheUVsZW1lbnQ6ICcsIEFycmF5RWxlbWVudCk7CiAgICAgICAgICB9CgogICAgICAgICAgdmFyIF9vdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChfQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgQWRkT3V0cHV0KF9vdXRwdXQpOwogICAgICAgIH0KICAgIH0gLy9wcmludGluZyBkaXJlY3QgbnVtYmVycyBhbmQgZGlyZWN0IGNhbGN1bHRpb25zIGxpa2UgcHJpbnQoMTApLCBwcmludCgxMCoxMCkKICAgIGVsc2UgaWYgKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIChpc1B1cmVFdmFsKFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkgfHwgaXNOdW1iZXIoUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSkpIHsKICAgICAgICBOZXh0VG9rZW5WYWx1ZSA9IFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKTsKCiAgICAgICAgaWYgKGlzTnVtYmVyKE5leHRUb2tlblZhbHVlKSAmJiBUb2tlbnNbaiArIDFdLnR5cGUgIT0gJ0NhbGN1bGF0aW9uJykgewogICAgICAgICAgQWRkT3V0cHV0KE5leHRUb2tlblZhbHVlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIGEgPSBldmFsKE5leHRUb2tlblZhbHVlKTsKICAgICAgICAgIEFkZE91dHB1dChhKTsKICAgICAgICB9CiAgICAgIH0gLy9mb3JvcGVyYXRpb25zIGxpa2UgcHJpbnQoJ3lvdSBsaXZlLCB5b3UgbGVhcm4nKQogICAgICBlbHNlIGlmIChUb2tlbnNbaiArIDFdLm1vZGUgPT0gIlJlYWxUaW1lUHJpbnQiICYmICFOZXh0VG9rZW5WYWx1ZS5pbmNsdWRlcygnKycpICYmICFOZXh0VG9rZW5WYWx1ZS5pbmNsdWRlcygnPScpKSB7CiAgICAgICAgICB2YXIgX291dHB1dDMgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7CgogICAgICAgICAgX291dHB1dDMgPSBfb3V0cHV0My5yZXBsYWNlKC8iL2csICcnKTsKICAgICAgICAgIF9vdXRwdXQzID0gX291dHB1dDMucmVwbGFjZSgvJy9nLCAnJyk7CiAgICAgICAgICBBZGRPdXRwdXQoX291dHB1dDMgKyAiXG4iKTsKICAgICAgICB9IC8vb3BlcmF0aW9ucyBsaWtlIHByaW50KEFnZSArICdpcyB5b3VuZyBhZ2UnKSBpLmUgc3RyaW5nIGNvbmNhdGVuYXRpb25zCiAgICAgICAgZWxzZSBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09ICJSZWFsVGltZVByaW50IiAmJiBOZXh0VG9rZW5WYWx1ZS5pbmNsdWRlcygnKycpKSB7CiAgICAgICAgICAgIHZhciB4ID0gU3BsaXRFbGVtZW50c0FycmF5KE5leHRUb2tlblZhbHVlKTsKICAgICAgICAgICAgU3RyaW5nVmFyID0gU2V0VmFsdWVzKHgsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgICAgU3RyaW5nVmFyID0gU3RyaW5nVmFyLmpvaW4oJycpOwogICAgICAgICAgICBTdHJpbmdWYXIgPSBTdHJpbmdWYXIuc3BsaXQoIisiKTsKCiAgICAgICAgICAgIHZhciBfb3V0cHV0NCA9IFN0cmluZ1Zhci5qb2luKCcgJyk7CgogICAgICAgICAgICBfb3V0cHV0NCA9IFJlbW92ZUJyYWNrZXRzKF9vdXRwdXQ0KTsKICAgICAgICAgICAgQWRkT3V0cHV0KF9vdXRwdXQ0ICsgIlxuIik7CiAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsY3VsYXRpb24oUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSAmJiBUb2tlbnNbaiArIDFdLm1vZGUgIT0gIlJlYWxUaW1lUHJpbnQiKSB7CiAgICAgICAgICAgIE5leHRUb2tlblZhbHVlID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICAgICAgdmFyIF9vdXRwdXQ1ID0gQ2FsY3VsYXRlVmFsdWVzKE5leHRUb2tlblZhbHVlLCBqLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgICBBZGRPdXRwdXQoX291dHB1dDUgKyAiXG4iKTsKICAgICAgICAgIH0KICB9IC8vRU5EIE9GIEZ1bmN0aW9ucyBhbmQgSW1wb3J0ZWQgRnVuY3Rpb25zCiAgLy9PdXQgb2YgYWxsIHNlbGYgZnVuY3Rpb24sIFByaW50RW5naW5lIGlzIHZlcnkgaW1wb3J0YW50IGZ1bmN0aW9uLiBJdCBwcmludHMgdmFyaWFibGUgdmFsdWVzIGJ5IHNlYXJjaGluZyB0aGVpciB2YWx1ZSBpbiB1cGRhdGVkX3Rva2Vucy4KICAvL1NFQ1RJT04gLSBDaGVja2luZyBlYWNoIHRva2VuIGFuZCBhZGRpbmcgdG8gdG9rZW5zIGFycmF5CiAgLy9QYXJzZSB0YWtlcyB0d28gYXJndW1lbnRzLiBUaGUgY2xlYW5lZF9zb3VyY2VkYXRhIGFycmF5IGFuZCBjdXJyZW50IGluZGV4IG9mIGNsZWFuZWRfc291cmNlZGF0YSBhcnJheQogIC8vUGFyc2UgaXMgdXNlZCB0byBjcmVhdGUgYSB0b2tlbnMgYXJyYXkgd2l0aCBlYWNoIHRva2VuIGhhdmluZyBpdCdzIG5hbWUsIHZhbHVlLCB0eXBlIGFuZCBvdGhlciBtZXRhZGF0YQogIC8vSXQgcGVyZm9ybXMgb3BlcmF0aW9ucyBkZXBlbmRpbmcgdXBvbiB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIHZhcmlhYmxlLCBhcnJheSwgZnVuY3Rpb24sIGxvb3AgZXRjLgoKCiAgZnVuY3Rpb24gUGFyc2UoY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSB7CiAgICB2YXIgZWxlbWVudCA9IGNsZWFuZWRfc291cmNlZGF0YVtpXTsKICAgIHZhciBzdHJpbmcgPSBbXTsgLy9QdXNoIHZhcmlhYmxlcyB0byB0b2tlbnMKICAgIC8vRm9ybWF0OiB7dHlwZTogInZhcmlhYmxlIiwgdmFsdWU6ICJSZXZlcnNlU3RyaW5nIn0KCiAgICBpZiAoaXNWYXJpYWJsZShlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgIC8vSGVyZSB3ZSBzZXBlcmF0ZSBNZXNzYWdlID0gJ0hlbGxvJyBpbnRvIGZvbGxvd2luZyB0aHJlZSB0b2tlbnMgOgogICAgICAvLzE6wqB7dHlwZTrCoCJ2YXJpYWJsZSIswqB2YWx1ZTrCoCJNZXNzYWdlIn0gCiAgICAgIC8vMjrCoHt0eXBlOsKgIm9wZXJhdG9yIizCoHZhbHVlOsKgIj0ifQogICAgICAvLzM6wqB7dHlwZTrCoCJ2YWx1ZSIswqB2YWx1ZTrCoCJIZWxsbyJ9CiAgICAgIGlmIChjbGVhbmVkX3NvdXJjZWRhdGFbaSArIDFdID09ICc9JykgewogICAgICAgIFB1c2hWYXJpYWJsZShlbGVtZW50LCB0b2tlbnMpOyAvL0lmIHdlIGFscmVhZHkgaGF2ZSB0aGUgdmFyaWFibGUgZGVjbGFyZWQgYmVmb3JlLCBwdXNoIGl0IHRvIFJlSW50aWFsaXplZFZhcmlhYmxlcyBhcnJheQoKICAgICAgICBpZiAodmFyaWFibGVBcnJheS5pbmNsdWRlcyhlbGVtZW50KSkgewogICAgICAgICAgdmFyIHggPSB0b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgcmV0dXJuIGVsLnZhbHVlID09IGVsZW1lbnQ7CiAgICAgICAgICB9KTsKICAgICAgICAgIHZhciBpbmRleCA9IHRva2Vucy5pbmRleE9mKHgpOwogICAgICAgICAgUmVJbnRpYWxpemVkVmFyaWFibGVzLnB1c2goewogICAgICAgICAgICBuYW1lOiBlbGVtZW50CiAgICAgICAgICB9KTsgLy8KICAgICAgICAgIC8vdG9rZW5zW2luZGV4KzJdLnZhbHVlPSBjbGVhbmVkX3NvdXJjZWRhdGFbaSsyXQogICAgICAgIH0KCiAgICAgICAgdmFyaWFibGVBcnJheS5wdXNoKGVsZW1lbnQpOwogICAgICB9IGVsc2UgaWYgKGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0gPT0gJz0nKSB7CiAgICAgICAgUHVzaFZhcmlhYmxlVmFsdWUoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgfSAvL1B1c2ggdmFyaWFibGVzIHRvIHRva2VucwoKICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICBQdXNoTnVtYmVyKGVsZW1lbnQsIHRva2Vucyk7IC8vUHVzaCBFbXB0eVN0cmluZ3MgdG8gdG9rZW5zCiAgICB9IGVsc2UgaWYgKGlzRW1wdHlTdHJpbmdvckNoYXIoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAvL0luIHNvbWUgY2FzZXMgZW1wdHkgc3RyaW5ncyB3aWxsIGJlIG1vZGlmaWVkIGludG8gc29tZXRoaW5nIGxpa2UgIiciIG9yICciJwogICAgICAvL1dlIGNvbnZlcnQgaXQgYmFjayB0byAiICIKICAgICAgaWYgKGVsZW1lbnQubGVuZ3RoID4gMSAmJiAoZWxlbWVudC5jaGFyQXQoMCkgPT0gIiciIHx8IGVsZW1lbnQuY2hhckF0KDApID09ICciJykpIHsKICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5yZXBsYWNlKC9bJyJdKy9nLCAnJyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZWxlbWVudCA9ICIgIjsKICAgICAgfQoKICAgICAgUHVzaFZhcmlhYmxlVmFsdWUoZWxlbWVudCwgdG9rZW5zKTsgLy9QdXNoIElucHV0IHRvIHRva2VucwogICAgICAvL0Zvcm1hdDoge3R5cGU6wqAiQWNjZXB0SW5wdXQiLMKgdmFsdWU6wqAiICIswqBBY2NlcHRBczrCoCJNZXNzYWdlIn0KICAgIH0gZWxzZSBpZiAoaXNJbnB1dChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgIFB1c2hJbnB1dChlbGVtZW50LCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSk7IC8vUHVzaCBvcGVyYXRvcnMgdG8gdG9rZW5zLiBUaGUgYWNjZXB0ZWQgb3BlcmF0b3JzIGFyZSA9LH0sewogICAgICAvL0Zvcm1hdDrCoHt0eXBlOsKgIm9wZXJhdG9yIizCoHZhbHVlOsKgIj0ifSAgICAKICAgIH0gZWxzZSBpZiAoaXNPcGVyYXRvcihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgIFB1c2hPcGVyYXRvcihlbGVtZW50LCB0b2tlbnMpOyAvL1B1c2gga2V5b3dyZHMgdG8gdG9rZW5zLiBUaGUgYWNjZXB0ZWQga2V5d29yZHMgaXMg4KSq4KWN4KSw4KS/4KSC4KSfCiAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJrZXl3b3JkIizCoHZhbHVlOsKgIuCkquCljeCksOCkv+CkguCknyJ9CiAgICB9IGVsc2UgaWYgKGlzS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQsIHRva2Vucyk7IC8vUHVzaCBmdW5jdGlvbnMgdG8gdG9rZW5zCiAgICAgIC8vRm9ybWF0OiB7dHlwZTogImZ1bmN0aW9uIiwgdmFsdWU6ICJGaXJzdCIsIGFyZ3VtZW50czogQXJyYXkoMiksIEZ1bmN0aW9uSW52b2NhdGlvbkV4aXN0czogZmFsc2UsIEZ1bmN0aW9uU3RhY2s6IEFycmF5KDApLCDigKZ9CiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICBQdXNoRnVuY3Rpb25EYXRhKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKICAgIH0gLy8gUHVzaCBhcnJheSB0byB0b2tlbnMKICAgIC8vRm9ybWF0OiB7dHlwZTogIkFycmF5IiwgdmFsdWU6ICJbXSJ9CiAgICBlbHNlIGlmIChpc0FycmF5KGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICBpZiAoZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGggLSAxKSA9PSAnXScpIHsKICAgICAgICAgIFB1c2hBcnJheShlbGVtZW50LCB0b2tlbnMpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvL1RvIGNvbnZlcnQgJ1snLDEsMiwzLDQsJ10nICBpbnRvIFsxLDIsMyw0XQogICAgICAgICAgdmFyIEJ1aWx0QXJyYXkgPSBCdWlsZEFycmF5KGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7CiAgICAgICAgICBQdXNoQXJyYXkoQnVpbHRBcnJheSwgdG9rZW5zKTsKICAgICAgICB9CiAgICAgIH0gLy9Gb3Igb3BlcmF0aW9ucyBsaWtlIE51bWJlcnNbYV09YQogICAgICAvL0Zvcm1hdDoge3R5cGU6wqAiU2V0QXJyYXlJbmRleFZhbHVlIizCoHZhbHVlOsKgIkZpYm9uYWNjaVthXSIswqBWYWx1ZVRvU2V0OsKgImEifQogICAgICBlbHNlIGlmIChpc1NldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpID09IHRydWUpIHsKICAgICAgICAgIFB1c2hTZXRBcnJheUluZGV4VmFsdWUoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgIH0gLy9Gb3Igb3BlcmF0aW9ucyBsaWtlIGE9TnVtYmVyc1thXSwgcmV2ZXJzZSBvZiBhYm92ZQogICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJHZXRBcnJheUluZGV4VmFsdWUiLMKgdmFsdWU6wqAiRmlib25hY2NpW2EtMl0ifQogICAgICAgIGVsc2UgaWYgKGlzU2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkgPT0gZmFsc2UpIHsKICAgICAgICAgICAgUHVzaEdldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSk7CiAgICAgICAgICB9IC8vUHVzaCBjb25kaXRpb25zIHRvIHRva2Vucy4gVGhlIGFjY2VwdGVkIGtleXdvcmRzIGFyZSDgpIXgpJfgpLAsIOCknOCkrOCkpOCklSwg4KSF4KSo4KWN4KSv4KSl4KS+CiAgICAgICAgICAvLyBGb3JtYXQ6IHt0eXBlOsKgImNvbmRpdGlvbmFsa2V5d29yZCIswqB2YWx1ZTrCoCLgpIXgpJfgpLAifQogICAgICAgICAgZWxzZSBpZiAoaXNDb25kaXRpb25hbEtleXdvcmQoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgIC8vUHVzaCB3aGlsZSBsb29wcyB0byB0b2tlbnMKICAgICAgICAgICAgICAvL0Zvcm1hdDoge3R5cGU6ICJXaGlsZUxvb3BTdGFydCIsIHZhbHVlOiAi4KSc4KSs4KSk4KSVIn0sIHt0eXBlOiAiY29uZGl0aW9uIiwgdmFsdWU6ICJjb3VudDwyNSJ9CiAgICAgICAgICAgICAgaWYgKGlzV2hpbGVMb29wKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgIFB1c2hXaGlsZUxvb3AoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBQdXNoQ29uZGl0aW9uYWxLZXl3b3JkKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICAgICAgfSAvL1RoaXMgaXMgaG93IHdlIHB1c2ggY29uZGl0aW9ucyBlbmNvdW50ZXJlZCBpbiB0aGUgc291cmNlY29kZQogICAgICAgICAgICAgIC8vRm9ybWF0Ont0eXBlOsKgImNvbmRpdGlvbiIswqB2YWx1ZTrCoCJhPDMifQoKCiAgICAgICAgICAgICAgdmFyIGZvdW5kY29uZGl0aW9uID0gQnVpbGRDb25kaXRpb24oZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKTsgLy9QdXNoIGNvbmRpdGlvbnMgdG8gdG9rZW5zIGFycmF5CgogICAgICAgICAgICAgIFB1c2hDb25kaXRpb24oZm91bmRjb25kaXRpb24sIHRva2Vucyk7CiAgICAgICAgICAgIH0gLy9GaW5kaW5nIG9wZXJhdGlvbnMgbGlrZSBOdW1iZXJzLuCkquClgeCktih4KSAKICAgICAgICAgICAgLy9Gb3JtYXQ6IHt0eXBlOiAiUHVzaFRvQXJyYXkiLCB2YWx1ZTogIk51bWJlcnMu4KSq4KWB4KS2KHgpIn0KICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5pbmNsdWRlcygn4KSq4KWB4KS2JykpIHsKICAgICAgICAgICAgICAgIFB1c2hUb0FycmF5KGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICAgICAgfSAvL1B1c2ggRm9yIGxvb3AgdG8gdG9rZW5zCiAgICAgICAgICAgICAgLy8gRm9ybWF0OiAKICAgICAgICAgICAgICAvLyB7dHlwZTrCoCJGb3JMb29wU3RhcnQiLMKgdmFsdWU6wqAi4KSm4KWB4KS54KSw4KS+4KSTIn0KICAgICAgICAgICAgICAvL8Kge3R5cGU6wqAiRm9yTG9vcEFyZ3VtZW50cyIswqBpdGVyYXRvcjrCoCJhIizCoHZhbHVlOsKgIigwLDI1KSIswqBpdGVyYXRpb25TdGFydDrCoCIwIizCoGl0ZXJhdGlvbkVuZDrCoCIyNSJ9CiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGb3JMb29wKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgUHVzaEZvckxvb3AoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgUHVzaEZvckxvb3BBcnVndW1lbnRzKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgbmFtZTogY2xlYW5lZF9zb3VyY2VkYXRhW2kgKyAxXSwKICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMCwKICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRm9yTG9vcEl0ZXJhdG9yJwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0gLy9QdXNoaW5nIGJhc2ljIENhbGN1bGF0aW9ucyBsaWtlICdsZW5ndGgtMScgdG8gdG9rZW5zCiAgICAgICAgICAgICAgICAvL0Zvcm1hdDoge3R5cGU6wqAiQ2FsY3VsYXRpb24iLMKgdmFsdWU6wqAibGVuZ3RoLTEifQogICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNDYWxjdWxhdGlvbihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50MiA9ICcnOwoKICAgICAgICAgICAgICAgICAgICBpZiAoY2xlYW5lZF9zb3VyY2VkYXRhW2kgKyAxXSAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGYgaXMgdG8gcGVyZm9ybSBsb25nIGNhbGN1bGF0aW9ucyBsaWtlIEF2ZXJhZ2VBZ2U9KGFnZW9uZSthZ2V0d28pLzIgKyAoYWdlb25lK2FnZXR3bykqMgogICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGlzQ2FsY3VsYXRpb24oY2xlYW5lZF9zb3VyY2VkYXRhW2ldKSkgewogICAgICAgICAgICAgICAgICAgICAgICBfZWxlbWVudDIgPSBfZWxlbWVudDIgKyBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CiAgICAgICAgICAgICAgICAgICAgICAgIGkrKzsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIHRlcm1zID0gX2VsZW1lbnQyLnNwbGl0KCcnKTsgLy9yZW1vdmluZyB0aGUgIigiIiBhbmQgIikiCgogICAgICAgICAgICAgICAgICAgIHZhciBDbGVhbmVkRWxlbWVudCA9IFJlbW92ZUJyYWNrZXRzKF9lbGVtZW50Mik7IC8vIHRvIHN0b3AgcHJldmVudGlvbiBvZiBleHByZXNzaW9ucyBsaWtlIGlzIisgZ2V0dGluZyBhZGRlZCBhcyBhIGNhbGN1bGF0aW9uCgogICAgICAgICAgICAgICAgICAgIGlmICghQ2xlYW5lZEVsZW1lbnQuaW5jbHVkZXMoJyInKSAmJiBfZWxlbWVudDIuY2hhckF0KDApICE9ICcvJyAmJiBfZWxlbWVudDIuY2hhckF0KDApICE9ICcqJyAmJiBfZWxlbWVudDIuY2hhckF0KDApICE9ICInIikgewogICAgICAgICAgICAgICAgICAgICAgUHVzaENhbGN1bGF0aW9uKF9lbGVtZW50MiwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIHByaW50KHggKyAneScpLiBUaGUgUmVhbFRpbWVQcmludCBvcGVyYXRpb25zCiAgICAgICAgICAgICAgICAgIC8vRm9ybWF0OiB7dHlwZTrCoCJ2YWx1ZSIswqB2YWx1ZTrCoCIoJ1JldmVyc2VkIFN0cmluZy0nKyBSZXZlcnNlU3RyaW5nKSIswqBtb2RlOsKgIlJlYWxUaW1lUHJpbnQifQogICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlYWxUaW1lUHJpbnRNdWx0aXBsZVN0cmluZyhlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRTdHJpbmcgPSAnJzsKICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gaTsKICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb25FbmQgPSBlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDEpICsgZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGggLSAyKTsKICAgICAgICAgICAgICAgICAgICAgIHZhciBmbGFnID0gMDsKCiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGs7IGsgPCBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOyBrKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50MyA9IGNsZWFuZWRfc291cmNlZGF0YVtrXTsKCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfY29uZGl0aW9uRW5kID0gX2VsZW1lbnQzLmNoYXJBdChfZWxlbWVudDMubGVuZ3RoIC0gMSkgKyBfZWxlbWVudDMuY2hhckF0KF9lbGVtZW50My5sZW5ndGggLSAyKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZWxlbWVudDMuaW5jbHVkZXMoJ+CkpuClgeCkueCksOCkvuCkkycpIHx8IF9lbGVtZW50My5pbmNsdWRlcygn4KSw4KSa4KSo4KS+JykgfHwgX2VsZW1lbnQzLmluY2x1ZGVzKCfgpIXgpKjgpY3gpK/gpKXgpL4nKSB8fCBfZWxlbWVudDMuaW5jbHVkZXMoJ+Ckh+CkqOCkquClgeCknycpIHx8IF9lbGVtZW50My5pbmNsdWRlcygn4KSq4KWB4KS2JykgfHwgX2VsZW1lbnQzLmluY2x1ZGVzKCfgpKrgpY3gpLDgpL/gpILgpJ8nKSB8fCBfZWxlbWVudDMuaW5jbHVkZXMoJ+CkheCkl+CksCcpIHx8IGNsZWFuZWRfc291cmNlZGF0YVtrICsgMV0gPT0gJz0nIHx8IF9lbGVtZW50MyA9PSAnfScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb25kaXRpb25FbmQgPT0gJykiJykgewogICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RyaW5nID0gZm91bmRTdHJpbmcgKyAnICcgKyBjbGVhbmVkX3NvdXJjZWRhdGFba107CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZyA9PSAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdHJpbmcgPSBmb3VuZFN0cmluZyArICcgJyArIGNsZWFuZWRfc291cmNlZGF0YVtrXTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmbGFnID09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFN0cmluZyA9IGNsZWFuZWRfc291cmNlZGF0YVtrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRTdHJpbmcuaW5jbHVkZXMoIj4iKSAmJiAhZm91bmRTdHJpbmcuaW5jbHVkZXMoJy8nKSAmJiAhZm91bmRTdHJpbmcuaW5jbHVkZXMoJyonKSAmJiAhZm91bmRTdHJpbmcuaW5jbHVkZXMoJzwnKSAmJiAhZm91bmRTdHJpbmcuaW5jbHVkZXMoJz09JykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm91bmRTdHJpbmc6ICcsIGZvdW5kU3RyaW5nKTsKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaFJlYWxUaW1lUHJpbnRPcGVyYXRpb24oZm91bmRTdHJpbmcsIHRva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSAvL3N0b3Jpbmcgb25seSB0aGUgc3RyaW5nIHZhbHVlcyB0byB0b2tlbnMgKCBub3QgdGhlIHN0cmluZ3MgaW4gcHJpbnQgc3RhdGVtZW50cykKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhlbGVtZW50KSkgewogICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlZFN0cmluZyA9IEJ1aWxkU3RyaW5nKGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRTdHJpbmcgPSBjYWxjdWxhdGVkU3RyaW5nLnJlcGxhY2UoL1snIl0rL2csICcnKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxjdWxhdGVkU3RyaW5nLmluY2x1ZGVzKCLgpKrgpY3gpLDgpL/gpILgpJ8iKSkgUHVzaFN0cmluZyhjYWxjdWxhdGVkU3RyaW5nLCB0b2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgfSAvL0FuIGV4dGVuc2lvbiBvZiBpc0tleXdvcmQoKSBmdW5jdGlvbgogICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZHMgaW1wcm92ZW1lbnQKICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eKD89Lio/4KSq4KWN4KSw4KS/4KSC4KSfKSg/PS4qW2Etel0pLy50ZXN0KGVsZW1lbnQpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEtleXdvcmQoZWxlbWVudC5zbGljZSgwLCA2KSwgdG9rZW5zKTsgLy9QdXNoaW5nIHByaW50IGtleXdvcmQgb25seQoKICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoRXhwcmVzc2lvbihlbGVtZW50LnNsaWNlKDYpLCB0b2tlbnMpOyAvL1B1c2hpbmcgcmVtYWluaW5nIGV4cHJlc3Npb24gbGlrZSAoYSksIChNZXNzYWdlKSBldGMKICAgICAgICAgICAgICAgICAgICAgICAgfSAvL2Vycm9yIHByb25lIGNoYW5nZSBtYWRlIGhlcmUtIFB1c2hpbmcgZXhwcmVzc2lvbiBpbiBoZXJlCiAgICAgICAgICAgICAgICAgICAgICAgIC8vVXNlZCB0byBwdXNoIGZ1bmN0aW9ucyBhbmQgZXhwcmVzc2lvbnMKICAgICAgICAgICAgICAgICAgICAgICAgLy9Vbm5lY2Vzc2FyeSBkYXRhIGlzIGJlaW5nIHBhc3NlZCB0aHJvdWdoIGthbGFhbS4KICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGlzIHdhcyBjcmVhdGVkIGZvciBhIHRlbXBvcmFyeSBmaXgKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHByZXNzaW9uKGVsZW1lbnQpID09IHRydWUgJiYgIWlzQ2FsY3VsYXRpb24oZWxlbWVudCkgJiYgIWVsZW1lbnQuaW5jbHVkZXMoJ1snKSAmJiAhZWxlbWVudC5pbmNsdWRlcygnXScpICYmICFpc0NvbmRpdGlvbmFsS2V5d29yZChjbGVhbmVkX3NvdXJjZWRhdGFbaSAtIDFdKSAmJiBjbGVhbmVkX3NvdXJjZWRhdGFbaSAtIDFdICE9ICfgpK7gpYcnICYmIGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0gIT0gJ+CksOCkmuCkqOCkvicpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDaGVja0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGVsZW1lbnQuc3BsaXQoJygnKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXNzZWRWYWx1ZXMgPSBSZW1vdmVCcmFja2V0cyhDaGVja0Z1bmN0aW9uRXhwcmVzc2lvblsxXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWRWYWx1ZXMgPSBwYXNzZWRWYWx1ZXMuc3BsaXQoJywnKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Rva2VuMiA9IHRva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwudmFsdWUgPT0gQ2hlY2tGdW5jdGlvbkV4cHJlc3Npb25bMF07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Rva2VuMiAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEZ1bmN0aW9uRXhlY3V0aW9uKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCBwYXNzZWRWYWx1ZXMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEV4cHJlc3Npb24oZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRXhwcmVzc2lvbihlbGVtZW50KSA9PSB0cnVlICYmIGVsZW1lbnQuaW5jbHVkZXMoJ1snKSAmJiBlbGVtZW50LmluY2x1ZGVzKCddJykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hBcnJheShlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9UaGlzIGlzIGV4cGVyaW1lbnRhbC4gRm9yIG5vdywgeW91IGNhbiBqdXN0IG5lZ2xlY3Qgc2VsZgogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0tleXdvcmQoZWxlbWVudCkgJiYgIWlzTnVtYmVyKGVsZW1lbnQpICYmICFpc1ZhcmlhYmxlKGVsZW1lbnQpICYmICFpc0V4cHJlc3Npb24oZWxlbWVudCkgJiYgIWlzT3BlcmF0b3IoZWxlbWVudCkpIHsvL0FOQ0hPUiAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qSG5hZGxpbmcgSW1wdXJpdHkgZXJyb3ItVGhlIG1haW4gcHJvYmxlbSBpcyBmaWd1cmluZyBvdXQgaG93IHRvIHNvbHZlICI9NzAwMCIgbGlrZSB0aGluZ3MKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGVhZCBhc2tpbmcgZGV2ZWxvcGVycyB0byBhZGQgc3BhY2UgbWFudWFsbHkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGFuZGxpbmcgQWxwaGFudW1lcmljIHN0cmluZ3MgdG8gc29sdmUgaXNzdWVzIGxpa2UgJyBhbm5hPTIzNjI5MzQnCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1wdXJpdHkgPSBlbGVtZW50LnNwbGl0KCc9JykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaW5kU3RyaW5nID0gaW1wdXJpdHlbMV0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RvIGFjY2VwdCBsb25nIG51bWJlcnMgaS5lIGE9NzQ5Mzc0NTkzNzQ1OTM3CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShpbXB1cml0eVswXSkgJiYgaXNOdW1iZXIoaW1wdXJpdHlbMV0pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXR5WzJdID0gaW1wdXJpdHlbMV07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXB1cml0eVsxXSA9ICc9JzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdG8gYWNjZXB0IGE9U1RSSU5HCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGltcHVyaXR5WzBdKSAmJiBpc1ZhcmlhYmxlKGltcHVyaXR5WzFdKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXB1cml0eVsyXSA9IGltcHVyaXR5WzFdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHlbMV0gPSAnPSc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXR5LmZvckVhY2goKGVsZW1lbnQsIGkpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaFZhcmlhYmxlKGVsZW1lbnQsIHRva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29udGludWU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQU5DSE9SIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSXNzdWU6IFJpZ2h0IG5vdywgb25seSBpc051bWJlciBpcyByZXNvbHZlZCwgYT0sID0yMzgyOHF3IGFyZW4ndCByZXNvbHZlZC4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU29sdXRpb246IFdvcmsgb24gYWxsIHRoZSBtb2R1bGVzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoTnVtYmVyKGVsZW1lbnQsIHRva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9BTkNIT1IgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1lvdSBtaWdodCBoYXZlIHRvIHJlbW92ZSBzZWxmIGV4dHJhIGZpbHRlcnMgc2luY2UgeW91IGFyZSBvbmx5IHdvcmtpbmcgb24gbnVtYmVycyAoRnV0dXJlIElzc3VlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT3BlcmF0b3IoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hPcGVyYXRvcihlbGVtZW50LCB0b2tlbikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNLZXl3b3JkKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEtleXdvcmQoZWxlbWVudCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoRXhwcmVzc2lvbihlbGVtZW50LCB0b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi8KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICB9IC8vVGhlIGZpbmFsIHN0YWdlIG9mIGFkZGluZyBhbiBvdXRwdXQgdG8gb3V0cHV0IHN0YWNrIGkuZS4ga2FsYWFtLm91dHB1dCBvciBrYWxhYW0ub3V0cHV0CgoKICBmdW5jdGlvbiBBZGRPdXRwdXQodmFsdWUpIHsKICAgIGthbGFhbS5vdXRwdXQgPSBrYWxhYW0ub3V0cHV0ICsgdmFsdWUgKyAiXG4iOwogIH0gLy8jU1RFUCAxLSBDbGVhbmluZyB0aGUgc291cmNlZGF0YSBhbmQgc2V0dGluZyB0aGUgJ3Jlc3VsdCcgdG8gJ2NsZWFuZWRfc291cmNlZGF0YScKICAvL0lmIGEgY29kZSBpcyBub3Qgd29ya2luZywgaXQgaXMgcHJvYmFibHkgYmVjYXVzZSBpdCdzIG5vdCBjbGVhbmVkIHByb3Blcmx5LiAKCgogIGNsZWFuZWRfc291cmNlZGF0YSA9IEdldENsZWFuU291cmNlZGF0YShzb3VyY2VkYXRhLCBjbGVhbmVkX3NvdXJjZWRhdGEsIG1peGVkaW1wdXJpdHkpOyAvLyNTVEVQIDItIC0gQ2hlY2tpbmcgZWFjaCB0b2tlbiBhbmQgYWRkaW5nIHRvIHRva2VucyBhcnJheQogIC8vUGFyc2luZyBldmVyeSBzaW5nbGUgZWxlbWVudCBmcm9tIGNsZWFuZWRfc291cmNlZGF0YSBhcnJheSBhbmQgcHVzaGluZyBpdCB0byBUb2tlbnMgZGVwZW5kaW5nIHVwb24gdGhlIHR5cGUgcGYgZWxlbWVudAogIC8vIFBBUlNJTkcgSU5JVElBVElPTgoKICBmb3IgKGk7IGkgPCBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOyBpKyspIHsKICAgIFBhcnNlKGNsZWFuZWRfc291cmNlZGF0YSwgaSk7CiAgfSAvL0NMRUFOSU5HIFVQIFRIRSBUT0tFTlMgQVJSQVkKICAvL1JlbW92aW5nIHRva2VucyB3aXRoIHZhbHVlID0gJycsIEl0IHdhcyBnZW5lcmF0ZWQgZHVlIHRvICIgY2xlYW5lZF9zb3VyY2VkYXRhID0gY2xlYW5lZF9zb3VyY2VkYXRhLnJlcGxhY2UoLyg7fFxufFxyKS9nbSwgIiAiKS5zcGxpdCgnICcpIgoKCiAgdG9rZW5zID0gdG9rZW5zLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsKICAgIHJldHVybiBlbC52YWx1ZSAhPSAnJzsKICB9KTsKICBjb25zb2xlLmxvZygndG9rZW5zOiAnLCB0b2tlbnMpOyAvLyNTVEVQIDMgLSBldmFsdWF0aW5nIGNvbmRpdGlvbnMsIGZpbmRpbmcgdmFsdWVzIGluIHVwZGF0ZWRfdG9rZW5zIGFuZCBwcmludGluZyBvdXRwdXRzCiAgLy9BcyBvZiBub3csIHNlbGYgaXMgaG93IHRoZSB0aW1lbGluZSBsb29rcwogIC8vcmF3IHNvdXJjZWNvZGUgLT4gY2xlYW5lZF9zb3VyY2VkYXRhIC0+IHRva2VucyAKICAvL1RoaXMgaXMgdGhlIGZpbmFsIHNlY3Rpb24KCiAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHsKICAgIC8vV2Ugd2lsbCBiZSBoYXZpbmcgYSBjb3B5IG9mIHRva2VucyBhcyBtdXRhYmxlX3Rva2VucyAKICAgIHZhciBtdXRhYmxlX3Rva2VucyA9IHRva2VuczsgLy90b2tlbiB2YWx1ZQoKICAgIHZhciB0b2tlbiA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlOyAvL3R5cGUgb2YgdG9rZW4gbGlrZSB2YXJpYWJsZSwgYXJyYXksIGZ1bmN0aW9uLCBsb29wcyBldGMKCiAgICB2YXIgdG9rZW5UeXBlID0gbXV0YWJsZV90b2tlbnNbal0udHlwZTsKICAgIHZhciBTdHJpbmdWYXIgPSBbXTsKICAgIHZhciBWYXJXaXRob3V0YnJhY2tldHMgPSBSZW1vdmVCcmFja2V0cyhtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSk7CiAgICBWYXJXaXRob3V0YnJhY2tldHMgPSBWYXJXaXRob3V0YnJhY2tldHMucmVwbGFjZSgvIC9nLCAnJyk7CgogICAgaWYgKHRva2VuVHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikgewogICAgICBTZXRBcnJheUluZGV4VmFsdWUobXV0YWJsZV90b2tlbnMsIGosIGosIHVwZGF0ZWRfdG9rZW5zLCB0b2tlbnMsIE9yaWdpbmFsSXRlcmF0b3IsIGl0ZXJhdG9yKTsKICAgIH0gZWxzZSBpZiAodG9rZW4gPT0gJz0nKSB7CiAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKG11dGFibGVfdG9rZW5zLCBqLCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IsIHNlbGYpOwogICAgfSBlbHNlIGlmICh0b2tlblR5cGUgPT0gJ1B1c2hUb0FycmF5JykgewogICAgICBBZGRFbGVtZW50VG9BcnJheShtdXRhYmxlX3Rva2VucywgaiwgdXBkYXRlZF90b2tlbnMpOwogICAgfSBlbHNlIGlmICh0b2tlbiA9PSAn4KSF4KSo4KWN4KSv4KSl4KS+JykgewogICAgICB2YXIgcmVzdWx0ID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBqLCByZXN1bHQpOwogICAgICBjb25zb2xlLmxvZygncmVzdWx0OiAnLCByZXN1bHQpOwogICAgICB2YXIgU3RhcnRvZkJsb2NrID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnN0YXJ0SW5kZXg7CiAgICAgIHZhciBFbmRvZkJsb2NrID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLkVuZEluZGV4OwogICAgICB2YXIgbGFzdFZhbHVlID0ga2FsYWFtLkxhc3RDb25kaXRpb25WYWx1ZS5wb3AoKTsKCiAgICAgIGlmIChsYXN0VmFsdWUgPT0gdHJ1ZSkgewogICAgICAgIGogPSBFbmRvZkJsb2NrOwogICAgICB9CiAgICB9IGVsc2UgaWYgKHRva2VuVHlwZSA9PSAnQWNjZXB0SW5wdXQnKSB7CiAgICAgIEFjY2VwdElucHV0YW5kU2V0VmFsdWUobXV0YWJsZV90b2tlbnMsIGosIHVwZGF0ZWRfdG9rZW5zKTsKICAgIH0gLy9XaGVuZXZlciB3ZSBlbmNvdW50ZXIgYSBmdW5jdGlvbiwgd2UgY3JlYXRlIGEgc2VwZXJhdGUgZXhlY3V0aW9uIGNvbnRleHQgCiAgICBlbHNlIGlmICh0b2tlblR5cGUgPT0gJ2Z1bmN0aW9uJykgewogICAgICAgIC8vV2UgYXJlIHByZXBhcmluZyB0aGUgcmVxdWlyZWQgZGF0YSB0byBleGVjdXRlIGEgZnVuY3Rpb24gY2FsbCBsYXRlciBpbiB0aGUgcHJncm9hbQogICAgICAgIC8vZnVuY3Rpb25zb3VyY2VkYXRhIGluY2x1ZGVzIGFsbCB0aGUgdG9rZW5zIGZyb20gdG9rZW5zIGFycmF5IHdoaWNoIGJlbG9uZ3MgdG8gYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uCiAgICAgICAgLy9XZSBmaW5kIHNlbGYgcmFuZ2Ugb3IgYSBmdW5jdGlvbiBibG9jayB0aHJvdWdoIEhhbmRsZUJsb2NrcyBmdW5jdGlvbgogICAgICAgIHZhciBmdW5jdGlvblNvdXJjZURhdGEgPSBbXTsKCiAgICAgICAgdmFyIF9yZXN1bHQgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIGogKyAxLCBmdW5jdGlvblNvdXJjZURhdGEpOwoKICAgICAgICBmdW5jdGlvblNvdXJjZURhdGEgPSBfcmVzdWx0LlN0b3JlUmVzdWx0OyAvL1RvIGlkZW50aWZ5IGZ1bmN0aW9uIGNvbnRleHQgaW4gdG9rZW5zIGFycmF5CgogICAgICAgIGZ1bmN0aW9uU291cmNlRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgZWwuY29udGV4dCA9ICdmdW5jdGlvbic7CiAgICAgICAgfSk7CiAgICAgICAgbXV0YWJsZV90b2tlbnNbal0uU291cmNlRGF0YSA9IGZ1bmN0aW9uU291cmNlRGF0YTsKICAgICAgfSAvL1dlIGFyZSBvdXQgb2YgdGhlIGZ1Y250aW9uIGV4ZWN1dGlvbiBjb250ZXh0IGFuZCBiYWNrIHRvIGdsb2JhbCBleGVjdXRpb24gY29udGV4dAogICAgICBlbHNlIGlmICh0b2tlblR5cGUgPT0gJ2NvbmRpdGlvbicpIHsKICAgICAgICAgIHZhciBfZWxlbWVudDQgPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZTsgLy9zZWxmIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBzdGVwIHRvIGNhbGN1bGF0ZSB2YWx1ZSBvZiBvcGVyYXRpb25zIGxpa2Ug4KSF4KSX4KSwIChhZ2VvbmU9PTEwICYmIEF2ZXJhZ2VBZ2U8MTAwMCAmJiBhZ2V0d28+MTAwIHx8IGFnZW9uZT09MTApIE9SIChhZ2VvbmU9PTEwICkKCiAgICAgICAgICB2YXIgQ29uZGl0aW9uVmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShfZWxlbWVudDQsIHVwZGF0ZWRfdG9rZW5zLCBqKTsKICAgICAgICAgIGthbGFhbS5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaChDb25kaXRpb25WYWx1ZSk7IC8vaWYgdmFsdWUgaXMgZmFsc2UsIGp1c3Qgc2tpcCB0aGUgaWYgbG9vcCBjb250ZXh0LCBpZiBub3QgaXQgd2lsbCBiZSByYW4gaW4gZmluYWwgcHJpbnQgbW9kdWxlCgogICAgICAgICAgaWYgKENvbmRpdGlvblZhbHVlID09IGZhbHNlKSB7CiAgICAgICAgICAgIHZhciBJbml0aWFsaXplTG9vcCA9IHRva2Vucy5pbmRleE9mKG11dGFibGVfdG9rZW5zW2pdKTsgLy9IYW5kbGUgQmxvY2tzIGlzIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgY2FyZSBvZiBuZXN0ZWQgYmxvY2sgYnkgdGFraW5nIGNhcmUgb2YgbmVzdGVkIHsgYW5kIH0gYnJhY2tldHMKICAgICAgICAgICAgLy9pdCB1c2VzIHRoZSBzdGFjayB0byBwdXNoIGFuZCBwb3AgYnJhY2tldHMgdG8gYWNjdXJhdGVseSBpZGVudGlmeSBzdGFydCBhbmQgdGhlIGVuZCBvZiB0aGUgYmxvY2sKCiAgICAgICAgICAgIHZhciBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2Vucywgaik7CiAgICAgICAgICAgIGogPSBSZXR1cm52YWx1ZS5qOwogICAgICAgICAgfQogICAgICAgIH0gLy9TbyB0aGF0IHdlIGRvbid0IHByaW50IGEgc2FtZSB2YWx1ZSB0d2ljZS4gRmlyc3QgaW4gZ2xvYmFsIGV4ZWN1dGlvbiBjb250ZXh0IGFuZCB0aGUgaW4gZnVuY3Rpb24gY29udGV4dAogICAgICAgIC8vVGhpcyBvbmUgcHJpbnRzIHRoZSBnbG9iYWwgY29udGV4dCB2YWx1ZXMKICAgICAgICBlbHNlIGlmICh0b2tlbiA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJyAmJiBtdXRhYmxlX3Rva2Vuc1tqXS5jb250ZXh0ICE9ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgUHJpbnRFbmdpbmUobXV0YWJsZV90b2tlbnMsIHVwZGF0ZWRfdG9rZW5zLCBqLCBzZWxmKTsgLy9mb3Igb3BlcmF0aW9ucyBsaWtlIHByaW50KGFycmF5WzNdKQogICAgICAgICAgfSAvL1RoaXMgcnVucyBvdXIgd2hpbGUgbG9vcCAuaS5lIOCknOCkrOCkpOCklQogICAgICAgICAgZWxzZSBpZiAodG9rZW5UeXBlID09ICdXaGlsZUxvb3BTdGFydCcpIHsKICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgdmFyIGdldFdoaWxlTG9vcFNvdXJjZWRhdGEgPSBmdW5jdGlvbiBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0OwogICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICB2YXIgVG9rZW5zQ3VycmVudEluZGV4ID0gaiArIDM7CiAgICAgICAgICAgICAgICB2YXIgQ29uZGl0aW9uVmFsdWUgPSBmYWxzZTsKICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlOwogICAgICAgICAgICAgICAgdmFyIEV4dHJhdGNlZFZhcmlhYmxlID0gW107CiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSAnJzsKICAgICAgICAgICAgICAgIHZhciBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IDA7CiAgICAgICAgICAgICAgICB2YXIgV2hpbGVMb29wU291cmNlZGF0YVRva2VucyA9IFtdOwoKICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVtZW50Lmxlbmd0aDsgX2krKykgewogICAgICAgICAgICAgICAgICB2YXIgeCA9IGVsZW1lbnQuY2hhckF0KF9pKTsKCiAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKHgpKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZSArIHg7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGlmICghaXNWYXJpYWJsZShlbGVtZW50LmNoYXJBdChfaSArIDEpKSAmJiBpc1ZhcmlhYmxlKHgpKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIF90b2tlbjMgPSB1cGRhdGVkX3Rva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT0gdmFyaWFibGU7CiAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICAgIEV4dHJhdGNlZFZhcmlhYmxlLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGU6IHZhcmlhYmxlLAogICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF90b2tlbjMudmFsdWUKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9ICcnOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChtdXRhYmxlX3Rva2VucywgaiwgJ3snLCBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCk7CiAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gZ2V0V2hpbGVMb29wU291cmNlZGF0YShXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgbXV0YWJsZV90b2tlbnMsICd9JywgV2hpbGVMb29wU291cmNlZGF0YVRva2VucykuU3RvcmVSZXN1bHQ7IC8vY29uc3RhbnRseSBhY2Nlc3NpbmcgdGhlIGNvbmRpdGlvbnZhbHVlCgogICAgICAgICAgICAgICAgd2hpbGUgKEdldENvbmRpdGlvblZhbHVlKGVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBqICsgMSkpIHsKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgV2hpbGVMb29wU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgICAgICAgICAgICAgLy9TRUNUSU9OIHdoaWxlIGxvb3AgY29udGV4dAogICAgICAgICAgICAgICAgICAgIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pMl0udmFsdWUgPT0gJz0nKSB7CiAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTIsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2kyXS50eXBlID09ICdBY2NlcHRJbnB1dCcpIHsKICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdElucHV0YW5kU2V0VmFsdWUoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgX2kyLCB1cGRhdGVkX3Rva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgfSAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIFdoaWxlIGxvb3AKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pMl0udHlwZSA9PSAnY29uZGl0aW9uJykgewogICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGluZGV4IHJldHVybnMgYSB2YWx1ZSwgaXQgbWVhbnMgY29uZGl0aW9uIGlzIGZhbHNlIGFuZCBza2lwIHRoZSBleGVjdXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gSGFuZGxlQ29uZGl0aW9ucyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTIsIHVwZGF0ZWRfdG9rZW5zKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBfaTIgPSBpbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBfaTIgPSBfaTI7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0gLy9IYW5kbGluZyDgpKrgpY3gpLDgpL/gpILgpJ8gc3RhdGVtZW50cyBpbiB3aGlsZSBsb29wCiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pMl0udmFsdWUgPT0gJ+CkquCljeCksOCkv+CkguCknycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBQcmludEVuZ2luZShXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCB1cGRhdGVkX3Rva2VucywgX2kyLCBzZWxmKTsgLy9mb3Igb3BlcmF0aW9ucyBsaWtlIHByaW50KGFycmF5WzNdKQogICAgICAgICAgICAgICAgICAgICAgICB9IC8vb3BlcmF0aW9ucyBsaWtlIE51bWJlcnNbYV09J3h5eicKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTJdLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5SW5kZXhWYWx1ZShXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTIsIGosIHVwZGF0ZWRfdG9rZW5zLCB0b2tlbnMsIE9yaWdpbmFsSXRlcmF0b3IsIGl0ZXJhdG9yKTsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gLy9FbmQgb2YgV2hpbGUgbG9vcCBleGVjdXRpb24KICAgICAgICAgICAgICAgIC8vSGFuZGxpbmcgRm9yIGxvb3BzIAoKICAgICAgICAgICAgICB9KSgpOwogICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHlwZSA9PSAnRm9yTG9vcFN0YXJ0JykgewogICAgICAgICAgICAgIHZhciBnZXRTb3VyY2VkYXRhID0gZnVuY3Rpb24gZ2V0U291cmNlZGF0YShzdGFydEluZGV4LCBtdXRhYmxlX3Rva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KTsKICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gUmV0dXJudmFsdWUuU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgdmFyIEZsYWdQcmltYWxMb29wID0gMDsKICAgICAgICAgICAgICB2YXIgU291cmNlZGF0YVRva2VucyA9IFtdOwogICAgICAgICAgICAgIHZhciBGb3JMb29wTWV0YURhdGEgPSBGb3JMb29wU2V0TWV0YWRhdGEobXV0YWJsZV90b2tlbnMsIGosIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgICAgICB2YXIgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gRm9yTG9vcE1ldGFEYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydDsKICAgICAgICAgICAgICB2YXIgQ3ljbGUgPSBGb3JMb29wTWV0YURhdGEuQ3ljbGU7CiAgICAgICAgICAgICAgdmFyIE9yaWdpbmFsSXRlcmF0b3IgPSBGb3JMb29wTWV0YURhdGEuT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgICAgICB2YXIgSXRlcmF0aW9uU3RhcnQgPSBGb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQ7CiAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gRm9yTG9vcE1ldGFEYXRhLml0ZXJhdG9yOwogICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gRm9yTG9vcE1ldGFEYXRhLmVsZW1lbnQ7CiAgICAgICAgICAgICAgdmFyIGVsZW1lbnRWYWx1ZSA9IEZvckxvb3BNZXRhRGF0YS5lbGVtZW50VmFsdWU7CiAgICAgICAgICAgICAgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQobXV0YWJsZV90b2tlbnMsIGosICd7JywgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsKICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zID0gZ2V0U291cmNlZGF0YShGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQsIG11dGFibGVfdG9rZW5zLCAnfScsIFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgIGVsLmlzTmVzdGVkTG9vcCA9IGZhbHNlOwogICAgICAgICAgICAgIH0pOyAvL0NoZWNraW5nIGlmIHRoZSBmb3IgbG9vcCBoYXMgb25lIG1vcmUgZm9yIGxvb3AgaW5zaWRlIGl0CgogICAgICAgICAgICAgIHZhciBGaW5kTmVzdGVkTG9vcCA9IFNvdXJjZWRhdGFUb2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgIHJldHVybiBlbC50eXBlID09ICdGb3JMb29wU3RhcnQnOwogICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICBpZiAoRmluZE5lc3RlZExvb3AgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkTG9vcGluZGV4ID0gU291cmNlZGF0YVRva2Vucy5pbmRleE9mKEZpbmROZXN0ZWRMb29wKSArIDM7CiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkTG9vcGxlbmd0aCA9IFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5FbmRJbmRleCAtIFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5zdGFydEluZGV4ICsgMjsgLy9pZiB3ZSBoYXZlIGEgbmVzdGVkIGxvb3AsIHNldCBpc05lc3RlTG9vcCB0byBUUlVFCgogICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IE5lc3RlZExvb3BpbmRleDsgeCA8IE5lc3RlZExvb3BpbmRleCArIE5lc3RlZExvb3BsZW5ndGg7IHgrKykgewogICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zW3hdLmlzTmVzdGVkTG9vcCA9IHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygnKCcpICYmIGVsZW1lbnQuaW5jbHVkZXMoJywnKSkgewogICAgICAgICAgICAgICAgRmxhZ1ByaW1hbExvb3AgPSAxOwogICAgICAgICAgICAgIH0gLy9JdGVyYXRpbmcgb3ZlciBmb3Jsb29wIHNvdXJjZWRhdGEKICAgICAgICAgICAgICAvL3NlbGYgbGluZSAnaXRlcmF0b3IgPD0gQ3ljbGUnIGRldGVybWluZXMgc3RhcnQgb2YgdGhlIGxvb3AgYW5kIHRoZSBkdXJhdGlvbiBvZiB0aGUgbG9vcAoKCiAgICAgICAgICAgICAgZm9yIChpdGVyYXRvciA9IEl0ZXJhdGlvblN0YXJ0OyBpdGVyYXRvciA8PSBDeWNsZTsgaXRlcmF0b3IrKykgewogICAgICAgICAgICAgICAgdmFyIGZvcmxvb3BpbmRleCA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IE9yaWdpbmFsSXRlcmF0b3I7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIGZvcmxvb3BpbmRleC52YWx1ZSA9IGl0ZXJhdG9yOyAvL2ZsYWcgdG8gYXZvaWQgcnVubmluZyBzZWxmIGNvZGUgaWYgbG9vcCBpcyBwcmltYWwgYmVjYXVzZSB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBjb21wZWx0ZWx5IGRpZmZlcmVudAoKICAgICAgICAgICAgICAgIGlmIChGbGFnUHJpbWFsTG9vcCA9IDApIHsKICAgICAgICAgICAgICAgICAgRm9yTG9vcEFycmF5b3JTdHJpbmdPdXRwdXQoZWxlbWVudFZhbHVlLCBpdGVyYXRvciwgdXBkYXRlZF90b2tlbnMsIHNlbGYpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyBfaTMrKykgewogICAgICAgICAgICAgICAgICB2YXIgaXNOZXN0ZWQgPSBTb3VyY2VkYXRhVG9rZW5zW19pM10uaXNOZXN0ZWRMb29wOyAvL1RoaXMgY29kZSBydW5zIG9ubHkgaWYgd2UgaGF2ZSBhIG5lc3RlZCBsb29wIHNpdHVhdGlvbgoKICAgICAgICAgICAgICAgICAgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2kzXS50eXBlID09ICdGb3JMb29wU3RhcnQnKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIF9nZXRTb3VyY2VkYXRhID0gZnVuY3Rpb24gX2dldFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgU291cmNlZGF0YVRva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MoU291cmNlZGF0YVRva2Vucywgc3RhcnRJbmRleCwgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBSZXR1cm52YWx1ZS5TdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRmxhZ1ByaW1hbExvb3AgPSAwOwogICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zID0gW107CiAgICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZEZvckxvb3BNZXRhRGF0YSA9IEZvckxvb3BTZXRNZXRhZGF0YShTb3VyY2VkYXRhVG9rZW5zLCBfaTMsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydDsKICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkQ3ljbGUgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuQ3ljbGUgKyAxOwogICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLk9yaWdpbmFsSXRlcmF0b3I7CiAgICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZEl0ZXJhdGlvblN0YXJ0ID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkl0ZXJhdGlvblN0YXJ0OwogICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRpdGVyYXRvciA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5JdGVyYXRpb25TdGFydDsKICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkZWxlbWVudCA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5lbGVtZW50OwogICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRlbGVtZW50VmFsdWUgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuZWxlbWVudFZhbHVlOwogICAgICAgICAgICAgICAgICAgIE5lc3RlZEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KFNvdXJjZWRhdGFUb2tlbnMsIF9pMywgJ3snLCBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpOwogICAgICAgICAgICAgICAgICAgIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMgPSBfZ2V0U291cmNlZGF0YShOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQsIFNvdXJjZWRhdGFUb2tlbnMsICd9JywgTmVzdGVkU291cmNlZGF0YVRva2Vucyk7CgogICAgICAgICAgICAgICAgICAgIGZvciAoTmVzdGVkaXRlcmF0b3I7IE5lc3RlZGl0ZXJhdG9yIDwgTmVzdGVkQ3ljbGU7IE5lc3RlZGl0ZXJhdG9yKyspIHsKICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBOZXN0ZWRpdGVyYXRvcjsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZGZvcmxvb3BpbmRleCA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT0gTmVzdGVkT3JpZ2luYWxJdGVyYXRvcjsKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZGZvcmxvb3BpbmRleC52YWx1ZSA9IHk7CgogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgTmVzdGVkU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IGluZGV4KyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4XTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmludEVuZ2luZShOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCB1cGRhdGVkX3Rva2VucywgaW5kZXgsIHNlbGYsIHksIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudmFsdWUgPT0gJz0nICYmIGVsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCBpbmRleCwgdXBkYXRlZF90b2tlbnMsIHksIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PSAnY29uZGl0aW9uJyAmJiBlbC5pc05lc3RlZExvb3AgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIENvbmRpdGlvblN0YXJ0SW5kZXggPSBpbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4XS52YWx1ZTsgLy9IYW5kbGVDb25kaXRpb25zIGV2YWx1YXRlcyBjb25kaXRpb24gYW5kIHJldHVybiB0aGUgaW5kZXggb2YgZnJvbSB3aGVyZSBwcmludGluZyBzaG91bGQgcmVzdW1lCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhbHVlIG9mIGkgZGVwZW5kcyBvbiB0aGUgY29uZGl0aW9ucwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IEdldENvbmRpdGlvblZhbHVlKGNvbmRpdGlvbiwgdXBkYXRlZF90b2tlbnMsIGluZGV4KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGthbGFhbS5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaCh2YWx1ZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIiAmJiBlbC5pc05lc3RlZExvb3AgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsIF9pMywgaiwgdXBkYXRlZF90b2tlbnMsIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pM10udmFsdWUgPT0gJz0nICYmIGlzTmVzdGVkID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgLy9hc3NpZ25pbmcgdmFsdWVzIHRvIHZhcmlhYmxlcyBpbiBhIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoU291cmNlZGF0YVRva2VucywgX2kzLCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2kzXS50eXBlID09ICdQdXNoVG9BcnJheScpIHsKICAgICAgICAgICAgICAgICAgICBBZGRFbGVtZW50VG9BcnJheShTb3VyY2VkYXRhVG9rZW5zLCBfaTMsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pM10udHlwZSA9PSAnQWNjZXB0SW5wdXQnKSB7CiAgICAgICAgICAgICAgICAgICAgQWNjZXB0SW5wdXRhbmRTZXRWYWx1ZShTb3VyY2VkYXRhVG9rZW5zLCBfaTMsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgfSAvL0hhbmRsaW5nIHByaW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTNdLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIGlzTmVzdGVkID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgICBQcmludEVuZ2luZShTb3VyY2VkYXRhVG9rZW5zLCB1cGRhdGVkX3Rva2VucywgX2kzLCBzZWxmLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgfSAvL0hhbmRsaW5nIHNldCBhcnJheSBlbGVtZW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pM10udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikgewogICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUoU291cmNlZGF0YVRva2VucywgX2kzLCBqLCB1cGRhdGVkX3Rva2VucywgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgICB9IC8vIEhhbmRsaW5nIENPTkRJVElPTkFMIHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2kzXS50eXBlID09ICdjb25kaXRpb24nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9Db25kaXRpb25TdGFydEluZGV4ID0gX2kzOwogICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfY29uZGl0aW9uID0gU291cmNlZGF0YVRva2Vuc1tfaTNdLnZhbHVlOyAvL0hhbmRsZUNvbmRpdGlvbnMgZXZhbHVhdGVzIGNvbmRpdGlvbiBhbmQgcmV0dXJuIHRoZSBpbmRleCBvZiBmcm9tIHdoZXJlIHByaW50aW5nIHNob3VsZCByZXN1bWUKICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhbHVlIG9mIGkgZGVwZW5kcyBvbiB0aGUgY29uZGl0aW9ucwoKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbmRpdGlvbi5pbmNsdWRlcygnfHwnKSB8fCBfY29uZGl0aW9uLmluY2x1ZGVzKCcmJicpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3ZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoX2NvbmRpdGlvbiwgdXBkYXRlZF90b2tlbnMsIF9pMyk7IC8vRXhwZXJpbWVudGFsCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGthbGFhbS5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaChfdmFsdWUpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdmFsdWUgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEJsb2NrTGVuZ3RoID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEJsb2NrU3RhcnQgPSAwOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFNvdXJjZWRhdGFUb2tlbnNbX2kzXS52YWx1ZSAhPSAneycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTMgKyAxXS52YWx1ZSA9PSAneycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJsb2NrTGVuZ3RoID0gU291cmNlZGF0YVRva2Vuc1tfaTMgKyAxXS5FbmRJbmRleCAtIFNvdXJjZWRhdGFUb2tlbnNbX2kzICsgMV0uc3RhcnRJbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pMyA9IEJsb2NrTGVuZ3RoICsgX2kzICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kzKys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pMyA9IF9pMzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kzID0gSGFuZGxlQ29uZGl0aW9ucyhTb3VyY2VkYXRhVG9rZW5zLCBfaTMsIHVwZGF0ZWRfdG9rZW5zKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kzICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTMgPSBfaTM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTMgPSBfQ29uZGl0aW9uU3RhcnRJbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGogPSBqICsgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7CiAgICAgICAgICAgIH0gLy9FTkQgRk9SIExPT1AgRVhFQ1VUSU9OCiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuVHlwZSA9PSAnZnVuY3Rpb25FeGVjdXRpb24nKSB7CiAgICAgICAgICAgICAgICB2YXIgQ29tcGxldGVUb2tlblZhbHVlTGlzdDsKICAgICAgICAgICAgICAgIHZhciBGbGFnUHJpbWFsTG9vcDsKICAgICAgICAgICAgICAgIHZhciBTb3VyY2VkYXRhVG9rZW5zOwogICAgICAgICAgICAgICAgdmFyIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydDsKICAgICAgICAgICAgICAgIHZhciBDeWNsZTsKICAgICAgICAgICAgICAgIHZhciBPcmlnaW5hbEl0ZXJhdG9yOwogICAgICAgICAgICAgICAgdmFyIEl0ZXJhdGlvblN0YXJ0OwogICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yOwogICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQ7CiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFZhbHVlOwogICAgICAgICAgICAgICAgdmFyIE5lc3RlZEZsYWdQcmltYWxMb29wOwogICAgICAgICAgICAgICAgdmFyIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnM7CiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0OwogICAgICAgICAgICAgICAgdmFyIE5lc3RlZEN5Y2xlOwogICAgICAgICAgICAgICAgdmFyIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3I7CiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkSXRlcmF0aW9uU3RhcnQ7CiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkaXRlcmF0b3I7CiAgICAgICAgICAgICAgICB2YXIgTmVzdGVkZWxlbWVudDsKICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRlbGVtZW50VmFsdWU7CgogICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgLy9jaGVja2luZyBpZiBmdW5jdGlvbiBpcyBpbnZva2VkIHNvbWV3aGVyZSBsYXRlciBpbiB0aGUgcHJvZ3JhbQogICAgICAgICAgICAgICAgICAvL0lmIHdlIHNlZSBhIGZ1bmN0aW9uIGV4ZWN1dGlvbiBjYWxsLCBmb3IgZS5nIEFkZCh4LHkpLCB3ZSBwcmVwYXJlIGZvciBleGVjdXRpb24KICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uU291cmNlRGF0YSA9IFtdOwogICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gbXV0YWJsZV90b2tlbnNbal0udmFsdWU7CiAgICAgICAgICAgICAgICAgIHZhciBwYXNzZWRWYWx1ZXMgPSBtdXRhYmxlX3Rva2Vuc1tqXS5wYXNzZWRWYWx1ZXM7CiAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvblRva2VuID0gbXV0YWJsZV90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwudmFsdWUgPT0gZnVuY3Rpb25OYW1lOwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQXJndW1lbnRzID0gZnVuY3Rpb25Ub2tlbi5hcmd1bWVudHM7CiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uU291cmNlRGF0YSA9IGZ1bmN0aW9uVG9rZW4uU291cmNlRGF0YTsgLy9DcmVhdGluZyBhIHNlcGVyYXRlIGV4ZWN1dGlvbiBjb250ZXh0IGFuZCBzZXR0aW5nIGZ1Y250aW9uIGNvbnRleHQgbmFtZTp2YWx1ZSBwYWlyIGluIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zCiAgICAgICAgICAgICAgICAgIC8vZm9yIGUuZyB4PTMsIHk9NCBpcyBhbHJlYWR5IGRlZmluZWQgYW5kIHRoZW4gd2UgZXhlY3V0ZSBhZGQoeCx5KQogICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZWRfdG9rZW5zIGZvcm0gbGltaXRlZCB0byBmdW5jdGlvbiBjb250ZXh0CiAgICAgICAgICAgICAgICAgIC8vT3BlcmF0aW5nIG9uIGZ1bmN0aW9uIGFyZ3VtZW50cyBhbmQgc2V0dGluZyB0aGVpciB2YWx1ZXMuIEZvciBlLmcgdGhlIGZ1bmN0aW9uIGFkZCh4LHkpIG1pZ2h0IGJlIGNhbGxlZCBhcyBhZGQoMyw0KQogICAgICAgICAgICAgICAgICAvL3NvIHdlIHNldCB4PTMsIHk9NCBhbmQgc2V0IHNlbGYgdmFyaWFibGUtdmFsdWUgcGFpciBpbiBmdW5jdGlvbkNvbnRleHR1cGRhdGVkX3Rva2VucwoKICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Bcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHBhc3NlZFZhbHVlc1tpbmRleF07CiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoLyIvZywgIiIpOwogICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8nL2csICIiKTsKICAgICAgICAgICAgICAgICAgICBwYXNzZWRWYWx1ZXNbaW5kZXhdID0gdmFsOyAvL2luIHNlbGYgY29kZSB3ZSBhcmUgZmlsdGVyaW5nIG91dCBhcmd1bWVudHMgcGFzc2VkIGJhc2VkIG9uIHdoZXRoZXIgdGhleSBhbHJlYWR5IGV4aXN0IGluIHVwZGF0ZWQgdG9rZW5zIG9yIG5vdAoKICAgICAgICAgICAgICAgICAgICB2YXIgRmluZEluVXBkYXRlZFRva2VucyA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PSB2YWw7CiAgICAgICAgICAgICAgICAgICAgfSk7IC8vRm9yIHBhc3Npbmcgc2FtZSBhcmd1bWVudCBhbmQgc2FtZSB2YWx1ZSB0byBmdW5jdGlvbiAgZS5nIGZ1bmN0aW9uIGZvbyAoZmlib25hY2NpKSBhbmQgZmlib25hY2NpIGlzIGFscmVhZHkgZGVjbGFyZWQgd2l0aCBzb21lIHZhbHVlCgogICAgICAgICAgICAgICAgICAgIGlmIChGaW5kSW5VcGRhdGVkVG9rZW5zID09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsLAogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLAogICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqICsgaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2YWx1ZScsCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdGdW5jdGlvbkV4ZWN1dGlvbkNvbnRleHQnCiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICB9IC8vRm9yIHBhc3NpbmcgZGlmZmVyZW50IGFyZ3VtZW50IGFuZCB2YWx1ZSB0byBmdW5jdGlvbiAgZS5nIGZ1bmN0aW9uIGZvbyAoYXJyKSBhbmQgYXJyIGRvZXNuJ3QgZXhpc3QgYW55d2hlcmUgaW4gdG9rZW5zLgogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsICE9IEZpbmRJblVwZGF0ZWRUb2tlbnMubmFtZSAmJiBGaW5kSW5VcGRhdGVkVG9rZW5zICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNvbnRleHR1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbCwKICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogRmluZEluVXBkYXRlZFRva2Vucy52YWx1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqICsgaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRmluZEluVXBkYXRlZFRva2Vucy50eXBlLAogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdGdW5jdGlvbkV4ZWN1dGlvbkNvbnRleHQnLAogICAgICAgICAgICAgICAgICAgICAgICAgIEludGhlRW5kU2V0VmFsdWV0bzogdmFsCiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWwsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbCwKICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqICsgaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRmluZEluVXBkYXRlZFRva2Vucy50eXBlLAogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdGdW5jdGlvbkV4ZWN1dGlvbkNvbnRleHQnLAogICAgICAgICAgICAgICAgICAgICAgICAgIEludGhlRW5kU2V0VmFsdWV0bzogdmFsCiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9KTsgLy9CdWlsZGluZyBhIGNvbXBsZXRlIHZhcmlhYmxlLXZhbHVlIHBhaXIgZGF0YXNldAoKICAgICAgICAgICAgICAgICAgQ29tcGxldGVUb2tlblZhbHVlTGlzdCA9IFtdLmNvbmNhdCh1cGRhdGVkX3Rva2VucywgX3RvQ29uc3VtYWJsZUFycmF5KGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zKSk7IC8vTm93IHdlIHN0YXJ0IGRpZ2dpbmcgaW50byB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uCgogICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAxOyBfaTQgPCBmdW5jdGlvblNvdXJjZURhdGEubGVuZ3RoOyBfaTQrKykgewogICAgICAgICAgICAgICAgICAgIHZhciBfZWwgPSBmdW5jdGlvblNvdXJjZURhdGFbX2k0XTsgLy9vcGVyYXRpb25zIGxpa2Ug4KSq4KWN4KSw4KS/4KSC4KSfKE1lc3NhZ2UpCiAgICAgICAgICAgICAgICAgICAgLy9QcmludEVuZ2luZSB3aWxsIHRha2UgY2FyZSBvZiBldmVyeSBwcmludCBzdGF0ZW1lbnQgZW5jb3VudGVyZWQgaW4gdGhlIHByb2dyYW0KCiAgICAgICAgICAgICAgICAgICAgaWYgKF9lbC52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykgewogICAgICAgICAgICAgICAgICAgICAgUHJpbnRFbmdpbmUoZnVuY3Rpb25Tb3VyY2VEYXRhLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBfaTQsIHNlbGYpOwogICAgICAgICAgICAgICAgICAgIH0gLy9vcGVyYXRpb25zIGxpa2UgTWVzc2FnZT0nSGVsbG8gV29ybGQnCiAgICAgICAgICAgICAgICAgICAgLy9Bc3NpZ25vclVwZGF0ZVZhbHVlcyBmdW5jdGlvbiB3aWxsIHRha2UgY2FyZSBvZiBldmVyeSBhc3NpZ25tZW50IGVuY291bnRlcmVkIGluIHRoZSBwcm9ncmFtCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX2VsLnZhbHVlID09ICc9JykgewogICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhmdW5jdGlvblNvdXJjZURhdGEsIF9pNCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IsIHNlbGYpOwogICAgICAgICAgICAgICAgICAgICAgfSAvL29wZXJhdGlvbnMgbGlrZSDgpIfgpKjgpKrgpYHgpJ8oTWVzc2FnZSkKICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9lbC50eXBlID09ICdBY2NlcHRJbnB1dCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRJbnB1dGFuZFNldFZhbHVlKGZ1bmN0aW9uU291cmNlRGF0YSwgX2k0LCB1cGRhdGVkX3Rva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9vcGVyYXRpb25zIGxpa2UgeDwyNCwgeSE9NSwgTWVzc2FnZT09J0hlbGxPIFdvcmxkIgogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfZWwudHlwZSA9PSAnY29uZGl0aW9uJykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50NSA9IGZ1bmN0aW9uU291cmNlRGF0YVtfaTRdLnZhbHVlOyAvL3NlbGYgZnVuY3Rpb24gaXMgdGhlIGZpcnN0IHN0ZXAgdG8gY2FsY3VsYXRlIHZhbHVlIG9mICBtdWxpdGlwbGUgY29uZGl0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0dldENvbmRpdGlvblZhbHVlIGlzIG91ciBnb3RvIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIGEgY29uZGl0aW9uIHRvIHRydWUgb3IgZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX0NvbmRpdGlvblZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoX2VsZW1lbnQ1LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBfaTQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGthbGFhbS5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaChfQ29uZGl0aW9uVmFsdWUpOyAvL2lmIHZhbHVlIGlzIGZhbHNlLCBqdXN0IHNraXAgdGhlIGlmIGxvb3AgY29udGV4dCwgaWYgbm90IGl0IHdpbGwgYmUgcmFuIGluIGZpbmFsIHByaW50IG1vZHVsZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfQ29uZGl0aW9uVmFsdWUgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9Jbml0aWFsaXplTG9vcCA9IHRva2Vucy5pbmRleE9mKGZ1bmN0aW9uU291cmNlRGF0YVtfaTRdKTsgLy9IYW5kbGUgQmxvY2tzIGlzIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgY2FyZSBvZiBuZXN0ZWQgYmxvY2sgYnkgdGFraW5nIGNhcmUgb2YgbmVzdGVkIHsgYW5kIH0gYnJhY2tldHMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pdCB1c2VzIHRoZSBzdGFjayB0byBwdXNoIGFuZCBwb3AgYnJhY2tldHMgdG8gYWNjdXJhdGVseSBpZGVudGlmeSBzdGFydCBhbmQgdGhlIGVuZCBvZiB0aGUgYmxvY2sKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX1JldHVybnZhbHVlID0gSGFuZGxlQmxvY2tzKGZ1bmN0aW9uU291cmNlRGF0YSwgX2k0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNCA9IF9SZXR1cm52YWx1ZS5pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9IYW5kbGluZyBzZXQgYXJyYXkgZWxlbWVudCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGUuZyBOdW1iZXJzWzJdPTI4CiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25Tb3VyY2VEYXRhW19pNF0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUoZnVuY3Rpb25Tb3VyY2VEYXRhLCBfaTQsIGosIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvL09wZWFydGluZyBvbiBmb3IgbG9vcCBlbmNvdW50ZXJlZCBpbiBwcm9ncmFtCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmdW5jdGlvblNvdXJjZURhdGFbX2k0XS50eXBlID09ICdGb3JMb29wU3RhcnQnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9nZXRTb3VyY2VkYXRhMiA9IGZ1bmN0aW9uIF9nZXRTb3VyY2VkYXRhMihzdGFydEluZGV4LCBmdW5jdGlvblNvdXJjZURhdGEsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFJldHVybnZhbHVlID0gSGFuZGxlQmxvY2tzKGZ1bmN0aW9uU291cmNlRGF0YSwgc3RhcnRJbmRleCwgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBSZXR1cm52YWx1ZS5TdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGbGFnUHJpbWFsTG9vcCA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2VucyA9IFtdOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX0Zvckxvb3BNZXRhRGF0YSA9IEZvckxvb3BTZXRNZXRhZGF0YShmdW5jdGlvblNvdXJjZURhdGEsIF9pNCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IF9Gb3JMb29wTWV0YURhdGEuRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN5Y2xlID0gX0Zvckxvb3BNZXRhRGF0YS5DeWNsZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcmlnaW5hbEl0ZXJhdG9yID0gX0Zvckxvb3BNZXRhRGF0YS5PcmlnaW5hbEl0ZXJhdG9yOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdGlvblN0YXJ0ID0gX0Zvckxvb3BNZXRhRGF0YS5JdGVyYXRpb25TdGFydDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IF9Gb3JMb29wTWV0YURhdGEuaXRlcmF0b3I7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IF9Gb3JMb29wTWV0YURhdGEuZWxlbWVudDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50VmFsdWUgPSBfRm9yTG9vcE1ldGFEYXRhLmVsZW1lbnRWYWx1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChmdW5jdGlvblNvdXJjZURhdGEsIF9pNCwgJ3snLCBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpOyAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zID0gX2dldFNvdXJjZWRhdGEyKEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgZnVuY3Rpb25Tb3VyY2VEYXRhLCAnfScsIFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmlzTmVzdGVkTG9vcCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX0ZpbmROZXN0ZWRMb29wID0gU291cmNlZGF0YVRva2Vucy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnR5cGUgPT0gJ0Zvckxvb3BTdGFydCc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfRmluZE5lc3RlZExvb3AgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX05lc3RlZExvb3BpbmRleCA9IFNvdXJjZWRhdGFUb2tlbnMuaW5kZXhPZihfRmluZE5lc3RlZExvb3ApICsgMjsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX05lc3RlZExvb3BsZW5ndGggPSBTb3VyY2VkYXRhVG9rZW5zW19OZXN0ZWRMb29waW5kZXhdLkVuZEluZGV4IC0gU291cmNlZGF0YVRva2Vuc1tfTmVzdGVkTG9vcGluZGV4XS5zdGFydEluZGV4ICsgMTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfeCA9IF9OZXN0ZWRMb29waW5kZXg7IF94IDwgX05lc3RlZExvb3BpbmRleCArIF9OZXN0ZWRMb29wbGVuZ3RoOyBfeCsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnNbX3hdLmlzTmVzdGVkTG9vcCA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvL1ByaW1hbCBsb29wIGlzIHRoZSBvbmUgd2hlcmUgdXNlciBnaXZlcyB1cyB0aGUgcmFuZ2UgZGlyZWN0bHkgbGlrZSAoMSwyMCkgZXRjLgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5jbHVkZXMoJygnKSAmJiBlbGVtZW50LmluY2x1ZGVzKCcsJykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZsYWdQcmltYWxMb29wID0gMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vSXRlcmF0aW5nIG92ZXIgZm9ybG9vcCBzb3VyY2VkYXRhCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWxmIGxpbmUgJ2l0ZXJhdG9yIDw9IEN5Y2xlJyBkZXRlcm1pbmVzIHN0YXJ0IG9mIHRoZSBsb29wIGFuZCB0aGUgZHVyYXRpb24gb2YgdGhlIGxvb3AKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaXRlcmF0b3IgPSBJdGVyYXRpb25TdGFydDsgaXRlcmF0b3IgPD0gQ3ljbGU7IGl0ZXJhdG9yKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZm9ybG9vcGluZGV4ID0gQ29tcGxldGVUb2tlblZhbHVlTGlzdC5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PSBPcmlnaW5hbEl0ZXJhdG9yOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Zvcmxvb3BpbmRleC52YWx1ZSA9IGl0ZXJhdG9yOyAvL2ZsYWcgdG8gYXZvaWQgcnVubmluZyBzZWxmIGNvZGUgaWYgbG9vcCBpcyBwcmltYWwgYmVjYXVzZSB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBjb21wZWx0ZWx5IGRpZmZlcmVudAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChGbGFnUHJpbWFsTG9vcCA9IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yTG9vcEFycmF5b3JTdHJpbmdPdXRwdXQoZWxlbWVudFZhbHVlLCBpdGVyYXRvciwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgc2VsZik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pNSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaXNOZXN0ZWQgPSBTb3VyY2VkYXRhVG9rZW5zW19pNV0uaXNOZXN0ZWRMb29wOyAvL1RoaXMgaXMgbmVzdGVkIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Xb3JrcyBidXQgbmVlZHMgaW1wcm92ZW1lbnRzIG9uIHZhcmlvdXMgcGFydHMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ORVNURUQgRk9SIExPT1AgU1RBUlQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pNV0udHlwZSA9PSAnRm9yTG9vcFN0YXJ0JykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZ2V0U291cmNlZGF0YTMgPSBmdW5jdGlvbiBfZ2V0U291cmNlZGF0YTMoc3RhcnRJbmRleCwgU291cmNlZGF0YVRva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdGFydEluZGV4LCBTb3VyY2VkYXRhVG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQ6ICcsIHN0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MoU291cmNlZGF0YVRva2Vucywgc3RhcnRJbmRleCwgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBSZXR1cm52YWx1ZS5TdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRGbGFnUHJpbWFsTG9vcCA9IDA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkU291cmNlZGF0YVRva2VucyA9IFtdOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX05lc3RlZEZvckxvb3BNZXRhRGF0YSA9IEZvckxvb3BTZXRNZXRhZGF0YShTb3VyY2VkYXRhVG9rZW5zLCBfaTUsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBfTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRDeWNsZSA9IF9OZXN0ZWRGb3JMb29wTWV0YURhdGEuQ3ljbGUgKyAxOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IgPSBfTmVzdGVkRm9yTG9vcE1ldGFEYXRhLk9yaWdpbmFsSXRlcmF0b3I7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkSXRlcmF0aW9uU3RhcnQgPSBfTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkl0ZXJhdGlvblN0YXJ0OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZGl0ZXJhdG9yID0gX05lc3RlZEZvckxvb3BNZXRhRGF0YS5JdGVyYXRpb25TdGFydDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRlbGVtZW50ID0gX05lc3RlZEZvckxvb3BNZXRhRGF0YS5lbGVtZW50OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZGVsZW1lbnRWYWx1ZSA9IF9OZXN0ZWRGb3JMb29wTWV0YURhdGEuZWxlbWVudFZhbHVlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KFNvdXJjZWRhdGFUb2tlbnMsIF9pNSwgJ3snLCBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMgPSBfZ2V0U291cmNlZGF0YTMoTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBTb3VyY2VkYXRhVG9rZW5zLCAnfScsIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMpOyAvL2NvbnNvbGUubG9nKCdOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zOiAnLCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChOZXN0ZWRpdGVyYXRvcjsgTmVzdGVkaXRlcmF0b3IgPCBOZXN0ZWRDeWNsZTsgTmVzdGVkaXRlcmF0b3IrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3kgPSBOZXN0ZWRpdGVyYXRvcjsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfTmVzdGVkZm9ybG9vcGluZGV4ID0gQ29tcGxldGVUb2tlblZhbHVlTGlzdC5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uYW1lID09IE5lc3RlZE9yaWdpbmFsSXRlcmF0b3I7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyAvL2NvbnNvbGUubG9nKCdmb3Jsb29waW5kZXg6ICcsIGZvcmxvb3BpbmRleCk7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX05lc3RlZGZvcmxvb3BpbmRleC52YWx1ZSA9IF95OwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2luZGV4ID0gMDsgX2luZGV4IDwgTmVzdGVkU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pbmRleCsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lbDIgPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW19pbmRleF07CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZWwyLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmludEVuZ2luZShOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBfaW5kZXgsIHNlbGYsIF95LCBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9lbDIudmFsdWUgPT0gJz0nICYmIF9lbDIuaXNOZXN0ZWRMb29wID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXNzaWduaW5nIHZhbHVlcyB0byB2YXJpYWJsZXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsIF9pbmRleCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgX3ksIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IsIHNlbGYpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2VsMi50eXBlID09ICdjb25kaXRpb24nICYmIF9lbDIuaXNOZXN0ZWRMb29wID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnNbaV06ICcsIFNvdXJjZWRhdGFUb2tlbnNbaV0saSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX0NvbmRpdGlvblN0YXJ0SW5kZXgyID0gX2luZGV4OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb25kaXRpb24yID0gTmVzdGVkU291cmNlZGF0YVRva2Vuc1tfaW5kZXhdLnZhbHVlOyAvL0hhbmRsZUNvbmRpdGlvbnMgZXZhbHVhdGVzIGNvbmRpdGlvbiBhbmQgcmV0dXJuIHRoZSBpbmRleCBvZiBmcm9tIHdoZXJlIHByaW50aW5nIHNob3VsZCByZXN1bWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb2YgaSBkZXBlbmRzIG9uIHRoZSBjb25kaXRpb25zCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb25kaXRpb24yLmluY2x1ZGVzKCd8fCcpIHx8IF9jb25kaXRpb24yLmluY2x1ZGVzKCcmJicpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdmFsdWUyID0gR2V0Q29uZGl0aW9uVmFsdWUoX2NvbmRpdGlvbjIsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIF9pbmRleCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrYWxhYW0uTGFzdENvbmRpdGlvblZhbHVlLnB1c2goX3ZhbHVlMik7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3ZhbHVlMiA9PSBmYWxzZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfQmxvY2tMZW5ndGggPSAwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfQmxvY2tTdGFydCA9IDA7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW19pbmRleF0udmFsdWUgIT0gJ3snKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVzdGVkU291cmNlZGF0YVRva2Vuc1tfaW5kZXggKyAxXS52YWx1ZSA9PSAneycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX0Jsb2NrTGVuZ3RoID0gTmVzdGVkU291cmNlZGF0YVRva2Vuc1tfaW5kZXggKyAxXS5FbmRJbmRleCAtIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbX2luZGV4ICsgMV0uc3RhcnRJbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2luZGV4ID0gX0Jsb2NrTGVuZ3RoICsgX2luZGV4ICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2luZGV4Kys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pbmRleCA9IF9pbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF94MiA9IEhhbmRsZUNvbmRpdGlvbnMoTmVzdGVkU291cmNlZGF0YVRva2VucywgX2luZGV4LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfeDIgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2luZGV4ID0gX3gyOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pbmRleCA9IF9Db25kaXRpb25TdGFydEluZGV4MjsgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vY29uc29sZS5sb2coJ2k6ICcsIGkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGkgPSBpICsgTmVzdGVkU291cmNlZGF0YVRva2Vucy5sZW5ndGgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpOiAnLCBpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfZWwyLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIgJiYgX2VsMi5pc05lc3RlZExvb3AgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUoTmVzdGVkU291cmNlZGF0YVRva2VucywgX2k1LCBqLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCB0b2tlbnMsIE9yaWdpbmFsSXRlcmF0b3IsIGl0ZXJhdG9yKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pNV0udHlwZSA9PSAnQWNjZXB0SW5wdXQnICYmIF9pc05lc3RlZCA9PSBmYWxzZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdElucHV0YW5kU2V0VmFsdWUoU291cmNlZGF0YVRva2VucywgX2k1LCB1cGRhdGVkX3Rva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTVdLnZhbHVlID09ICc9JyAmJiBfaXNOZXN0ZWQgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoU291cmNlZGF0YVRva2VucywgX2k1LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvciwgc2VsZik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9IYW5kbGluZyBwcmludCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2k1XS52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJyAmJiBfaXNOZXN0ZWQgPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIG9wZXJhdGlvbnMgbGlrZSBwcmludChhcnJheVszXSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmb3IgbG9vb3AgcHJpbnRzOiAnLCBmdW5jdGlvblNvdXJjZURhdGFbaV0saSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmludEVuZ2luZShTb3VyY2VkYXRhVG9rZW5zLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBfaTUsIHNlbGYsIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yKTsgLy8KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vSGFuZGxpbmcgc2V0IGFycmF5IGVsZW1lbnQgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2k1XS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5SW5kZXhWYWx1ZShTb3VyY2VkYXRhVG9rZW5zLCBfaTUsIGosIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pNV0udHlwZSA9PSAnY29uZGl0aW9uJykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnNbaV06ICcsIFNvdXJjZWRhdGFUb2tlbnNbaV0saSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9Db25kaXRpb25TdGFydEluZGV4MyA9IF9pNTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbmRpdGlvbjMgPSBTb3VyY2VkYXRhVG9rZW5zW19pNV0udmFsdWU7IC8vSGFuZGxlQ29uZGl0aW9ucyBldmFsdWF0ZXMgY29uZGl0aW9uIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mIGZyb20gd2hlcmUgcHJpbnRpbmcgc2hvdWxkIHJlc3VtZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb2YgaSBkZXBlbmRzIG9uIHRoZSBjb25kaXRpb25zCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY29uZGl0aW9uMy5pbmNsdWRlcygnfHwnKSB8fCBfY29uZGl0aW9uMy5pbmNsdWRlcygnJiYnKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF92YWx1ZTMgPSBHZXRDb25kaXRpb25WYWx1ZShfY29uZGl0aW9uMywgdXBkYXRlZF90b2tlbnMsIF9pNSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2FsYWFtLkxhc3RDb25kaXRpb25WYWx1ZS5wdXNoKF92YWx1ZTMpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdmFsdWUzID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfQmxvY2tMZW5ndGgyID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9CbG9ja1N0YXJ0MiA9IDA7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoU291cmNlZGF0YVRva2Vuc1tfaTVdLnZhbHVlICE9ICd7JykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW19pNSArIDFdLnZhbHVlID09ICd7JykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX0Jsb2NrTGVuZ3RoMiA9IFNvdXJjZWRhdGFUb2tlbnNbX2k1ICsgMV0uRW5kSW5kZXggLSBTb3VyY2VkYXRhVG9rZW5zW19pNSArIDFdLnN0YXJ0SW5kZXg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTUgPSBfQmxvY2tMZW5ndGgyICsgX2k1ICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2k1Kys7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNSA9IF9pNTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2k1ID0gSGFuZGxlQ29uZGl0aW9ucyhTb3VyY2VkYXRhVG9rZW5zLCBfaTUsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTUgIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNSA9IF9pNTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNSA9IF9Db25kaXRpb25TdGFydEluZGV4MzsgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTQgPSBfaTQgKyBTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgLy9FTkQgTkVTVEVEIEZPUiBMT09QCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25Tb3VyY2VEYXRhW19pNF0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5SW5kZXhWYWx1ZShTb3VyY2VkYXRhVG9rZW5zLCBfaTQsIGosIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIHRva2VucywgT3JpZ2luYWxJdGVyYXRvciwgaXRlcmF0b3IpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vSGFuZGxpbmcgV2hpbGUgbG9vcCBpbiBmdW5jdGlvbgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmdW5jdGlvblNvdXJjZURhdGFbX2k0XS50eXBlID09ICdXaGlsZUxvb3BTdGFydCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhID0gZnVuY3Rpb24gZ2V0V2hpbGVMb29wU291cmNlZGF0YShzdGFydEluZGV4LCBmdW5jdGlvblNvdXJjZURhdGEsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gSGFuZGxlQmxvY2tzKGZ1bmN0aW9uU291cmNlRGF0YSwgc3RhcnRJbmRleCwgU3RvcmVSZXN1bHQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUb2tlbnNDdXJyZW50SW5kZXggPSBfaTQgKyAzOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ29uZGl0aW9uVmFsdWUgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBmdW5jdGlvblNvdXJjZURhdGFbX2k0ICsgMV0udmFsdWU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBFeHRyYXRjZWRWYXJpYWJsZSA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSAnJzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMgPSBbXTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGVsZW1lbnQubGVuZ3RoOyBfaTYrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfeDMgPSBlbGVtZW50LmNoYXJBdChfaTYpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShfeDMpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlICsgX3gzOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhcmlhYmxlKGVsZW1lbnQuY2hhckF0KF9pNiArIDEpKSAmJiBpc1ZhcmlhYmxlKF94MykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdG9rZW40ID0gQ29tcGxldGVUb2tlblZhbHVlTGlzdC5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PSB2YXJpYWJsZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4dHJhdGNlZFZhcmlhYmxlLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZTogdmFyaWFibGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdG9rZW40LnZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gJyc7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KGZ1bmN0aW9uU291cmNlRGF0YSwgX2k0LCAneycsIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBmdW5jdGlvblNvdXJjZURhdGEsICd9JywgV2hpbGVMb29wU291cmNlZGF0YVRva2VucykuU3RvcmVSZXN1bHQ7IC8vY29uc3RhbnRseSBldmFsdWF0aW5nIHRoZSBjb25kaXRpb252YWx1ZS4gZm9yIGUuZyBjb3VudDwyNSBpbiDgpJzgpKzgpKTgpJUoY291bnQ8MjUpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoR2V0Q29uZGl0aW9uVmFsdWUoZWxlbWVudCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaiArIDEpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgV2hpbGVMb29wU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pNysrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NFQ1RJT04gd2hpbGUgbG9vcCBjb250ZXh0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTddLnZhbHVlID09ICc9JykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTcsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpOyAvLwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTddLnR5cGUgPT0gJ0FjY2VwdElucHV0JykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHRJbnB1dGFuZFNldFZhbHVlKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pNywgdXBkYXRlZF90b2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW19pN10udHlwZSA9PSAnY29uZGl0aW9uJykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaW5kZXgyID0gSGFuZGxlQ29uZGl0aW9ucyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTcsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2luZGV4MiAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNyA9IF9pbmRleDI7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNyA9IF9pNzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTddLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJpbnRFbmdpbmUoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgX2k3LCBzZWxmKTsgLy9mb3Igb3BlcmF0aW9ucyBsaWtlIHByaW50KGFycmF5WzNdKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2k3XS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIF9pNywgaiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgdG9rZW5zLCBPcmlnaW5hbEl0ZXJhdG9yLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pNCA9IF9pNCArIDEgKyBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aCArIDE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSAvL3NraXBwaW5nIHBhcnNpbmcgaW5kZXggc28gdGhhdCBmdW5jdGlvbiBjb250ZXh0IGlzIHJ1biBieSBzaW5nbGUgZW50aXR5IGFuZCBnbG9iYWwgZXhlY3V0aW9uIGRvZXNuJ3QgcnVuIHNlbGYgY29kZSB0b28KICAgICAgICAgICAgICAgICAgLy8gIGogPSBtdXRhYmxlX3Rva2Vuc1tqICsgMV0uRW5kSW5kZXgKICAgICAgICAgICAgICAgICAgLy9JZiB3ZSBwYXNzIGZ1bmN0aW9uIGZvbyhhcnIpIHdoZXJlIGFyciBpcyAoc3VwcG9zZSkgZmlib25hY2NpPVtdIGRlY2xhcmVkIGluIHRoZSBnbG9iYWwgZXhlIGNvbnRleHQodXBkYXRlZF90b2tlbnMpLiBCdXQgb3BlcmF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkIG9uCiAgICAgICAgICAgICAgICAgIC8vYXJyIGluIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zLiBzbyBhdCB0aGUgZW5kIG9mIGZ1Y250aW9uIGV4ZWN1dGlvbiB3ZSBzZXQgdGhlIHZhbHVlIHRvIGl0J3MgcmlnaHQgb3duZXIuCgoKICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuSW50aGVFbmRTZXRWYWx1ZXRvICE9ICcnOwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgdmFyIEdpdmVQb3dlcnNUbyA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT0gdG9rZW4uSW50aGVFbmRTZXRWYWx1ZXRvOwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgR2l2ZVBvd2Vyc1RvLnZhbHVlID0gdG9rZW4udmFsdWU7IC8vSSBoYXZlIHRvIGVtcHR5IGl0IGJlY2F1c2UgZnVuY3Rpb24gY29udGV4dCBoYXMgdG8gcmVtYWluIGVtcHR5IG90aGVyIHdpc2UgZnVuY3Rpb24gYXJndW1lbnRzIHdpbGwga2VlcCBvbiBhY2NlcHRpbmcgbmV3IHZhbHVlcyB3aXRoIHRoZSBzYW1lIGtleQogICAgICAgICAgICAgICAgICAvL2ZvciBlLmc9IFByaW50RnVsbE5hbWUoRmlyc3ROYW1lLExhc3ROYW1lKSBhbmQgUHJpbnRGdWxsTmFtZShGaXJzdE5hbSxMYXN0TmFtKSBuZWVkcyB0d28gZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0IGhlbmNlIGZpcnN0IG9uZSBuZWVkcyB0byBtYWtlIHNwYWNlIGZvciBsYXRlcgoKICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMgPSBbXTsKICAgICAgICAgICAgICAgIH0pKCk7CiAgICAgICAgICAgICAgfQogIH0gLy9UaGlzIGlzIHdoZXJlIGVycm9yIGhhbmRsaW5nIGtpY2tzIGluCiAgLy9UbyBmaW5kIHVuZGVmaW5lZCB2YXJpYWJsZXMKCgogIGZ1bmN0aW9uIG9ubHlVbmlxdWUodmFsdWUsIGluZGV4LCBhcnIpIHsKICAgIHJldHVybiBhcnIuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4OwogIH0KCiAgdmFyIGFzc2lnbmVkX3ZhcmlhYmxlcyA9IGFzc2lnbmVkX3ZhcmlhYmxlcy5maWx0ZXIob25seVVuaXF1ZSk7CiAgdmFyIGRpZmZlcmVuY2UgPSB2YXJpYWJsZXNfYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7CiAgICByZXR1cm4gIWFzc2lnbmVkX3ZhcmlhYmxlcy5pbmNsdWRlcyh4KTsKICB9KTsKCiAgaWYgKGRpZmZlcmVuY2UubGVuZ3RoID4gMCkgewogICAgZGlmZmVyZW5jZS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgewogICAgICBrYWxhYW0uZXJyb3IucHVzaCgnVmFyaWFibGUgJyArIGVsICsgJyBpcyB1bmRlZmluZWQgJyk7CiAgICB9KTsKICB9CgogIGlmIChrYWxhYW0uZXJyb3IubGVuZ3RoID4gMCkgewogICAga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQgPSBrYWxhYW0uZXJyb3I7CiAgfSBlbHNlIHsKICAgIGthbGFhbS5saW5lYnlsaW5lT3V0cHV0ID0ga2FsYWFtLm91dHB1dC5zcGxpdCgnXG4nKTsKICB9IC8vdGltZSB0YWtlbiB0byB0cmFuc3BpbGUgdGhlIGNvZGUgaXMgdDEtdDAKCgogIHZhciB0MSA9IHBlcmZvcm1hbmNlLm5vdygpOwoKICBpZiAoa2FsYWFtLmxpbmVieWxpbmVPdXRwdXQgIT0gJycgJiYga2FsYWFtLmVycm9yLmxlbmd0aCA9PSAwKSB7CiAgICBrYWxhYW0uVGltZVRha2VuID0gIkNvbXBpbGVkIFN1Y2Nlc2Z1bGx5IGluICIgKyAodDEgLSB0MCkudG9QcmVjaXNpb24oNCkgKyAibXMuIjsKICB9IGVsc2UgewogICAga2FsYWFtLmlzRXJyb3IgPSB0cnVlOwogICAga2FsYWFtLlRpbWVUYWtlbiA9ICJDb21waWxhdGlvbiBFcnJvcjogQ2hlY2sgZm9yIGFzc2lnbmVtZW50IGFuZCBkZWNsYXJhdGlvbiBtaXN0eXBpbmciOwogIH0gLy9rYWxhYW0ubGluZWJ5bGluZW91dHB1dCBpcyB3aGF0IHlvdSB3aWxsIGZpbmFsbHkgc2VlIG9uIG91dHB1dCBzY3JlZW4KCgogIGthbGFhbS5saW5lYnlsaW5lT3V0cHV0ID0ga2FsYWFtLmxpbmVieWxpbmVPdXRwdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7CiAgICByZXR1cm4gaXRlbSAhPT0gIiI7CiAgfSk7Cn0="},{"version":3,"sources":["/Users/jonny/Documents/Work/test/src/lib/Compiler/main.js"],"names":["TypeCheck","AdvancedTypeCheck","BuildOperation","PushArray","PushCalculation","PushConditionalKeyword","PushCondition","PushForLoop","PushWhileLoop","PushWhileLoopCondition","PushForLoopAruguments","PushExpression","PushKeyword","PushNumber","PushOperator","PushRealTimePrintOperation","PushString","PushStringandValueOperation","PushVariable","PushVariableValue","PushFunctionData","PushFunctionExecution","PushToArray","PushInput","GetCleanSourcedata","RemoveBrackets","Count","AddElementToArray","ResetValue","isArrayOperation","CreateArrayElement","CalculateValues","GetArrayorStringElement","SetArrayorStringElement","handlemultConditions","HandleBlocks","SplitElementsArray","SetValues","PushSetArrayIndexValue","PushGetArrayIndexValue","UpdateUpdated_tokenswithValues","GetConditionValue","AcceptInputandSetValue","ForLoopArrayorStringOutput","AssignorUpdateValues","HandleConditions","getLoopIndexStart","ForLoopSetMetadata","SetArrayIndexValue","Compile","kalaam","t0","performance","now","isError","output","linebylineOutput","split","error","OperationObjects","sourcedata","code","cleaned_sourcedata","i","tokens","mixedimpurity","updated_tokens","functionContextupdated_tokens","variables_array","assigned_variables","terms","terms2","operation","CalculationStack","foundToken","ReIntializedVariables","variableArray","isVariable","isNumber","isOperator","isKeyword","isConditionalKeyword","isForLoop","isWhileLoop","isFunction","isExpression","isArray","isInput","isSetArrayIndexValue","isString","isEmptyStringorChar","isPureEval","isRealTimePrintMultipleString","isStringandValue","isCalculation","isDirectPrintArithmetic","BuildString","BuildArray","BuildCondition","PrintEngine","Tokens","j","global","iterator","OriginalIterator","token","value","NextTokenValue","StringVar","VariableToPrint","includes","push","forEach","el","name","AddOutput","outputpure","eval","type","toString","undefined","IndexInput","Value","ArrayElement","IndexToChange","element","replace","Split","join","find","a","mode","x","Parse","string","index","indexOf","length","charAt","BuiltArray","foundcondition","CleanedElement","foundString","k","conditionEnd","flag","calculatedString","test","slice","CheckFunctionExpression","passedValues","filter","console","log","mutable_tokens","tokenType","VarWithoutbrackets","self","result","StartofBlock","startIndex","EndofBlock","EndIndex","lastValue","LastConditionValue","pop","functionSourceData","StoreResult","context","SourceData","ConditionValue","InitializeLoop","Returnvalue","getWhileLoopSourcedata","check","TokensCurrentIndex","ExtratcedVariable","variable","WhileLoopSourcedataIndexStart","WhileLoopSourcedataTokens","getSourcedata","FlagPrimalLoop","SourcedataTokens","ForLoopMetaData","ForLoopSourcedataIndexStart","Cycle","IterationStart","elementValue","isNestedLoop","FindNestedLoop","NestedLoopindex","NestedLooplength","forloopindex","isNested","NestedFlagPrimalLoop","NestedSourcedataTokens","NestedForLoopMetaData","NestedForLoopSourcedataIndexStart","NestedCycle","NestedOriginalIterator","NestedIterationStart","Nestediterator","Nestedelement","NestedelementValue","y","Nestedforloopindex","ConditionStartIndex","condition","BlockLength","BlockStart","CompleteTokenValueList","functionName","functionToken","functionArguments","arguments","val","FindInUpdatedTokens","identifier","IntheEndSetValueto","GivePowersTo","onlyUnique","arr","difference","t1","TimeTaken","toPrecision","item"],"mappings":"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","sourcesContent":["  \n/*!\n * Kalaam v1.0.0\n * (C) 2020 Swanand Kadam\n * Released under the MIT License.\n */\n\n\n //SECTION - Importing function modules\n\n\n//To check variable types: Number, String, Array etc.\nimport * as TypeCheck from '../TypeCheck/TypeChecking'\n\n//To check other operations like MultiString, Arithmetic Operation etc.\nimport * as AdvancedTypeCheck from '../TypeCheck/AdvancedTypeChecking'\n\n//To format user input into a proper String, Array or Condition. \nimport * as BuildOperation from '../Scripts/BuildOperations'\n\n//Functions imported to push a particular data to our Tokens array. \n//Tokens array is basically a clean, formatted and a word by word version of raw code provided by user\nimport\n{\n  PushArray,\n  PushCalculation,\n  PushConditionalKeyword,\n  PushCondition,\n  PushForLoop,\n  PushWhileLoop,\n  PushWhileLoopCondition,\n  PushForLoopAruguments,\n  PushExpression,\n  PushKeyword,\n  PushNumber,\n  PushOperator,\n  PushRealTimePrintOperation,\n  PushString,\n  PushStringandValueOperation,\n  PushVariable,\n  PushVariableValue,\n  PushFunctionData,\n  PushFunctionExecution,\n  PushToArray,\n  PushInput\n\n}\nfrom '../PushTokens/main'\n\n//This are other helper functions that we need for a particular task. All of this functions will be explained indepth as we see them in codebase.\nimport\n{\n  GetCleanSourcedata,\n  RemoveBrackets,\n  Count,\n  AddElementToArray,\n  ResetValue,\n  isArrayOperation,\n  CreateArrayElement,\n  CalculateValues,\n  GetArrayorStringElement,\n  SetArrayorStringElement,\n  handlemultConditions,\n  HandleBlocks,\n  SplitElementsArray,\n  SetValues,\n  PushSetArrayIndexValue,\n  PushGetArrayIndexValue,\n  UpdateUpdated_tokenswithValues,\n  GetConditionValue,\n  AcceptInputandSetValue,\n  ForLoopArrayorStringOutput,\n  AssignorUpdateValues,\n  HandleConditions,\n  getLoopIndexStart,\n  ForLoopSetMetadata,\n  SetArrayIndexValue\n}\nfrom '../Scripts/main.js'\n\n  \n//We will be importing this whole function to practise.vue and it will be executed when user clicks on 'RUN'\n\n  export default function Compile(kalaam){\n\n\n\n //'kalaam' is our global object and access it's value as 'this.$data' from practise.vue located in views\n//All the input sourcecode, tokens, output, error handling etc is stored in kalaam object\n\n\n\n  //t0 along with t1 takes record of Time taken to run the code. t1-t0 gives us the exact time taken.\n  var t0 = performance.now()\n\n  //If an error is encountered we set the value to true and push the error to errors array.\n  kalaam.isError = false\n\n  //to stop accumulating output on succesive RUN. \n  kalaam.output = ''\n\n  //kalaam.input = '',\n  kalaam.linebylineOutput = kalaam.output.split(\"\\n\")\n  //kalaam.inputIndexes = []\n  kalaam.error = []\n  kalaam.OperationObjects = []\n\n  //Sourcedata is the raw code provided by use\n  var sourcedata = kalaam.code;\n  \n\n  //This is where formatted and cleaned sourcedata will go.\n  var cleaned_sourcedata = []\n  var i = 0;\n  //This is where tokens will be pushed depending upon their types like Variable, function, loops etc.\n  var tokens = [];\n\n  //Experimental\n  var mixedimpurity = []\n\n  //The variables with their calculated values are pushed here. If c=a+b, updated_tokens is where you will find the calculated value\n  var updated_tokens = []\n\n  //Variable-value pairs similar to updated_tokens but limits itself to a user created function.\n  var functionContextupdated_tokens = []\n\n  var variables_array = []\n\n  //Pushing the variables that are assigned to filter out defined and undefined variables. Useful in error handling\n  var assigned_variables = []\n  var terms = []\n  var terms2 = []\n  var operation = ''\n  var CalculationStack = []\n  var foundToken = ''\n  var ReIntializedVariables = []\n\n  //TO REMOVE DUPLICATE VARIABLES, \n\n  let variableArray = []\n  //A temporary instance of a global variable. Used because of scoping issue, there are better soultions and we will do that.\n\n  //emptying accumulated value \n  //See AssignorUpdateValues function for more\n  ResetValue()\n\n  //SECTION - Checking for type of characters. TypeCheck is an object which consists all self functions. Check Line 102\n\n  const isVariable = TypeCheck.isVariable()\n  \n  const isNumber = TypeCheck.isNumber()\n\n  const isOperator = TypeCheck.isOperator()\n\n  const isKeyword = TypeCheck.isKeyword()\n  const isConditionalKeyword = TypeCheck.isConditionalKeyword()\n  const isForLoop = TypeCheck.isForLoop()\n  const isWhileLoop = TypeCheck.isWhileLoop()\n  const isFunction = TypeCheck.isFunction()\n\n  //needs work\n  const isExpression = TypeCheck.isExpression()\n\n  const isArray = TypeCheck.isArray()\n  const isInput = TypeCheck.isInput()\n\n  const isSetArrayIndexValue = TypeCheck.isSetArrayIndexValue()\n\n  // const isEmptyArrayInit = TypeCheck.isEmptyArrayInit()\n\n  const isString = TypeCheck.isString()\n  const isEmptyStringorChar = TypeCheck.isEmptyStringorChar()\n\n  const isPureEval = AdvancedTypeCheck.isPureEval()\n\n  //if parser encounters anything like (\" or (, then that's a realtime print. \n\n  //buildstring will be applied now to create a string and push it into tokens. Buildstring is used to combine string tokens like \n  //['hello', 'Kalaam', 'developers', \"!\"] into 'hello kalaam developers!'.\n\n  //It's because cleaned_sourcedata is an array of tokens and each token is an individual word in a program.\n\n  //It's recommended to look at cleaned_sourcedata of every program to understand how it converts plain text into array of individual words.\n\n  const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString()\n\n  const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n  const isCalculation = AdvancedTypeCheck.isCalculation()\n\n  const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n  //SECTION Build Operations \n\n  //To convert ['hello', 'Kalaam', 'developers', \"!\"] into 'hello kalaam developers!'.\n\n  const BuildString = BuildOperation.BuildString()\n\n  //To convert ['[', 'x','y','z',']'] into ['x','y','z']\n\n  const BuildArray = BuildOperation.BuildArray()\n\n  //self function is the first step to handlle operations like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n  const BuildCondition = BuildOperation.BuildCondition()\n\n  //This will run for every () statement encountered in the program, not just for loops\n\n  //ARGUMENTS TO PrintEngine are:\n  //Tokens- Tokens array \n  //updated_tokens- Variable-value pairs of variables\n  //j- Index of a token in Tokens array\n  //global- self or self\n  //iterator and OriginalIterator are used to print values in for and while loops.\n\n  function PrintEngine(Tokens, updated_tokens, j, global, iterator, OriginalIterator)\n\n  {\n\n    //Try console.log('Tokens, updated_tokens, j, global, iterator, OriginalIterator): ', Tokens, updated_tokens, j, global, iterator, OriginalIterator)); \n    //To understand what kind of data is necessary to print a value \n\n    //Getting the current token as token and value to be printed as NextTokenValue\n    //e.g. For (Name), Name is the NextTokenValue and it is the one which we will have to print\n\n    var token = Tokens[j].value\n\n    var NextTokenValue = Tokens[j + 1].value\n\n    var StringVar = []\n\n    //Removing the brackets, if any. \n    var VariableToPrint = RemoveBrackets(NextTokenValue)\n\n    //Adding the variable to variables_array\n\n    if (isVariable(VariableToPrint) && !variables_array.includes(VariableToPrint))\n    {\n\n      variables_array.push(VariableToPrint)\n      // \n\n    }\n\n    //SECTION - Outputting the code\n    // finding the variable value in updated_tokens. Updated_tokens is where our Variable-value pairs exists.\n    //Try console.log(updated_tokens) to see how it looks\n\n    //This loop is only for printing direct values like print(name), print(array)\n    updated_tokens.forEach((el, i) =>\n    {\n\n      //If we have a variable-value pair sitting in updated_tokens\n\n      if (el.name == VariableToPrint)\n      {\n\n        //for calculations like x=ageone+agetwo\n\n        //If we have already calculated value in assigned_variables, use that or else move forward\n\n        if (assigned_variables.includes(el) || assigned_variables.includes(el.name))\n        {\n\n          AddOutput( el.value)\n\n        }\n        else\n        {\n\n          //if the value found is a Number\n\n          if (isNumber(el.value))\n          {\n\n            AddOutput( el.value)\n\n            assigned_variables.push(el.name);\n\n          }\n\n          //if the value found is operations like age=2020-1996\n          else if (isPureEval(el.value))\n          {\n\n            //we are using Javascript's eval function to calculate direct arithmetic operations \n            let outputpure = eval(el.value)\n\n            el.value = outputpure\n\n            AddOutput( el.value)\n\n            assigned_variables.push(el.name);\n\n          }\n\n          //We will simplify self conditions as we move forward\n          else if (!isPureEval(el.value) && !isNumber(el.value))\n\n          {\n\n            if (!(el.name.includes(']') && el.name.includes('[')))\n            {\n\n              if (el.type == 'Array')\n              {\n\n                if (el.value.includes('[') == false)\n\n                {\n\n                  el.value = '[' + el.value.toString() + ']'\n\n                }\n\n              }\n\n              AddOutput( el.value)\n\n              assigned_variables.push(el.name);\n            }\n\n          }\n\n        }\n\n      }\n\n    })\n\n    //This is how we print Array in Kalaam\n    if (Tokens[j + 1].type == 'Array')\n\n    {\n\n      //To run only if iterator is present\n\n      //This runs on for loop - (Array[a]) etc\n\n      //self runs only if for(i) and in the loop, array[i], not on array[x]. For loop Iterator and index should be same, in self case 'i'\n\n      if (iterator != undefined && Tokens[j + 1].IndexInput == OriginalIterator)\n\n      {\n\n        let Value = NextTokenValue\n\n        let ArrayElement = CreateArrayElement(Value, iterator)\n\n        let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n        AddOutput( output)\n\n        assigned_variables.push(Tokens[j + 1]);\n\n      }\n\n      //This runs to Print(Array[2]) like specific array values\n      else if (Tokens[j + 1].IndexInput != OriginalIterator)\n\n      {\n\n        let Value = NextTokenValue\n\n        let IndexToChange = Tokens[j + 1].IndexInput\n\n        let ArrayElement = CreateArrayElement(Value, IndexToChange)\n\n        let element = ArrayElement.replace(']', '')\n\n        let Split = element.split('[')\n\n        if (Split[1].includes('-') || Split[1].includes('+'))\n        {\n\n          let output = CalculateValues(Split[1], j, updated_tokens)\n\n          Split[1] = output\n\n          Split = Split.join('[') + ']'\n          ArrayElement = Split\n\n        }\n\n        let token = updated_tokens.find(el => el.name == Split[1])\n\n        if (token != undefined && OriginalIterator != Split[1])\n        {\n\n          Split[1] = token.value\n\n          Split = Split.join('[') + ']'\n          ArrayElement = Split\n\n        }\n        else\n        {\n\n          ArrayElement = ArrayElement\n          //console.log('ArrayElement: ', ArrayElement);\n\n        }\n\n        let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n        AddOutput( output)\n\n      }\n\n    }\n\n    //printing direct numbers and direct calcultions like print(10), print(10*10)\n    else if (token == '' && (isPureEval(RemoveBrackets(NextTokenValue)) || isNumber(RemoveBrackets(NextTokenValue))))\n    {\n\n      NextTokenValue = RemoveBrackets(NextTokenValue)\n\n      if (isNumber(NextTokenValue) && Tokens[j + 1].type != 'Calculation')\n\n      {\n\n        AddOutput( NextTokenValue)\n\n      }\n      else\n      {\n\n        let a = eval(NextTokenValue)\n\n        AddOutput( a)\n\n      }\n\n    }\n\n    //foroperations like print('you live, you learn')\n    else if (Tokens[j + 1].mode == \"RealTimePrint\" && !NextTokenValue.includes('+') && !NextTokenValue.includes('='))\n\n    {\n\n      let output = RemoveBrackets(NextTokenValue)\n\n      output = output.replace(/\"/g, '');\n      output = output.replace(/'/g, '');\n\n      AddOutput( output + \"\\n\")\n\n    }\n\n    //operations like print(Age + 'is young age') i.e string concatenations\n    else if (Tokens[j + 1].mode == \"RealTimePrint\" && NextTokenValue.includes('+'))\n    {\n\n      let x = SplitElementsArray(NextTokenValue)\n\n      StringVar = SetValues(x, updated_tokens)\n\n      StringVar = StringVar.join('')\n      StringVar = StringVar.split(\"+\")\n\n      let output = StringVar.join(' ')\n      output = RemoveBrackets(output)\n\n      AddOutput( output + \"\\n\")\n\n    }\n    else if (isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != \"RealTimePrint\")\n\n    {\n\n      NextTokenValue = RemoveBrackets(NextTokenValue)\n\n      let output = CalculateValues(NextTokenValue, j, updated_tokens)\n\n      AddOutput( output + \"\\n\")\n\n    }\n\n  }\n\n  //END OF Functions and Imported Functions\n\n  //Out of all self function, PrintEngine is very important function. It prints variable values by searching their value in updated_tokens.\n\n  //SECTION - Checking each token and adding to tokens array\n\n  //Parse takes two arguments. The cleaned_sourcedata array and current index of cleaned_sourcedata array\n\n  //Parse is used to create a tokens array with each token having it's name, value, type and other metadata\n\n  //It performs operations depending upon whether the element is variable, array, function, loop etc.\n\n  function Parse(cleaned_sourcedata, i)\n  {\n\n    var element = cleaned_sourcedata[i];\n\n    var string = []\n\n    //Push variables to tokens\n    //Format: {type: \"variable\", value: \"ReverseString\"}\n\n    if (isVariable(element) == true)\n    {\n\n      //Here we seperate Message = 'Hello' into following three tokens :\n\n      //1:{type:\"variable\",value:\"Message\"} \n\n      //2:{type:\"operator\",value:\"=\"}\n\n      //3:{type:\"value\",value:\"Hello\"}\n\n      if (cleaned_sourcedata[i + 1] == '=')\n      {\n\n        PushVariable(element, tokens)\n\n        //If we already have the variable declared before, push it to ReIntializedVariables array\n\n        if (variableArray.includes(element))\n        {\n\n          let x = tokens.find(el => el.value == element)\n\n          let index = tokens.indexOf(x)\n\n          ReIntializedVariables.push(\n          {\n            name: element\n          })\n\n          //\n\n          //tokens[index+2].value= cleaned_sourcedata[i+2]\n\n        }\n\n        variableArray.push(element)\n\n      }\n      else if (cleaned_sourcedata[i - 1] == '=')\n      {\n\n        PushVariableValue(element, tokens)\n\n      }\n\n      //Push variables to tokens\n\n    }\n    else if (isNumber(element) == true)\n    {\n\n      PushNumber(element, tokens)\n\n      //Push EmptyStrings to tokens\n\n    }\n    else if (isEmptyStringorChar(element) == true)\n    {\n\n      //In some cases empty strings will be modified into something like \"'\" or '\"'\n      //We convert it back to \" \"\n      if (element.length > 1 && (element.charAt(0) == \"'\" || element.charAt(0) == '\"'))\n      {\n\n        element = element.replace(/['\"]+/g, '')\n\n      }\n      else\n      {\n\n        element = \" \"\n      }\n\n      PushVariableValue(element, tokens)\n\n      //Push Input to tokens\n      //Format: {type:\"AcceptInput\",value:\" \",AcceptAs:\"Message\"}\n\n    }\n    else if (isInput(element) == true)\n\n    {\n\n      PushInput(element, tokens, cleaned_sourcedata, i)\n\n      //Push operators to tokens. The accepted operators are =,},{\n      //Format:{type:\"operator\",value:\"=\"}    \n\n    }\n    else if (isOperator(element) == true)\n    {\n\n      PushOperator(element, tokens)\n\n      //Push keyowrds to tokens. The accepted keywords is \n\n      //Format: {type:\"keyword\",value:\"\"}\n\n    }\n    else if (isKeyword(element) == true)\n    {\n\n      PushKeyword(element, tokens)\n\n      //Push functions to tokens\n      //Format: {type: \"function\", value: \"First\", arguments: Array(2), FunctionInvocationExists: false, FunctionStack: Array(0), }\n\n    }\n    else if (isFunction(element) == true)\n    {\n\n      PushFunctionData(element, tokens, cleaned_sourcedata, i)\n\n    }\n\n    // Push array to tokens\n    //Format: {type: \"Array\", value: \"[]\"}\n    else if (isArray(element) == true)\n    {\n\n      if (element.charAt(element.length - 1) == ']')\n      {\n\n        PushArray(element, tokens)\n\n      }\n      else\n      {\n\n        //To convert '[',1,2,3,4,']'  into [1,2,3,4]\n\n        let BuiltArray = BuildArray(element, i, cleaned_sourcedata)\n\n        PushArray(BuiltArray, tokens)\n\n      }\n    }\n\n    //For operations like Numbers[a]=a\n    //Format: {type:\"SetArrayIndexValue\",value:\"Fibonacci[a]\",ValueToSet:\"a\"}\n    else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == true)\n    {\n\n      PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n\n    }\n\n    //For operations like a=Numbers[a], reverse of above\n    //Format: {type:\"GetArrayIndexValue\",value:\"Fibonacci[a-2]\"}\n    else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == false)\n    {\n\n      PushGetArrayIndexValue(element, tokens, cleaned_sourcedata, i)\n\n    }\n\n    //Push conditions to tokens. The accepted keywords are , , \n    // Format: {type:\"conditionalkeyword\",value:\"\"}\n    else if (isConditionalKeyword(element) == true)\n    {\n\n      //Push while loops to tokens\n      //Format: {type: \"WhileLoopStart\", value: \"\"}, {type: \"condition\", value: \"count<25\"}\n\n      if (isWhileLoop(element) == true)\n      {\n\n        PushWhileLoop(element, tokens, cleaned_sourcedata, i)\n\n      }\n      else\n      {\n\n        PushConditionalKeyword(element, tokens)\n      }\n\n      //This is how we push conditions encountered in the sourcecode\n      //Format:{type:\"condition\",value:\"a<3\"}\n      let foundcondition = BuildCondition(element, i, cleaned_sourcedata)\n\n      //Push conditions to tokens array\n      PushCondition(foundcondition, tokens)\n\n    }\n\n    //Finding operations like Numbers.(x) \n    //Format: {type: \"PushToArray\", value: \"Numbers.(x)\"}\n    else if (element.includes(''))\n\n    {\n\n      PushToArray(element, tokens)\n\n    }\n\n    //Push For loop to tokens\n    // Format: \n    // {type:\"ForLoopStart\",value:\"\"}\n    //{type:\"ForLoopArguments\",iterator:\"a\",value:\"(0,25)\",iterationStart:\"0\",iterationEnd:\"25\"}\n    else if (isForLoop(element) == true)\n    {\n\n      PushForLoop(element, tokens)\n      PushForLoopAruguments(element, cleaned_sourcedata, i, tokens)\n\n      updated_tokens.push(\n      {\n\n        name: cleaned_sourcedata[i + 1],\n        value: 0,\n        type: 'ForLoopIterator'\n\n      })\n\n    }\n\n    //Pushing basic Calculations like 'length-1' to tokens\n    //Format: {type:\"Calculation\",value:\"length-1\"}\n    else if (isCalculation(element) == true)\n    {\n\n      let element = ''\n\n      if (cleaned_sourcedata[i + 1] != undefined)\n      {\n\n        // self is to perform long calculations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n\n        while (isCalculation(cleaned_sourcedata[i]))\n\n        {\n\n          element = element + cleaned_sourcedata[i];\n\n          i++;\n\n        }\n\n      }\n\n      terms = element.split('')\n\n      //removing the \"(\"\" and \")\"\n\n      var CleanedElement = RemoveBrackets(element)\n\n      // to stop prevention of expressions like is\"+ getting added as a calculation\n      if (!(CleanedElement.includes('\"')) && element.charAt(0) != '/' && element.charAt(0) != '*' && element.charAt(0) != \"'\")\n      {\n\n        PushCalculation(element, tokens, cleaned_sourcedata, i)\n\n      }\n\n    }\n\n    //finding operations like print(x + 'y'). The RealTimePrint operations\n\n    //Format: {type:\"value\",value:\"('Reversed String-'+ ReverseString)\",mode:\"RealTimePrint\"}\n    else if (isRealTimePrintMultipleString(element) == true)\n    {\n\n      let foundString = ''\n\n      let k = i\n\n      let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n      var flag = 0;\n\n      for (k; k < cleaned_sourcedata.length; k++)\n      {\n\n        let element = cleaned_sourcedata[k]\n        let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n        if (element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || cleaned_sourcedata[k + 1] == '=' || element == '}')\n        {\n\n          break;\n\n        }\n\n        if (conditionEnd == ')\"')\n\n        {\n\n          foundString = foundString + ' ' + cleaned_sourcedata[k];\n          break;\n\n        }\n        else if (flag == 1)\n        {\n\n          foundString = foundString + ' ' + cleaned_sourcedata[k]\n\n        }\n        else if (flag == 0)\n        {\n\n          foundString = cleaned_sourcedata[k];\n\n          flag = 1;\n\n        }\n\n      }\n\n      if ((!foundString.includes(\">\")) && (!foundString.includes('/')) && (!foundString.includes('*')) && (!foundString.includes('<')) && (!foundString.includes('==')))\n\n      {\n\n        //console.log('foundString: ', foundString);\n        PushRealTimePrintOperation(foundString, tokens)\n\n      }\n\n    }\n\n    //storing only the string values to tokens ( not the strings in print statements)\n    else if (isString(element))\n\n    {\n\n      let calculatedString = BuildString(element, i, cleaned_sourcedata)\n\n      calculatedString = calculatedString.replace(/['\"]+/g, '')\n\n      if (!(calculatedString.includes(\"\")))\n\n        PushString(calculatedString, tokens)\n\n    }\n\n    //An extension of isKeyword() function\n    // Needs improvement\n    else if (/^(?=.*?)(?=.*[a-z])/.test(element))\n    {\n\n      PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n\n      PushExpression(element.slice(6), tokens) //Pushing remaining expression like (a), (Message) etc\n    }\n\n    //error prone change made here- Pushing expression in here\n    //Used to push functions and expressions\n    //Unnecessary data is being passed through kalaam.\n    //This was created for a temporary fix\n    else if (isExpression(element) == true && !isCalculation(element) && !element.includes('[') && !element.includes(']') && (!isConditionalKeyword(cleaned_sourcedata[i - 1])) && (cleaned_sourcedata[i - 1] != '' && cleaned_sourcedata[i - 1] != ''))\n    {\n\n      let CheckFunctionExpression = element.split('(')\n\n      let passedValues = RemoveBrackets(CheckFunctionExpression[1])\n      passedValues = passedValues.split(',')\n      let token = tokens.find(el => el.value == CheckFunctionExpression[0])\n\n      if (token != undefined)\n      {\n\n        PushFunctionExecution(element, tokens, cleaned_sourcedata, i, passedValues)\n\n      }\n      else\n      {\n\n        PushExpression(element, tokens)\n      }\n\n    }\n    else if (isExpression(element) == true && element.includes('[') && element.includes(']'))\n    {\n\n      PushArray(element, tokens)\n\n    }\n\n    //This is experimental. For now, you can just neglect self\n    else if (!isKeyword(element) && !isNumber(element) && !isVariable(element) && !isExpression(element) && !isOperator(element))\n    {\n\n      //ANCHOR \n      /*Hnadling Impurity error-The main problem is figuring out how to solve \"=7000\" like things\n      instead asking developers to add space manually\n      Handling Alphanumeric strings to solve issues like ' anna=2362934'\n\n      let impurity = element.split('=')\n\n      let findString = impurity[1]\n\n\n      //to accept long numbers i.e a=749374593745937\n\n      if (isVariable(impurity[0]) && isNumber(impurity[1])) {\n\n\n          impurity[2] = impurity[1];\n          impurity[1] = '=';\n\n      }\n\n      //to accept a=STRING\n      if (isVariable(impurity[0]) && isVariable(impurity[1])) {\n\n\n          impurity[2] = impurity[1];\n          impurity[1] = '=';\n\n      }\n\n\n\n      impurity.forEach((element, i) => {\n\n          if (isVariable(element) == true) {\n\n\n\n              PushVariable(element, tokens)\n\n\n              //continue;\n          }\n\n          // ANCHOR \n\n          //Issue: Right now, only isNumber is resolved, a=, =23828qw aren't resolved.\n          //Solution: Work on all the modules\n\n\n          if (isNumber(element) == true) {\n\n\n              PushNumber(element, tokens)\n\n          }\n\n          //ANCHOR \n          //You might have to remove self extra filters since you are only working on numbers (Future Issue)\n          if (isOperator(element) == true) {\n              PushOperator(element, token)\n\n          }\n\n\n\n          if (isKeyword(element) == true) {\n\n              PushKeyword(element)\n\n          }\n\n          if (isExpression(element) == true) {\n\n\n              PushExpression(element, tokens)\n\n          }\n\n\n\n\n      })\n         */\n\n    }\n\n  }\n\n  //The final stage of adding an output to output stack i.e. kalaam.output or kalaam.output\n\n  function AddOutput( value)\n  {\n\n    kalaam.output = kalaam.output + value + \"\\n\";\n\n  }\n\n  \n  \n  \n  //#STEP 1- Cleaning the sourcedata and setting the 'result' to 'cleaned_sourcedata'\n\n \n \n \n //If a code is not working, it is probably because it's not cleaned properly. \n  cleaned_sourcedata = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity)\n  \n  \n\n  \n  \n  //#STEP 2- - Checking each token and adding to tokens array\n  \n  \n  \n  //Parsing every single element from cleaned_sourcedata array and pushing it to Tokens depending upon the type pf element\n\n  // PARSING INITIATION\n\n  for (i; i < cleaned_sourcedata.length; i++)\n  {\n\n    Parse(cleaned_sourcedata, i)\n  }\n\n  //CLEANING UP THE TOKENS ARRAY\n  //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n\n  tokens = tokens.filter(el => el.value != '')\n  console.log('tokens: ', tokens);\n  \n  \n\n  \n  \n  //#STEP 3 - evaluating conditions, finding values in updated_tokens and printing outputs\n\n  \n  \n  //As of now, self is how the timeline looks\n\n  //raw sourcecode -> cleaned_sourcedata -> tokens \n\n  //This is the final section\n\n  for (var j = 0; j < tokens.length; j++)\n  {\n\n    //We will be having a copy of tokens as mutable_tokens \n\n    let mutable_tokens = tokens\n\n    //token value\n    var token = mutable_tokens[j].value\n    \n\n    //type of token like variable, array, function, loops etc\n    let tokenType = mutable_tokens[j].type\n\n    var StringVar = []\n\n    let VarWithoutbrackets = RemoveBrackets(mutable_tokens[j].value)\n    \n\n    VarWithoutbrackets = VarWithoutbrackets.replace(/ /g, '')\n\n    if (tokenType == \"SetArrayIndexValue\")\n\n    {\n\n      SetArrayIndexValue(mutable_tokens, j, j, updated_tokens, tokens, OriginalIterator, iterator)\n\n    }\n    else if (token == '=')\n    {\n\n      AssignorUpdateValues(mutable_tokens, j, updated_tokens, iterator, OriginalIterator, self)\n\n    }\n    else if (tokenType == 'PushToArray')\n    {\n\n      AddElementToArray(mutable_tokens, j, updated_tokens)\n\n    }\n    else if (token == '')\n\n    {\n\n      let result = HandleBlocks(mutable_tokens, j, result)\n      console.log('result: ', result);\n      let StartofBlock = mutable_tokens[j + 1].startIndex\n      let EndofBlock = mutable_tokens[j + 1].EndIndex\n\n      let lastValue = kalaam.LastConditionValue.pop()\n\n      if (lastValue == true)\n\n      {\n\n        j = EndofBlock\n\n      }\n\n    }\n    else if (tokenType == 'AcceptInput')\n    {\n\n      AcceptInputandSetValue(mutable_tokens, j, updated_tokens)\n\n    }\n\n    //Whenever we encounter a function, we create a seperate execution context \n    else if (tokenType == 'function')\n    {\n\n      //We are preparing the required data to execute a function call later in the prgroam\n\n      //functionsourcedata includes all the tokens from tokens array which belongs to a particular function\n\n      //We find self range or a function block through HandleBlocks function\n\n      let functionSourceData = []\n\n      let result = HandleBlocks(mutable_tokens, j + 1, functionSourceData)\n\n      functionSourceData = result.StoreResult\n\n      //To identify function context in tokens array\n\n      functionSourceData.forEach(el =>\n      {\n\n        el.context = 'function'\n      })\n\n      mutable_tokens[j].SourceData = functionSourceData\n\n    }\n\n    //We are out of the fucntion execution context and back to global execution context\n    else if (tokenType == 'condition')\n\n    {\n\n      let element = mutable_tokens[j].value\n\n      //self function is the first step to calculate value of operations like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n      let ConditionValue = GetConditionValue(element, updated_tokens, j)\n      kalaam.LastConditionValue.push(ConditionValue)\n\n      //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n      if (ConditionValue == false)\n      {\n\n        let InitializeLoop = tokens.indexOf(mutable_tokens[j])\n\n        //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n        //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n        let Returnvalue = HandleBlocks(mutable_tokens, j)\n\n        j = Returnvalue.j\n      }\n\n    }\n\n    //So that we don't print a same value twice. First in global execution context and the in function context\n\n    //This one prints the global context values\n    else if (token == '' && mutable_tokens[j].context != 'function')\n\n    {\n\n      PrintEngine(mutable_tokens, updated_tokens, j, self) //for operations like print(array[3])\n\n    }\n\n    //This runs our while loop .i.e \n    else if (tokenType == 'WhileLoopStart')\n    {\n\n      let TokensCurrentIndex = j + 3\n\n      let ConditionValue = false\n\n      let element = mutable_tokens[j + 1].value\n\n      let ExtratcedVariable = []\n\n      let variable = ''\n      let WhileLoopSourcedataIndexStart = 0\n      let WhileLoopSourcedataTokens = []\n\n      for (let i = 0; i < element.length; i++)\n      {\n        let x = element.charAt(i)\n\n        if (isVariable(x))\n\n        {\n\n          variable = variable + x\n\n        }\n        if (!isVariable(element.charAt(i + 1)) && isVariable(x))\n        {\n\n          let token = updated_tokens.find(el => el.name == variable)\n\n          ExtratcedVariable.push(\n          {\n            variable: variable,\n            value: token.value\n\n          })\n\n          variable = ''\n\n        }\n\n      }\n\n      function getWhileLoopSourcedata(startIndex, mutable_tokens, check, StoreResult)\n      {\n\n        StoreResult = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n\n        return StoreResult\n\n      }\n\n      WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart)\n\n      WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, '}', WhileLoopSourcedataTokens).StoreResult\n\n      //constantly accessing the conditionvalue\n\n      while (GetConditionValue(element, updated_tokens, j + 1))\n      {\n\n        for (let i = 0; i < WhileLoopSourcedataTokens.length; i++)\n        {\n\n          //SECTION while loop context\n\n          if (WhileLoopSourcedataTokens[i].value == '=')\n          {\n\n            AssignorUpdateValues(WhileLoopSourcedataTokens, i, updated_tokens)\n\n          }\n          else if (WhileLoopSourcedataTokens[i].type == 'AcceptInput')\n          {\n\n            AcceptInputandSetValue(WhileLoopSourcedataTokens, i, updated_tokens)\n\n          }\n\n          // Handling CONDITIONAL statements in While loop\n          else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n          {\n\n            //if index returns a value, it means condition is false and skip the execution\n\n            let index = HandleConditions(WhileLoopSourcedataTokens, i, updated_tokens)\n\n            if (index != undefined)\n            {\n              i = index\n\n            }\n            else\n            {\n              i = i\n            }\n\n          }\n\n          //Handling  statements in while loop\n          else if (WhileLoopSourcedataTokens[i].value == '')\n\n          {\n\n            PrintEngine(WhileLoopSourcedataTokens, updated_tokens, i, self) //for operations like print(array[3])\n\n          }\n\n          //operations like Numbers[a]='xyz'\n          else if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n          {\n\n            SetArrayIndexValue(WhileLoopSourcedataTokens, i, j, updated_tokens, tokens, OriginalIterator, iterator)\n\n          }\n\n        }\n\n      }\n\n      //End of While loop execution\n\n      //Handling For loops \n\n    }\n    else if (tokenType == 'ForLoopStart')\n\n    {\n\n      var FlagPrimalLoop = 0\n\n      var SourcedataTokens = []\n\n      let ForLoopMetaData = ForLoopSetMetadata(mutable_tokens, j, updated_tokens)\n      \n\n      var ForLoopSourcedataIndexStart = ForLoopMetaData.ForLoopSourcedataIndexStart\n      var Cycle = ForLoopMetaData.Cycle\n\n      var OriginalIterator = ForLoopMetaData.OriginalIterator\n      var IterationStart = ForLoopMetaData.IterationStart\n      var iterator = ForLoopMetaData.iterator\n      var element = ForLoopMetaData.element\n      var elementValue = ForLoopMetaData.elementValue\n\n      function getSourcedata(startIndex, mutable_tokens, check, StoreResult)\n      {\n\n        let Returnvalue = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n        StoreResult = Returnvalue.StoreResult\n\n        return StoreResult\n\n      }\n\n      ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart)\n\n      SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, '}', SourcedataTokens)\n      \n\n      SourcedataTokens.forEach(el =>\n      {\n\n        el.isNestedLoop = false\n\n      })\n\n      //Checking if the for loop has one more for loop inside it\n      let FindNestedLoop = SourcedataTokens.find(el => el.type == 'ForLoopStart')\n\n      if (FindNestedLoop != undefined)\n      {\n\n        let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 3\n        let NestedLooplength = (SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex) + 2\n\n        //if we have a nested loop, set isNesteLoop to TRUE\n\n        for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++)\n        {\n\n          SourcedataTokens[x].isNestedLoop = true\n\n        }\n\n      }\n\n      if (element.includes('(') && element.includes(','))\n\n      {\n\n        FlagPrimalLoop = 1\n\n      }\n\n      //Iterating over forloop sourcedata\n      //self line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n      for (iterator = IterationStart; iterator <= Cycle; iterator++)\n      \n      {\n\n        let forloopindex = updated_tokens.find(el => el.name == OriginalIterator)\n\n        forloopindex.value = iterator\n\n        //flag to avoid running self code if loop is primal because the payload needs to be compeltely different\n        if (FlagPrimalLoop = 0)\n        {\n          ForLoopArrayorStringOutput(elementValue, iterator, updated_tokens, self)\n\n        }\n\n        for (let i = 0; i < SourcedataTokens.length; i++)\n\n        {\n\n          let isNested = SourcedataTokens[i].isNestedLoop\n\n          //This code runs only if we have a nested loop situation\n\n          if (SourcedataTokens[i].type == 'ForLoopStart')\n          {\n\n            var NestedFlagPrimalLoop = 0\n\n            var NestedSourcedataTokens = []\n\n            let NestedForLoopMetaData = ForLoopSetMetadata(SourcedataTokens, i, updated_tokens)\n            var NestedForLoopSourcedataIndexStart = NestedForLoopMetaData.ForLoopSourcedataIndexStart\n            var NestedCycle = NestedForLoopMetaData.Cycle + 1\n            var NestedOriginalIterator = NestedForLoopMetaData.OriginalIterator\n            var NestedIterationStart = NestedForLoopMetaData.IterationStart\n            var Nestediterator = NestedForLoopMetaData.IterationStart\n            var Nestedelement = NestedForLoopMetaData.element\n            var NestedelementValue = NestedForLoopMetaData.elementValue\n\n            function getSourcedata(startIndex, SourcedataTokens, check, StoreResult)\n            {\n\n              let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n              StoreResult = Returnvalue.StoreResult\n\n              return StoreResult\n\n            }\n\n            NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n\n            NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n\n            for (Nestediterator; Nestediterator < NestedCycle; Nestediterator++)\n            {\n              {\n\n                let y = Nestediterator\n\n                let Nestedforloopindex = updated_tokens.find(el => el.name == NestedOriginalIterator)\n\n                Nestedforloopindex.value = y\n\n                for (let index = 0; index < NestedSourcedataTokens.length; index++)\n                {\n\n                  let el = NestedSourcedataTokens[index]\n\n                  if (el.value == '')\n\n                  {\n\n                    PrintEngine(NestedSourcedataTokens, updated_tokens, index, self, y, NestedOriginalIterator)\n\n                  }\n                  else if (el.value == '=' && el.isNestedLoop == true)\n                  {\n\n                    AssignorUpdateValues(NestedSourcedataTokens, index, updated_tokens, y, NestedOriginalIterator)\n\n                  }\n                  else if (el.type == 'condition' && el.isNestedLoop == true)\n\n                  {\n\n                    let ConditionStartIndex = index\n                    let condition = NestedSourcedataTokens[index].value\n                    //HandleConditions evaluates condition and return the index of from where printing should resume\n\n                    //value of i depends on the conditions\n\n                    let value = GetConditionValue(condition, updated_tokens, index)\n                    \n\n                    kalaam.LastConditionValue.push(value)\n\n                    if (value == false)\n                    {\n\n                      break\n\n                    }\n\n                  }\n                  else if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop == true)\n\n                  {\n\n                    SetArrayIndexValue(NestedSourcedataTokens, i, j, updated_tokens, tokens, OriginalIterator, iterator)\n\n                  }\n\n                }\n\n              }\n\n            }\n\n          }\n          else if (SourcedataTokens[i].value == '=' && isNested == false)\n          {\n\n            //assigning values to variables in a for loop\n\n            AssignorUpdateValues(SourcedataTokens, i, updated_tokens, iterator, OriginalIterator)\n            \n\n          }\n          else if (SourcedataTokens[i].type == 'PushToArray')\n\n          {\n\n            AddElementToArray(SourcedataTokens, i, updated_tokens)\n\n          }\n          else if (SourcedataTokens[i].type == 'AcceptInput')\n          {\n\n            AcceptInputandSetValue(SourcedataTokens, i, updated_tokens)\n\n          }\n\n          //Handling print statements in for loop\n          else if (SourcedataTokens[i].value == '' && isNested == false)\n\n          {\n\n            PrintEngine(SourcedataTokens, updated_tokens, i, self, iterator, OriginalIterator)\n\n          }\n\n          //Handling set array element statements in for loop\n          else if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n          {\n\n            SetArrayIndexValue(SourcedataTokens, i, j, updated_tokens, tokens, OriginalIterator, iterator)\n\n          }\n\n          // Handling CONDITIONAL statements in for loop\n          else if (SourcedataTokens[i].type == 'condition')\n\n          {\n\n            let ConditionStartIndex = i\n            let condition = SourcedataTokens[i].value\n            \n            //HandleConditions evaluates condition and return the index of from where printing should resume\n            //value of i depends on the conditions\n\n            if (condition.includes('||') || condition.includes('&&'))\n\n            {\n\n              let value = GetConditionValue(condition, updated_tokens, i)\n\n              //Experimental\n              kalaam.LastConditionValue.push(value)\n\n              if (value == false)\n              {\n\n                let BlockLength = 0\n                let BlockStart = 0\n\n                while (SourcedataTokens[i].value != '{')\n\n                {\n\n                  if (SourcedataTokens[i + 1].value == '{')\n\n                  {\n\n                    BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                    i = BlockLength + i + 1\n\n                    break;\n\n                  }\n\n                  i++\n                }\n\n              }\n              else\n              {\n\n                i = i\n\n              }\n\n            }\n            else\n            {\n\n              i = HandleConditions(SourcedataTokens, i, updated_tokens);\n              \n\n              if (i != undefined)\n              {\n\n                i = i\n\n              }\n              else\n              {\n                i = ConditionStartIndex\n              }\n\n            }\n\n          }\n\n        }\n\n      }\n\n      j = j + SourcedataTokens.length\n\n    }\n\n    //END FOR LOOP EXECUTION\n    else if (tokenType == 'functionExecution')\n    {\n\n      //checking if function is invoked somewhere later in the program\n\n      //If we see a function execution call, for e.g Add(x,y), we prepare for execution\n\n      let functionSourceData = []\n\n      let functionName = mutable_tokens[j].value\n\n      let passedValues = mutable_tokens[j].passedValues\n\n      let functionToken = mutable_tokens.find(el => el.value == functionName)\n\n      let functionArguments = functionToken.arguments\n\n      functionSourceData = functionToken.SourceData\n\n      //Creating a seperate execution context and setting fucntion context name:value pair in functionContextupdated_tokens\n\n      //for e.g x=3, y=4 is already defined and then we execute add(x,y)\n\n      // This is an updated_tokens form limited to function context\n\n      //Operating on function arguments and setting their values. For e.g the function add(x,y) might be called as add(3,4)\n\n      //so we set x=3, y=4 and set self variable-value pair in functionContextupdated_tokens\n\n      functionArguments.forEach((el, index) =>\n      {\n\n        let val = passedValues[index]\n\n        val = val.replace(/\"/g, \"\");\n        val = val.replace(/'/g, \"\");\n\n        passedValues[index] = val\n\n        //in self code we are filtering out arguments passed based on whether they already exist in updated tokens or not\n\n        let FindInUpdatedTokens = updated_tokens.find(el => el.name == val)\n\n        //For passing same argument and same value to function  e.g function foo (fibonacci) and fibonacci is already declared with some value\n        if (FindInUpdatedTokens == undefined)\n        {\n\n          functionContextupdated_tokens.push(\n          {\n\n            name: el,\n\n            value: val,\n\n            identifier: j + index,\n            type: 'value',\n            context: 'FunctionExecutionContext'\n\n          })\n\n        }\n\n        //For passing different argument and value to function  e.g function foo (arr) and arr doesn't exist anywhere in tokens.\n        else if (el != FindInUpdatedTokens.name && FindInUpdatedTokens != undefined)\n        {\n\n          functionContextupdated_tokens.push(\n          {\n\n            name: el,\n\n            value: FindInUpdatedTokens.value,\n\n            identifier: j + index,\n            type: FindInUpdatedTokens.type,\n            context: 'FunctionExecutionContext',\n            IntheEndSetValueto: val\n\n          })\n\n        }\n        else\n        {\n\n          functionContextupdated_tokens.push(\n          {\n\n            name: el,\n\n            value: val,\n\n            identifier: j + index,\n            type: FindInUpdatedTokens.type,\n            context: 'FunctionExecutionContext',\n            IntheEndSetValueto: val\n\n          })\n\n        }\n\n      });\n\n      //Building a complete variable-value pair dataset\n\n      var CompleteTokenValueList = [...updated_tokens, ...functionContextupdated_tokens]\n\n      //Now we start digging into the function execution\n\n      for (let i = 1; i < functionSourceData.length; i++)\n\n      {\n\n        let el = functionSourceData[i]\n\n        //operations like (Message)\n        //PrintEngine will take care of every print statement encountered in the program\n\n        if (el.value == '')\n\n        {\n\n          PrintEngine(functionSourceData, CompleteTokenValueList, i, self)\n\n        }\n\n        //operations like Message='Hello World'\n\n        //AssignorUpdateValues function will take care of every assignment encountered in the program\n        else if (el.value == '=')\n        {\n\n          AssignorUpdateValues(functionSourceData, i, CompleteTokenValueList, iterator, OriginalIterator, self)\n\n        }\n\n        //operations like (Message)\n        else if (el.type == 'AcceptInput')\n        {\n\n          AcceptInputandSetValue(functionSourceData, i, updated_tokens)\n\n        }\n\n        //operations like x<24, y!=5, Message=='HellO World\"\n        else if (el.type == 'condition')\n\n        {\n\n          let element = functionSourceData[i].value\n\n          //self function is the first step to calculate value of  mulitiple conditions like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n          //GetConditionValue is our goto function to evaluate a condition to true or false\n          let ConditionValue = GetConditionValue(element, CompleteTokenValueList, i)\n\n          kalaam.LastConditionValue.push(ConditionValue)\n\n          //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n          if (ConditionValue == false)\n          {\n\n            let InitializeLoop = tokens.indexOf(functionSourceData[i])\n\n            //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n            //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n            let Returnvalue = HandleBlocks(functionSourceData, i)\n\n            i = Returnvalue.i\n          }\n\n        }\n\n        //Handling set array element statements in for loop\n        // for e.g Numbers[2]=28\n        else if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n        {\n\n          SetArrayIndexValue(functionSourceData, i, j, CompleteTokenValueList, tokens, OriginalIterator, iterator)\n\n        }\n\n        //Opearting on for loop encountered in program\n        else if (functionSourceData[i].type == 'ForLoopStart')\n\n        {\n\n          var FlagPrimalLoop = 0\n\n          var SourcedataTokens = []\n\n          let ForLoopMetaData = ForLoopSetMetadata(functionSourceData, i, CompleteTokenValueList)\n\n          var ForLoopSourcedataIndexStart = ForLoopMetaData.ForLoopSourcedataIndexStart\n          var Cycle = ForLoopMetaData.Cycle\n          var OriginalIterator = ForLoopMetaData.OriginalIterator\n          var IterationStart = ForLoopMetaData.IterationStart\n          var iterator = ForLoopMetaData.iterator\n          var element = ForLoopMetaData.element\n          var elementValue = ForLoopMetaData.elementValue\n\n          function getSourcedata(startIndex, functionSourceData, check, StoreResult)\n          {\n\n            let Returnvalue = HandleBlocks(functionSourceData, startIndex, StoreResult)\n            StoreResult = Returnvalue.StoreResult\n\n            return StoreResult\n\n          }\n\n          ForLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', ForLoopSourcedataIndexStart)\n\n          //\n\n          SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, functionSourceData, '}', SourcedataTokens)\n\n          SourcedataTokens.forEach(el =>\n          {\n\n            el.isNestedLoop = false\n\n          })\n\n          let FindNestedLoop = SourcedataTokens.find(el => el.type == 'ForLoopStart')\n          if (FindNestedLoop != undefined)\n          {\n\n            let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 2\n            let NestedLooplength = (SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex) + 1\n\n            for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++)\n            {\n\n              SourcedataTokens[x].isNestedLoop = true\n\n            }\n\n          }\n\n          //Primal loop is the one where user gives us the range directly like (1,20) etc.\n\n          if (element.includes('(') && element.includes(','))\n\n          {\n\n            FlagPrimalLoop = 1\n\n          }\n\n          //Iterating over forloop sourcedata\n          //self line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n          for (iterator = IterationStart; iterator <= Cycle; iterator++)\n          {\n\n            let forloopindex = CompleteTokenValueList.find(el => el.name == OriginalIterator)\n\n            forloopindex.value = iterator\n\n            //flag to avoid running self code if loop is primal because the payload needs to be compeltely different\n            if (FlagPrimalLoop = 0)\n            {\n              ForLoopArrayorStringOutput(elementValue, iterator, CompleteTokenValueList, self)\n\n            }\n\n            for (let i = 0; i < SourcedataTokens.length; i++)\n\n            {\n\n              let isNested = SourcedataTokens[i].isNestedLoop\n\n              //This is nested loop\n              //Works but needs improvements on various parts\n\n              //NESTED FOR LOOP START\n\n              if (SourcedataTokens[i].type == 'ForLoopStart')\n              {\n\n                var NestedFlagPrimalLoop = 0\n\n                var NestedSourcedataTokens = []\n\n                let NestedForLoopMetaData = ForLoopSetMetadata(SourcedataTokens, i, CompleteTokenValueList)\n\n                var NestedForLoopSourcedataIndexStart = NestedForLoopMetaData.ForLoopSourcedataIndexStart\n                var NestedCycle = NestedForLoopMetaData.Cycle + 1\n                var NestedOriginalIterator = NestedForLoopMetaData.OriginalIterator\n                var NestedIterationStart = NestedForLoopMetaData.IterationStart\n                var Nestediterator = NestedForLoopMetaData.IterationStart\n\n                var Nestedelement = NestedForLoopMetaData.element\n                var NestedelementValue = NestedForLoopMetaData.elementValue\n\n                function getSourcedata(startIndex, SourcedataTokens, check, StoreResult)\n                {\n                  //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n                  let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                  StoreResult = Returnvalue.StoreResult\n\n                  return StoreResult\n\n                }\n\n                NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n\n                NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n\n                for (Nestediterator; Nestediterator < NestedCycle; Nestediterator++)\n                {\n                  {\n\n                    let y = Nestediterator\n\n                    let Nestedforloopindex = CompleteTokenValueList.find(el => el.name == NestedOriginalIterator)\n                    //console.log('forloopindex: ', forloopindex);\n\n                    Nestedforloopindex.value = y\n\n                    for (let index = 0; index < NestedSourcedataTokens.length; index++)\n                    {\n\n                      let el = NestedSourcedataTokens[index]\n\n                      if (el.value == '')\n\n                      {\n\n                        PrintEngine(NestedSourcedataTokens, CompleteTokenValueList, index, self, y, NestedOriginalIterator)\n\n                      }\n                      else if (el.value == '=' && el.isNestedLoop == true)\n                      {\n\n                        //assigning values to variables\n\n                        AssignorUpdateValues(NestedSourcedataTokens, index, CompleteTokenValueList, y, NestedOriginalIterator, self)\n\n                      }\n                      else if (el.type == 'condition' && el.isNestedLoop == true)\n\n                      {\n\n                        //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                        let ConditionStartIndex = index\n                        let condition = NestedSourcedataTokens[index].value\n                        //HandleConditions evaluates condition and return the index of from where printing should resume\n                        //value of i depends on the conditions\n\n                        if (condition.includes('||') || condition.includes('&&'))\n\n                        {\n\n                          let value = GetConditionValue(condition, CompleteTokenValueList, index)\n                          kalaam.LastConditionValue.push(value)\n\n                          if (value == false)\n                          {\n\n                            let BlockLength = 0\n                            let BlockStart = 0\n\n                            while (NestedSourcedataTokens[index].value != '{')\n\n                            {\n\n                              if (NestedSourcedataTokens[index + 1].value == '{')\n\n                              {\n\n                                BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                index = BlockLength + index + 1\n\n                                break;\n\n                              }\n\n                              index++\n                            }\n\n                          }\n                          else\n                          {\n\n                            index = index\n\n                          }\n\n                        }\n                        else\n                        {\n\n                          let x = HandleConditions(NestedSourcedataTokens, index, CompleteTokenValueList);\n\n                          if (x != undefined)\n                          {\n\n                            index = x\n\n                          }\n                          else\n                          {\n                            index = ConditionStartIndex\n                            //console.log('i: ', i);\n                          }\n\n                        }\n\n                      }\n\n                      //console.log('i: ', i);\n\n                      // i = i + NestedSourcedataTokens.length\n                      //console.log('i: ', i);\n                      else if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop == true)\n\n                      {\n                        SetArrayIndexValue(NestedSourcedataTokens, i, j, CompleteTokenValueList, tokens, OriginalIterator, iterator)\n\n                      }\n\n                    }\n\n                  }\n\n                }\n\n              }\n              else if (SourcedataTokens[i].type == 'AcceptInput' && isNested == false)\n              {\n                AcceptInputandSetValue(SourcedataTokens, i, updated_tokens)\n\n              }\n              else if (SourcedataTokens[i].value == '=' && isNested == false)\n              {\n\n                //assigning values to variables\n\n                AssignorUpdateValues(SourcedataTokens, i, CompleteTokenValueList, iterator, OriginalIterator, self)\n\n              }\n\n              //Handling print statements in for loop\n              else if (SourcedataTokens[i].value == '' && isNested == false)\n\n              {\n\n                //for operations like print(array[3])\n\n                // console.log('for looop prints: ', functionSourceData[i],i);\n\n                PrintEngine(SourcedataTokens, CompleteTokenValueList, i, self, iterator, OriginalIterator)\n\n                //\n\n              }\n\n              //Handling set array element statements in for loop\n              else if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n              {\n\n                SetArrayIndexValue(SourcedataTokens, i, j, CompleteTokenValueList, tokens, OriginalIterator, iterator)\n\n              }\n\n              // Handling CONDITIONAL statements in for loop\n              else if (SourcedataTokens[i].type == 'condition')\n\n              {\n\n                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                let ConditionStartIndex = i\n                let condition = SourcedataTokens[i].value\n                //HandleConditions evaluates condition and return the index of from where printing should resume\n                //value of i depends on the conditions\n\n                if (condition.includes('||') || condition.includes('&&'))\n\n                {\n\n                  let value = GetConditionValue(condition, updated_tokens, i)\n                  kalaam.LastConditionValue.push(value)\n\n                  if (value == false)\n                  {\n\n                    let BlockLength = 0\n                    let BlockStart = 0\n\n                    while (SourcedataTokens[i].value != '{')\n\n                    {\n\n                      if (SourcedataTokens[i + 1].value == '{')\n\n                      {\n\n                        BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                        i = BlockLength + i + 1\n\n                        break;\n\n                      }\n\n                      i++\n                    }\n\n                  }\n                  else\n                  {\n\n                    i = i\n\n                  }\n\n                }\n                else\n                {\n\n                  i = HandleConditions(SourcedataTokens, i, CompleteTokenValueList);\n\n                  if (i != undefined)\n                  {\n\n                    i = i\n\n                  }\n                  else\n                  {\n                    i = ConditionStartIndex\n                    //console.log('i: ', i);\n                  }\n\n                }\n\n              }\n\n            }\n\n          }\n\n          i = i + SourcedataTokens.length\n\n          //END NESTED FOR LOOP\n\n        }\n        else if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n        {\n\n          SetArrayIndexValue(SourcedataTokens, i, j, CompleteTokenValueList, tokens, OriginalIterator, iterator)\n\n        }\n\n        //Handling While loop in function\n        else if (functionSourceData[i].type == 'WhileLoopStart')\n        {\n\n          let TokensCurrentIndex = i + 3\n\n          let ConditionValue = false\n\n          let element = functionSourceData[i + 1].value\n\n          let ExtratcedVariable = []\n\n          let variable = ''\n          let WhileLoopSourcedataIndexStart = 0\n          let WhileLoopSourcedataTokens = []\n\n          for (let i = 0; i < element.length; i++)\n          {\n            let x = element.charAt(i)\n\n            if (isVariable(x))\n\n            {\n\n              variable = variable + x\n\n            }\n            if (!isVariable(element.charAt(i + 1)) && isVariable(x))\n            {\n\n              let token = CompleteTokenValueList.find(el => el.name == variable)\n\n              ExtratcedVariable.push(\n              {\n                variable: variable,\n                value: token.value\n\n              })\n\n              variable = ''\n\n            }\n\n          }\n\n          function getWhileLoopSourcedata(startIndex, functionSourceData, check, StoreResult)\n          {\n\n            StoreResult = HandleBlocks(functionSourceData, startIndex, StoreResult)\n\n            return StoreResult\n\n          }\n\n          WhileLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', WhileLoopSourcedataIndexStart)\n          //\n          WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, functionSourceData, '}', WhileLoopSourcedataTokens).StoreResult\n\n          //constantly evaluating the conditionvalue. for e.g count<25 in (count<25)\n\n          while (GetConditionValue(element, CompleteTokenValueList, j + 1))\n          {\n\n            for (let i = 0; i < WhileLoopSourcedataTokens.length; i++)\n            {\n\n              //SECTION while loop context\n\n              if (WhileLoopSourcedataTokens[i].value == '=')\n              {\n\n                AssignorUpdateValues(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                //\n\n                // \n\n              }\n              else if (WhileLoopSourcedataTokens[i].type == 'AcceptInput')\n              {\n\n                AcceptInputandSetValue(WhileLoopSourcedataTokens, i, updated_tokens)\n\n              }\n\n              // Handling CONDITIONAL statements in for loop\n              else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n              {\n\n                let index = HandleConditions(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                if (index != undefined)\n                {\n                  i = index\n\n                }\n                else\n                {\n                  i = i\n                }\n\n              }\n              else if (WhileLoopSourcedataTokens[i].value == '')\n\n              {\n\n                PrintEngine(WhileLoopSourcedataTokens, CompleteTokenValueList, i, self) //for operations like print(array[3])\n\n              }\n              else if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n              {\n\n                SetArrayIndexValue(WhileLoopSourcedataTokens, i, j, CompleteTokenValueList, tokens, OriginalIterator, iterator)\n\n              }\n\n            }\n\n          }\n\n          i = i + 1 + WhileLoopSourcedataTokens.length + 1\n\n        }\n\n      }\n\n      //skipping parsing index so that function context is run by single entity and global execution doesn't run self code too\n      //  j = mutable_tokens[j + 1].EndIndex\n\n      //If we pass function foo(arr) where arr is (suppose) fibonacci=[] declared in the global exe context(updated_tokens). But operation will be performed on\n      //arr in functionContextupdated_tokens. so at the end of fucntion execution we set the value to it's right owner.\n      let token = functionContextupdated_tokens.find(el => el.IntheEndSetValueto != '')\n      let GivePowersTo = updated_tokens.find(el => el.name == token.IntheEndSetValueto)\n\n      GivePowersTo.value = token.value\n\n      //I have to empty it because function context has to remain empty other wise function arguments will keep on accepting new values with the same key\n      //for e.g= PrintFullName(FirstName,LastName) and PrintFullName(FirstNam,LastNam) needs two different execution context hence first one needs to make space for later\n\n      functionContextupdated_tokens = []\n\n    }\n\n  }\n\n\n\n  //This is where error handling kicks in\n\n  //To find undefined variables\n\n  function onlyUnique(value, index, arr)\n  {\n    return arr.indexOf(value) === index;\n  }\n\n  var assigned_variables = assigned_variables.filter(onlyUnique)\n\n  let difference = variables_array.filter(x => !assigned_variables.includes(x))\n\n  if (difference.length > 0)\n\n  {\n\n    difference.forEach(el =>\n    {\n\n      kalaam.error.push('Variable ' + el + ' is undefined ')\n\n    })\n\n  }\n\n  if (kalaam.error.length > 0)\n  {\n\n    kalaam.linebylineOutput = kalaam.error\n\n  }\n  else\n  {\n\n    kalaam.linebylineOutput = kalaam.output.split('\\n')\n\n  }\n\n  //time taken to transpile the code is t1-t0\n  var t1 = performance.now()\n\n  if (kalaam.linebylineOutput != '' && kalaam.error.length == 0)\n  {\n    kalaam.TimeTaken = \"Compiled Succesfully in \" + (t1 - t0).toPrecision(4) + \"ms.\"\n\n  }\n  else\n  {\n\n    kalaam.isError = true\n\n    kalaam.TimeTaken = \"Compilation Error: Check for assignement and declaration mistyping\"\n\n  }\n\n  //kalaam.linebylineoutput is what you will finally see on output screen\n\n  kalaam.linebylineOutput = kalaam.linebylineOutput.filter(function(item)\n  \n\n  \n  {\n\n    return item !== \"\"\n  })\n\n\n\n}"]}]}