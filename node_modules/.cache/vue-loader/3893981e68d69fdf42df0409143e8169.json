{"remainingRequest":"/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/jonny/Documents/Work/test/src/views/Practise.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/jonny/Documents/Work/test/src/views/Practise.vue","mtime":1592193186813},{"path":"/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/vuetify-loader/lib/loader.js","mtime":1574476662000},{"path":"/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vY29tcG9uZW50cy9IZWFkZXInCgppbXBvcnQgeyBjb2RlbWlycm9yIH0gZnJvbSAndnVlLWNvZGVtaXJyb3InCiAKLy8gcmVxdWlyZSBzdHlsZXMKaW1wb3J0ICdjb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmNzcycKICAgaW1wb3J0IHsKICAgIFNvdXJjZURhdGFSZXBsYWNlZm9yRWFzeVBhcnNpbmcKfSBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvZnVuY3Rpb25zJwppbXBvcnQgKiBhcyBUeXBlQ2hlY2sgZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL1R5cGVDaGVja2luZycKaW1wb3J0ICogYXMgQWR2YW5jZWRUeXBlQ2hlY2sgZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL0FkdmFuY2VkVHlwZUNoZWNraW5nJwppbXBvcnQgKiBhcyBCdWlsZE9wZXJhdGlvbiBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvQnVpbGRPcGVyYXRpb25zJwppbXBvcnQgewogICAgUHVzaEFycmF5LAogICAgUHVzaENhbGN1bGF0aW9uLAogICAgUHVzaENvbmRpdGlvbmFsS2V5d29yZCwKICAgIFB1c2hDb25kaXRpb24sCiAgICBQdXNoRm9yTG9vcCwKICAgIFB1c2hXaGlsZUxvb3AsCiAgICBQdXNoV2hpbGVMb29wQ29uZGl0aW9uLAogICAgUHVzaEZvckxvb3BBcnVndW1lbnRzLAogICAgUHVzaEV4cHJlc3Npb24sCiAgICBQdXNoS2V5d29yZCwKICAgIFB1c2hOdW1iZXIsCiAgICBQdXNoT3BlcmF0b3IsCiAgICBQdXNoUmVhbFRpbWVQcmludE9wZXJhdGlvbiwKICAgIFB1c2hTdHJpbmcsCiAgICBQdXNoU3RyaW5nYW5kVmFsdWVPcGVyYXRpb24sCiAgICBQdXNoVmFyaWFibGUsCiAgICBQdXNoVmFyaWFibGVWYWx1ZSwKICAgIFB1c2hGdW5jdGlvbkRhdGEsCiAgICBQdXNoRnVuY3Rpb25FeGVjdXRpb24sCiAgICBQdXNoVG9BcnJheSwKICAgIFB1c2hJbnB1dAoKfSBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvUHVzaEZ1bmN0aW9ucycKaW1wb3J0IHsKICAgIFJlbW92ZUJyYWNrZXRzLAogICAgQ291bnQsCiAgICBSZXNldFZhbHVlLAogICAgaXNBcnJheU9wZXJhdGlvbiwKICAgIENyZWF0ZUFycmF5RWxlbWVudCwKICAgIENhbGN1bGF0ZVZhbHVlcywKICAgIEdldEFycmF5b3JTdHJpbmdFbGVtZW50LAogICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQsCiAgICBQcmludEFycmF5RWxlbWVudCwKICAgIGhhbmRsZW11bHRDb25kaXRpb25zLAogICAgSGFuZGxlQmxvY2tzLAogICAgU3BsaXRFbGVtZW50c0FycmF5LAogICAgU2V0VmFsdWVzLAogICAgUHVzaFNldEFycmF5SW5kZXhWYWx1ZSwKICAgIFB1c2hHZXRBcnJheUluZGV4VmFsdWUsCiAgICBVcGRhdGVVcGRhdGVkX3Rva2Vuc3dpdGhWYWx1ZXMsCiAgICBHZXRDb25kaXRpb25WYWx1ZSwKICAgIEZvckxvb3BBcnJheW9yU3RyaW5nT3V0cHV0LAogICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMsCiAgICBIYW5kbGVDb25kaXRpb25zLAogICAgZ2V0TG9vcEluZGV4U3RhcnQsCiAgICBGb3JMb29wU2V0TWV0YWRhdGEsCiAgICBTZXRBcnJheUluZGV4VmFsdWUKfSBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvTWlzY0ltcG9ydGFudEZ1bmN0aW9ucycKCmltcG9ydCB7IG1hcFN0YXRlIH0gZnJvbSAndnVleCcKCgoKZXhwb3J0IGRlZmF1bHQgewogICAgbmFtZTogIkhlbGxvV29ybGQiLAogICAgcHJvcHM6IHsKICAgICAgICBtc2c6IFN0cmluZwogICAgfSwKCiAgIAogICAgICBjb21wdXRlZDogbWFwU3RhdGUoWydDdXJyZW50Q29kZSddKSwKCgogICAgZGF0YSgpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBjb2RlOicnLApDb2RlaW51c2U6JycsCiAgICAgICAgICAgCiAKICAgICAgICAgICAgb3V0cHV0OiAnJywKICAgICAgICAgICAgY206JycsCiAgICAgICAgICAgIGVycm9yOiBbXSwKICAgICAgICAgICAgT3BlcmF0aW9uT2JqZWN0czogW10sCiAgICAgICAgICAgIGxpbmVieWxpbmVPdXRwdXQ6ICcnLAogICAgICAgICAgICBUaW1lVGFrZW46ICcnLAogICAgICAgICAgICBpbnB1dEluZGV4ZXM6IFtdLAogICAgICAgICAgICBpbnB1dDogJycsCiAgICAgICAgICAgIGlzRXJyb3I6JycsCiAgICAgICAgICAgIExhc3RDb25kaXRpb25WYWx1ZTpbXSwKICAgICAgICAgICAgTGluZUJ5TGluZUNvZGU6W10sCiAgICAgICAgICAgIGNtT3B0aW9uczogewogICAgICAgIC8vIGNvZGVtaXJyb3Igb3B0aW9ucwogICAgICAgIHRhYlNpemU6IDQsCiAgICAgICAgbGluZU51bWJlcnM6IHRydWUsCiAgICAgICAgbGluZTogdHJ1ZSwKICAgICAgICB0aGVtZTonJwogICAgICB9CgogICAgICAgIH07CiAgICB9LAogICAgICBjb21wb25lbnRzOiB7CiAgICBjb2RlbWlycm9yLAogICAgSGVhZGVyCiAgfSwKCiBtb3VudGVkKCkgewogICAgY29uc29sZS5sb2coJ3RoaXMgaXMgY3VycmVudCBjb2RlbWlycm9yIG9iamVjdCcsIHRoaXMuY29kZW1pcnJvcikKICAgIC8vIHlvdSBjYW4gdXNlIHRoaXMuY29kZW1pcnJvciB0byBkbyBzb21ldGhpbmcuLi4KICB9LAoKICAgIGNyZWF0ZWQoKXsKCgoKbGV0IG09dGhpcy4kc3RvcmUuc3RhdGUuQ3VycmVudENvZGUucmVwbGFjZSgnJmx0OycsJzwnKQptPW0ucmVwbGFjZSgnJmd0OycsJz4nKQp0aGlzLmNvZGU9bQoKCgovKgp0aGlzLkNvZGVpbnVzZT1tCgoKaWYodGhpcy5jb2RlLmxlbmd0aD4wKQp7Cgp0aGlzLkxpbmVCeUxpbmVDb2RlPXRoaXMuY29kZS5zcGxpdCgiXG4iKQoKdGhpcy5MaW5lQnlMaW5lQ29kZS5mb3JFYWNoKChlbCxpbmRleCk9PnsKICAgIAoKCmVsPSAoaW5kZXgrMSkgKyAnICAnICsgZWwKCnRoaXMuTGluZUJ5TGluZUNvZGVbaW5kZXhdPWVsICsgJ1xuJwoKCn0pCgogCiB0aGlzLkxpbmVCeUxpbmVDb2RlPXRoaXMuTGluZUJ5TGluZUNvZGUuam9pbignXG4nKQoKIHRoaXMuY29kZT10aGlzLkxpbmVCeUxpbmVDb2RlCgp9CiAKKi8KCiAgICB9LAoKICAgIG1ldGhvZHM6IHsKCgogb25DbVJlYWR5KGNtKSB7CiAgICAgIGNvbnNvbGUubG9nKCd0aGUgZWRpdG9yIGlzIHJlYWRpZWQhJywgY20pCgogICAgIAoKdGhpcy5jbT1jbTsKCmlmKHNjcmVlbi53aWR0aDw0MjApCnsKCiB0aGlzLmNtLnNldFNpemUoJzEwMCUnLCAzMDApOwoKfQplbHNlewoKIHRoaXMuY20uc2V0U2l6ZSgnMTAwJScsIDUwMCk7Cn0KCgogICAgfSwKICAgIG9uQ21Gb2N1cyhjbSkgewogICAgCgoKICAgICAgLy90aGlzLmNtPWNtCiAgICB9LAogICAgb25DbUNvZGVDaGFuZ2UobmV3Q29kZSkgewogICAgICAvL2NvbnNvbGUubG9nKCd0aGlzIGlzIG5ldyBjb2RlJywgbmV3Q29kZSkKICAgICAgdGhpcy5jb2RlID0gbmV3Q29kZQogICAgfSwKCkFkZDpmdW5jdGlvbihpbnNlcnQpCgp7Cgp2YXIgZG9jID0gdGhpcy5jbS5nZXREb2MoKTsKCiAgICB2YXIgY3Vyc29yID0gZG9jLmdldEN1cnNvcigpOwogICAgZG9jLnJlcGxhY2VSYW5nZShpbnNlcnQsIGN1cnNvcik7CiAKCgoKfQosCiAgICAgICAgUlVOOiBmdW5jdGlvbigpIHsKCgoKICAgICAgICAgICAgICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpCgogICAgICAgICAgICAgICAgdGhpcy5pc0Vycm9yPWZhbHNlCgogICAgICAgICAgICAgICAgLy90byBzdG9wIGFjY3VtdWxhdGluZyBvdXRwdXQgb24gc3VjY2VzaXZlIFJVTgogICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSAnJwogICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9ICcnLAogICAgICAgICAgICAgICAgICAgIHRoaXMubGluZWJ5bGluZU91dHB1dCA9IHRoaXMub3V0cHV0LnNwbGl0KCJcbiIpCiAgICAgICAgICAgICAgICB0aGlzLmlucHV0SW5kZXhlcyA9IFtdCiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gW10KICAgICAgICAgICAgICAgIHRoaXMuT3BlcmF0aW9uT2JqZWN0cyA9IFtdCiAgICAgICAgICAgICAgICB2YXIgc291cmNlZGF0YSA9IHRoaXMuY29kZTsKICAgICAgICAgICAgICAgIHZhciBjbGVhbmVkX3NvdXJjZWRhdGEgPSBbXQogICAgICAgICAgICAgICAgdmFyIGkgPSAwOwogICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IFtdOwogICAgICAgICAgICAgICAgdmFyIG1peGVkaW1wdXJpdHkgPSBbXQogICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRfdG9rZW5zID0gW10KICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbkNvbnRleHR1cGRhdGVkX3Rva2VucyA9IFtdCiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVzX2FycmF5ID0gW10KICAgICAgICAgICAgICAgIHZhciBhc3NpZ25lZF92YXJpYWJsZXMgPSBbXQogICAgICAgICAgICAgICAgdmFyIHRlcm1zID0gW10KICAgICAgICAgICAgICAgIHZhciB0ZXJtczIgPSBbXQogICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9ICcnCiAgICAgICAgICAgICAgICB2YXIgQ2FsY3VsYXRpb25TdGFjayA9IFtdCiAgICAgICAgICAgICAgICB2YXIgZm91bmRUb2tlbiA9ICcnCiAgICAgICAgICAgICAgICB2YXIgUmVJbnRpYWxpemVkVmFyaWFibGVzID0gW10KICAgICAgICAgICAgICAgIHZhciB0ZW1wdGhpcz10aGlzCgogICAgICAgICAgICAgICAgLy9lbXB0eWluZyBhY2N1bXVsYXRlZHZhbHVlIHN0b3JlZCBmb3Igb3BlcmF0aW9ucyBsaWtlIE5hbWU9IE5hbWUrQXJyYXlbaV0KICAgICAgICAgICAgICAgIC8vU2VlIEFzc2lnbm9yVXBkYXRlVmFsdWVzIGZ1Y3Rpb24gZm9yIG1vcmUKICAgICAgICAgICAgICAgIFJlc2V0VmFsdWUoKQoKCiAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEFkZE91dHB1dCh0ZW1wdGhpcyx2YWx1ZSkKICAgICAgICAgICAgICAgIHsKCgoKICAgICAgICAgICAgICAgIHRlbXB0aGlzLm91dHB1dCA9IHRlbXB0aGlzLm91dHB1dCArIHZhbHVlICsgIlxuIjsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIC8vcHJlcGFyaW5nIHNvdXJjZWRhdGEgZm9yIGVhc3kgcGFyc2luZyBieSBoYW5kbGluZyBuZXcgbGluZXMsIGVudGVycyBldGMuCiAgICAgICAgICAgICAgICAvL2NsZWFuaW5nIHVwIHRoZSBkYXRhIHRvIGdldCBteSB2ZXJzaW9uIG9mIHNvdXJjZWRhdGEuIGl0J3MgYmV0dGVyIHRvIGdldCB2ZXJzaW9uIHN1aXRhYmxlIGZvciBtZSBiZWNhdXNlIHVzZXJzIGNhbiB0eXBlIHdoYXQgdGhleSB3aXNoIGJ1dCBJIG5lZWQgdG8gbWFpbnRhaW4gCiAgICAgICAgICAgICAgICAvL2ludGVncml0eSBvZiBwcm9ncmFtIGluIGV2ZXJ5IHBvc3NpYmxlIGNvbmRpdGlvLiBTby4gSSBjcmVhdGVkIG15IG93biBjb25kaXRpb24gYmVsb3cKCiAgICAgICAgICAgICAgICBmdW5jdGlvbiBHZXRDbGVhblNvdXJjZWRhdGEoc291cmNlZGF0YSwgY2xlYW5lZF9zb3VyY2VkYXRhLCBpbXB1cml0aWVzKSB7CgogICAgICAgICAgICAgICAgICAgIHNvdXJjZWRhdGEgPSBTb3VyY2VEYXRhUmVwbGFjZWZvckVhc3lQYXJzaW5nKHNvdXJjZWRhdGEpCgogICAgICAgICAgICAgICAgICAgIHNvdXJjZWRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4gewoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmluZGluZyB0aGUgZWxlbWVudHMgd2hpY2ggaGFzID0iIGluIGl0IHNvIHRoYXQgdG8gc2VwcmF0ZSB0aGVtIGUuZy4gYW5uYT0ic3dhbmFuZCIgYWxzbyBmaW5kaW5nIHRoZSBlbGVtZW50cyB3aGljaCBzdGFydHMgd2l0aCA9LiBlLmcgIj03ODc4Nzg5MCIKCgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmluY2x1ZGVzKCc9PScpICYmIChlbGVtZW50LmluZGV4T2YoJz0iJykgPiAtMSB8fCBlbGVtZW50LmluZGV4T2YoJz0nKSA+IDAgfHwgZWxlbWVudC5jaGFyQXQoMCkgPT0gIj0iKSAmJiBlbGVtZW50ICE9ICc9PScpCgoKICAgICAgICAgICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdGllcy5wdXNoKGVsZW1lbnQpIC8vcHVzaCBzdWNoIGVsZW1lbnQgYXMgaW1wdXJpdHkgaW4gaW1wdXJpdGllcwoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gZWxlbWVudC5zcGxpdCgiPSIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YVtpbmRleF0gPSAoZWxlbWVudHNbMF0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGFbaW5kZXggKyAxXSA9ICgiPSIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGFbaW5kZXggKyAyXSA9IChlbGVtZW50c1sxXSkKCgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXMgbG9uZyBhcyBlbGVtZW50IGlzIHB1cmUsIHB1c2ggaXQgdG8gbmV3IGFuZCBjbGVhbiB2ZXJzaW9uIG9mIHNvdXJjZWRhdGEKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXB1cml0aWVzLmluY2x1ZGVzKGVsZW1lbnQpKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGEucHVzaChlbGVtZW50KQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZpbmcgZW1wdHkgIiIgdmFsdWVzIGZvciBmaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZWRhdGEKICAgICAgICAgICAgICAgICAgICAvL1NFQ1RJT04gRkluYWwgc291cmNlZGF0YSBjbGVhbmluZwoKICAgICAgICAgICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGEgPSBjbGVhbmVkX3NvdXJjZWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtICE9PSAiIgogICAgICAgICAgICAgICAgICAgIH0pCgoKCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuZWRfc291cmNlZGF0YTsKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIGxldCBSZXN1bHQgPSBHZXRDbGVhblNvdXJjZWRhdGEoc291cmNlZGF0YSwgY2xlYW5lZF9zb3VyY2VkYXRhLCBtaXhlZGltcHVyaXR5KQoKICAgICAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YSA9IFJlc3VsdAogICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NsZWFuZWRfc291cmNlZGF0YTogJywgY2xlYW5lZF9zb3VyY2VkYXRhKTsKCgoKCiAgICAgICAgICAgICAgICAvL1NFQ1RJT04gLSBDaGVja2luZyBmb3IgdHlwZSBvZiBjaGFyYWN0ZXJzCgoKICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFyaWFibGUgPSBUeXBlQ2hlY2suaXNWYXJpYWJsZSgpCiAgICAgICAgICAgICAgICBjb25zdCBpc051bWJlciA9IFR5cGVDaGVjay5pc051bWJlcigpCgogICAgICAgICAgICAgICAgY29uc3QgaXNPcGVyYXRvciA9IFR5cGVDaGVjay5pc09wZXJhdG9yKCkKCiAgICAgICAgICAgICAgICBjb25zdCBpc0tleXdvcmQgPSBUeXBlQ2hlY2suaXNLZXl3b3JkKCkKICAgICAgICAgICAgICAgIGNvbnN0IGlzQ29uZGl0aW9uYWxLZXl3b3JkID0gVHlwZUNoZWNrLmlzQ29uZGl0aW9uYWxLZXl3b3JkKCkKICAgICAgICAgICAgICAgIGNvbnN0IGlzRm9yTG9vcCA9IFR5cGVDaGVjay5pc0Zvckxvb3AoKQogICAgICAgICAgICAgICAgY29uc3QgaXNXaGlsZUxvb3AgPSBUeXBlQ2hlY2suaXNXaGlsZUxvb3AoKQogICAgICAgICAgICAgICAgY29uc3QgaXNGdW5jdGlvbiA9IFR5cGVDaGVjay5pc0Z1bmN0aW9uKCkKICAgICAgICAgICAgICAgIC8vbmVlZHMgd29yawogICAgICAgICAgICAgICAgY29uc3QgaXNFeHByZXNzaW9uID0gVHlwZUNoZWNrLmlzRXhwcmVzc2lvbigpCgogICAgICAgICAgICAgICAgY29uc3QgaXNBcnJheSA9IFR5cGVDaGVjay5pc0FycmF5KCkKICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5wdXQgPSBUeXBlQ2hlY2suaXNJbnB1dCgpCgogICAgICAgICAgICAgICAgY29uc3QgaXNTZXRBcnJheUluZGV4VmFsdWUgPSBUeXBlQ2hlY2suaXNTZXRBcnJheUluZGV4VmFsdWUoKQoKICAgICAgICAgICAgICAgIC8vIGNvbnN0IGlzRW1wdHlBcnJheUluaXQgPSBUeXBlQ2hlY2suaXNFbXB0eUFycmF5SW5pdCgpCgogICAgICAgICAgICAgICAgY29uc3QgaXNTdHJpbmcgPSBUeXBlQ2hlY2suaXNTdHJpbmcoKQogICAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eVN0cmluZ29yQ2hhciA9IFR5cGVDaGVjay5pc0VtcHR5U3RyaW5nb3JDaGFyKCkKCiAgICAgICAgICAgICAgICBjb25zdCBpc1B1cmVFdmFsID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNQdXJlRXZhbCgpCgogICAgICAgICAgICAgICAgLy9pZiBwYXJzZXIgZW5jb3VudGVycyBhbnl0aGluZyBsaWtlICgiIG9yICgsIHRoZW4gdGhhdCdzIGEgcmVhbHRpbWUgcHJpbnQuIAogICAgICAgICAgICAgICAgLy9idWlsZHN0cmluZyB3aWxsIGJlIGFwcGxpZWQgbm93IHRvIGNyZWF0ZSBhIHN0cmluZyBhbmQgcHVzaCBpdCBpbnRvIHRva2VucwoKICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhbFRpbWVQcmludE11bHRpcGxlU3RyaW5nID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoKQoKCgogICAgICAgICAgICAgICAgY29uc3QgaXNTdHJpbmdhbmRWYWx1ZSA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzU3RyaW5nYW5kVmFsdWUoKQoKICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2FsY3VsYXRpb24gPSBBZHZhbmNlZFR5cGVDaGVjay5pc0NhbGN1bGF0aW9uKCkKCiAgICAgICAgICAgICAgICBjb25zdCBpc0RpcmVjdFByaW50QXJpdGhtZXRpYyA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzRGlyZWN0UHJpbnRBcml0aG1ldGljKCkKCgoKCgogICAgICAgICAgICAgICAgLy9TRUNUSU9OIEJ1aWxkIE9wZXJhdGlvbnMgCgoKICAgICAgICAgICAgICAgIGNvbnN0IEJ1aWxkU3RyaW5nID0gQnVpbGRPcGVyYXRpb24uQnVpbGRTdHJpbmcoKQoKICAgICAgICAgICAgICAgIGNvbnN0IEJ1aWxkQXJyYXkgPSBCdWlsZE9wZXJhdGlvbi5CdWlsZEFycmF5KCkKCiAgICAgICAgICAgICAgICAvL3RoaXMgZnVuY3Rpb24gaXMgdGhlIGZpcnN0IHN0ZXAgdG8gaGFuZGxsZSBvcGVyYXRpb25zIGxpa2Ug4KSF4KSX4KSwIChhZ2VvbmU9PTEwICYmIEF2ZXJhZ2VBZ2U8MTAwMCAmJiBhZ2V0d28+MTAwIHx8IGFnZW9uZT09MTApIE9SIChhZ2VvbmU9PTEwICkKCgogICAgICAgICAgICAgICAgY29uc3QgQnVpbGRDb25kaXRpb24gPSBCdWlsZE9wZXJhdGlvbi5CdWlsZENvbmRpdGlvbigpCgoKCiAgICAgICAgICAgICAgICAvL1RoaXMgd2lsbCBydW4gZm9yIGV2ZXJ5IHByaW50IHN0YXRlbWVudCBlbmNvdW50ZXJlZCBpbiB0aGUgcHJvZ3JhbSwgbm90IGp1c3QgZm9yIGxvb3BzCgogICAgICAgICAgICAgICAgZnVuY3Rpb24gSWZUb2tlblByaW50KFRva2VucywgdXBkYXRlZF90b2tlbnMsIGosIGdsb2JhbCwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IpCgoKCgogICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gVG9rZW5zW2pdLnZhbHVlCiAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgdmFyIE5leHRUb2tlblZhbHVlID0gVG9rZW5zW2ogKyAxXS52YWx1ZQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIC8vTmV4dFRva2VuVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZS5yZXBsYWNlKCIrIiwgJyArICcpCiAgICAgICAgICAgICAgICAgICAgCgoKCgogICAgICAgICAgICAgICAgICAgIHZhciBTdHJpbmdWYXIgPSBbXQoKICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShiKSAmJiAhdmFyaWFibGVzX2FycmF5LmluY2x1ZGVzKGIpKSB7CgogICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNfYXJyYXkucHVzaChiKQogICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL1NFQ1RJT04gLSBPdXRwdXR0aW5nIHRoZSBjb2RlCiAgICAgICAgICAgICAgICAgICAgLy8gZmluZGluZyB0aGUgcmVsdmFudCB2YWx1ZSBhbmQgdGhlbiBvdXRwdXQgaXQgYXMgSFRNTAoKICAgICAgICAgICAgICAgICAgICAvL1RoaXMgbG9vcCBpcyBvbmx5IGZvciBwcmludGluZyBkaXJlY3QgdmFsdWVzIGxpa2UgcHJpbnQobmFtZSksIHByaW50KGFycmF5KQogICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLmZvckVhY2goKGVsLCBpKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwubmFtZSA9PSBiKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIGNhbGN1bGF0aW9ucyBsaWtlIHg9YWdlb25lK2FnZXR3bwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgd2UgaGF2ZSBhbHJlYWR5IGNhbHVjdWxhdGVkIHZhbHVlLCB1c2UgdGhhdCBvciBlbHNlIG1vdmUgZm9yd2FyZAoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3NpZ25lZF92YXJpYWJsZXMuaW5jbHVkZXMoZWwpfHxhc3NpZ25lZF92YXJpYWJsZXMuaW5jbHVkZXMoZWwubmFtZSkgKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWRkT3V0cHV0KGdsb2JhbCwgZWwudmFsdWUpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGVsLnZhbHVlKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBZGRPdXRwdXQoZ2xvYmFsLCBlbC52YWx1ZSkKCmFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsLm5hbWUpOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb3BlcmF0aW9ucyBsaWtlIGFnZT0yMDIwLTE5OTYKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1B1cmVFdmFsKGVsLnZhbHVlKSkgewoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dHB1cmUgPSBldmFsKGVsLnZhbHVlKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IG91dHB1dHB1cmUKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWRkT3V0cHV0KGdsb2JhbCwgZWwudmFsdWUpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbC5uYW1lKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb3BlcmF0aW9ucyBsaWtlIG5hbWU9InN3YW5hbmQga2FkYW0iLCB2YXJpYWJsZSBhc3NpZ25tZW50cyBhcyBzdHJpbmdzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHVyZUV2YWwoZWwudmFsdWUpICYmICFpc051bWJlcihlbC52YWx1ZSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGVsLm5hbWUuaW5jbHVkZXMoJ10nKSAmJiBlbC5uYW1lLmluY2x1ZGVzKCdbJykpKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVsLnR5cGU9PSdBcnJheScpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKaWYgKGVsLnZhbHVlLmluY2x1ZGVzKCdbJyk9PWZhbHNlKQoKewoKZWwudmFsdWU9J1snK2VsLnZhbHVlLnRvU3RyaW5nKCkrJ10nCgoKCn0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWRkT3V0cHV0KGdsb2JhbCwgZWwudmFsdWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAvLyB3b3JrIHRvIGJlIGNvbnRpbnVlZAogICAgICAgICAgICAgICAgICAgIH0pCgoKICAgICAgICAgICAgICAgICAgICAvL0FOQ0hPUiAtIENPTkRJVElPTiAyCiAgICAgICAgICAgICAgICAgICAgaWYgKFRva2Vuc1tqICsgMV0udHlwZSA9PSAnQXJyYXknKQoKCgoKICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAvL1RvIHJ1biBvbmx5IGlmIGl0ZXJhdG9yIGlzIHByZXNlbnQKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpcyBydW5zIG9uIGZvciBsb29wIC0gUHJpbnQoQXJyYXlbYV0pIGV0YwoKICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIHJ1bnMgb25seSBpZiBmb3IoaSkgYW5kIGluIHRoZSBsb29wLCBhcnJheVtpXSwgbm90IG9uIGFycmF5W3hdLiBJdGVyYXRvciBhbmQgaW5kZXggc2hvdWxkIGJlIHNhbWUKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvciAhPSB1bmRlZmluZWQgJiYgVG9rZW5zW2ogKyAxXS5JbmRleElucHV0ID09IE9yaWdpbmFsSXRlcmF0b3IpCgogICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZhbHVlOiAnLCBWYWx1ZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEFycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChWYWx1ZSwgaXRlcmF0b3IpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFkZE91dHB1dChnbG9iYWwsIG91dHB1dCkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goVG9rZW5zW2ogKyAxXSk7CgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpcyBydW5zIHRvIFByaW50KEFycmF5WzJdKSBsaWtlIHNwZWNpZmljIGFycmF5IHZhbHVlcwogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChUb2tlbnNbaisxXS5JbmRleElucHV0ICE9IE9yaWdpbmFsSXRlcmF0b3IpCiAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBWYWx1ZSA9IE5leHRUb2tlblZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEluZGV4VG9DaGFuZ2UgPSBUb2tlbnNbaiArIDFdLkluZGV4SW5wdXQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEFycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChWYWx1ZSwgSW5kZXhUb0NoYW5nZSkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBBcnJheUVsZW1lbnQucmVwbGFjZSgnXScsICcnKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgU3BsaXQgPSBlbGVtZW50LnNwbGl0KCdbJykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU3BsaXRbMV0uaW5jbHVkZXMoJy0nKSB8fCBTcGxpdFsxXS5pbmNsdWRlcygnKycpKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gQ2FsY3VsYXRlVmFsdWVzKFNwbGl0WzFdLCBqLCB1cGRhdGVkX3Rva2VucykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXRbMV0gPSBvdXRwdXQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykgKyAnXScKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBTcGxpdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ0FycmF5RWxlbWVudDogJywgQXJyYXlFbGVtZW50KTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsID0+IGVsLm5hbWUgPT0gU3BsaXRbMV0pCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IHVuZGVmaW5lZCAmJiBPcmlnaW5hbEl0ZXJhdG9yICE9IFNwbGl0WzFdKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0WzFdID0gdG9rZW4udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykgKyAnXScKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBTcGxpdAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBBcnJheUVsZW1lbnQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdBcnJheUVsZW1lbnQ6ICcsIEFycmF5RWxlbWVudCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBZGRPdXRwdXQoZ2xvYmFsLCBvdXRwdXQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ291dHB1dDogJywgb3V0cHV0KTsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgLy9wcmludGluZyBkaXJlY3QgbnVtYmVycyBhbmQgZGlyZWN0IGNhbGN1bHRpb25zIGxpa2UgcHJpbnQoMTApLCBwcmludCgxMCoxMCkKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJyAmJiAoaXNQdXJlRXZhbChSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSkpIHx8IGlzTnVtYmVyKFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkpKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgTmV4dFRva2VuVmFsdWU9UmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpCiAgICAgICAgICAgICAgICAgICAgICAgIAoKaWYoaXNOdW1iZXIoTmV4dFRva2VuVmFsdWUpICYmIFRva2Vuc1tqKzFdLnR5cGUhPSdDYWxjdWxhdGlvbicpCgoKewogICAKQWRkT3V0cHV0KGdsb2JhbCwgTmV4dFRva2VuVmFsdWUpCgp9CgplbHNlewoKCmxldCBhID0gZXZhbChOZXh0VG9rZW5WYWx1ZSkKY29uc29sZS5sb2coJ2E6ICcsIGEpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICBBZGRPdXRwdXQoZ2xvYmFsLCBhKQoKfQogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgLy9mb3JvcGVyYXRpb25zIGxpa2UgcHJpbnQoJ3lvdSBsaXZlLCB5b3UgbGVhcm4nKQogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFRva2Vuc1tqICsgMV0ubW9kZSA9PSAiUmVhbFRpbWVQcmludCIgJiYgIU5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCcrJykgJiYgIU5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCc9JykpCgogICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpCgogICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvIi9nLCAnJyk7CiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8nL2csICcnKTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWRkT3V0cHV0KGdsb2JhbCwgb3V0cHV0KyJcbiIpCgoKCiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL29wZXJhdGlvbnMgbGlrZSBwcmludChBZ2UgKyAnaXMgeW91bmcgYWdlJykKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChUb2tlbnNbaiArIDFdLm1vZGUgPT0gIlJlYWxUaW1lUHJpbnQiICYmIE5leHRUb2tlblZhbHVlLmluY2x1ZGVzKCcrJykpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBTcGxpdEVsZW1lbnRzQXJyYXkoTmV4dFRva2VuVmFsdWUpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdWYXIgPSBTZXRWYWx1ZXMoeCwgdXBkYXRlZF90b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdWYXIgPSBTdHJpbmdWYXIuam9pbignJykKICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3RyaW5nVmFyLnNwbGl0KCIrIikKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBTdHJpbmdWYXIuam9pbignICcpCiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IFJlbW92ZUJyYWNrZXRzKG91dHB1dCkKCiAgICAgICAgICAgICAgICAgICAgICAgIEFkZE91dHB1dChnbG9iYWwsIG91dHB1dCsiXG4iKQoKCgogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzQ2FsY3VsYXRpb24oUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSAmJiBUb2tlbnNbaiArIDFdLm1vZGUgIT0gIlJlYWxUaW1lUHJpbnQiKQogICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgewoKTmV4dFRva2VuVmFsdWU9UmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gQ2FsY3VsYXRlVmFsdWVzKE5leHRUb2tlblZhbHVlLCBqLCB1cGRhdGVkX3Rva2VucykKCiAgICAgICAgICAgICAgICAgICAgICAgIEFkZE91dHB1dChnbG9iYWwsIG91dHB1dCsiXG4iKQoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIAoKCgoKICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgLy9FTkQgT0YgRnVuY3Rpb25zIGFuZCBJbXBvcnRlZCBGdW5jdGlvbnMKCgoKICAgICAgICAgICAgICAgIC8vU0VDVElPTiAtIFBhcnNpbmcgU1RBUlRTIGhlcmUKCiAgICAgICAgICAgICAgICAvL1NFQ1RJT04gLSBDaGVja2luZyBlYWNoIHRva2VuIGFuZCBhZGRpbmcgdG8gdG9rZW5zIGFycmF5CgoKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbGV0IHZhcmlhYmxlQXJyYXkgPSBbXSAvL1RPIFJFTU9WRSBEVVBMSUNBVEUgVkFSSUFCTEVTLCBTRUUgNDgyCgogICAgICAgICAgICAgICAgZnVuY3Rpb24gUGFyc2UoY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSB7CgogICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY2xlYW5lZF9zb3VyY2VkYXRhW2ldOwoKCiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IFtdCgoKCgogICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkX3NvdXJjZWRhdGFbaSArIDFdID09ICc9JykgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaFZhcmlhYmxlKGVsZW1lbnQsIHRva2VucykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlQXJyYXkuaW5jbHVkZXMoZWxlbWVudCkpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IFVwZGF0ZUVsZW1lbnRWYWx1ZSA9IGVsZW1lbnQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSB0b2tlbnMuZmluZChlbCA9PiBlbC52YWx1ZSA9PSBlbGVtZW50KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSB0b2tlbnMuaW5kZXhPZih4KQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVJbnRpYWxpemVkVmFyaWFibGVzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90b2tlbnNbaW5kZXgrMl0udmFsdWU9IGNsZWFuZWRfc291cmNlZGF0YVtpKzJdCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVBcnJheS5wdXNoKGVsZW1lbnQpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0gPT0gJz0nKSB7CgoKY29uc29sZS5sb2coJ2VsZW1lbnQ6ICcsIGVsZW1lbnQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaFZhcmlhYmxlVmFsdWUoZWxlbWVudCwgdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIH0gCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIoZWxlbWVudCkgPT0gdHJ1ZSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaE51bWJlcihlbGVtZW50LCB0b2tlbnMpCgogICAgICAgICAgICAgICAgICAgIH0gCgogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNFbXB0eVN0cmluZ29yQ2hhcihlbGVtZW50KT09dHJ1ZSl7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtZW50Lmxlbmd0aD4xICYmIChlbGVtZW50LmNoYXJBdCgwKT09IicifHxlbGVtZW50LmNoYXJBdCgwKT09JyInKSl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgplbGVtZW50PWVsZW1lbnQucmVwbGFjZSgvWyciXSsvZywgJycpCgogICAgICAgIAoKICAgIH0KCiAgICBlbHNlewoKICAgICAgICBlbGVtZW50PSIgIgogICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgClB1c2hWYXJpYWJsZVZhbHVlKGVsZW1lbnQsdG9rZW5zKQoKCgoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW5wdXQoZWxlbWVudCkgPT0gdHJ1ZSkKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaElucHV0KGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKQoKCgoKICAgICAgICAgICAgICAgICAgICB9IAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT3BlcmF0b3IoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaE9wZXJhdG9yKGVsZW1lbnQsIHRva2VucykKCiAgICAgICAgICAgICAgICAgICAgfSAKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0tleXdvcmQoZWxlbWVudCkgPT0gdHJ1ZSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEtleXdvcmQoZWxlbWVudCwgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICB9IAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWxlbWVudCkgPT0gdHJ1ZSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEZ1bmN0aW9uRGF0YShlbGVtZW50LCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkKCiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGl0IGFjY3BldHMgQXJyeVsyYV0gYXMgaW5kZXggOiAKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KGVsZW1lbnQpID09IHRydWUpIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDEpID09ICddJykgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEFycmF5KGVsZW1lbnQsIHRva2VucykKCiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCdWlsdEFycmF5ID0gQnVpbGRBcnJheShlbGVtZW50LCBpLCBjbGVhbmVkX3NvdXJjZWRhdGEpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEFycmF5KEJ1aWx0QXJyYXksIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgLy9mb3IgTnVtYmVyc1thXT14CiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTZXRBcnJheUluZGV4VmFsdWUoZWxlbWVudCwgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSA9PSB0cnVlKSB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoU2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKTsKCgoKICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgLy9mb3IgeD1OdW1iZXJzW2FdCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTZXRBcnJheUluZGV4VmFsdWUoZWxlbWVudCwgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSA9PSBmYWxzZSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoR2V0QXJyYXlJbmRleFZhbHVlKGVsZW1lbnQsIHRva2VucywgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKQoKCgoKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNDb25kaXRpb25hbEtleXdvcmQoZWxlbWVudCkgPT0gdHJ1ZSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaGlsZUxvb3AoZWxlbWVudCkgPT0gdHJ1ZSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hXaGlsZUxvb3AoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoV2hpbGVMb29wQ29uZGl0aW9uKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaENvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50LCB0b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRjb25kaXRpb24gPSBCdWlsZENvbmRpdGlvbihlbGVtZW50LCBpLCBjbGVhbmVkX3NvdXJjZWRhdGEpCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmb3VuZGNvbmRpdGlvbjogJywgZm91bmRjb25kaXRpb24pOwoKCgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoQ29uZGl0aW9uKGZvdW5kY29uZGl0aW9uLCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgIH0gCgogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZWxlbWVudC5pbmNsdWRlcygn4KSq4KWB4KS2JykpCiAgICAKewoKICAgUHVzaFRvQXJyYXkoZWxlbWVudCwgdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRm9yTG9vcChlbGVtZW50KSA9PSB0cnVlKSB7CgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoRm9yTG9vcChlbGVtZW50LCB0b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hGb3JMb29wQXJ1Z3VtZW50cyhlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIHRva2VucykKCiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNsZWFuZWRfc291cmNlZGF0YVtpICsgMV0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGb3JMb29wSXRlcmF0b3InCgogICAgICAgICAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAgICAgfSAKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0NhbGN1bGF0aW9uKGVsZW1lbnQpID09IHRydWUpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9ICcnCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xlYW5lZF9zb3VyY2VkYXRhW2kgKyAxXSAhPSB1bmRlZmluZWQpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcGVyZm9ybSBsb25nIG9wZXJhdGlvbnMgbGlrZSBBdmVyYWdlQWdlPShhZ2VvbmUrYWdldHdvKS8yICsgKGFnZW9uZSthZ2V0d28pKjIKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaXNDYWxjdWxhdGlvbihjbGVhbmVkX3NvdXJjZWRhdGFbaV0pKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQgKyBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vUHVzaENhbGN1bGF0aW9uKGVsZW1lbnQsdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgLy8gIAogICAgICAgICAgICAgICAgICAgICAgICB0ZXJtcyA9IGVsZW1lbnQuc3BsaXQoJycpCgogICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92aW5nIHRoZSAiKCIiIGFuZCAiKSIKCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDbGVhbmVkRWxlbWVudCA9IFJlbW92ZUJyYWNrZXRzKGVsZW1lbnQpCgoKICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc3RvcCBwcmV2ZW50aW9uIG9mIGV4cHJlc3Npb25zIGxpa2UgaXMiKyBnZXR0aW5nIGFkZGVkIGFzIGEgY2FsY3VsYXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoQ2xlYW5lZEVsZW1lbnQuaW5jbHVkZXMoJyInKSkgJiYgZWxlbWVudC5jaGFyQXQoMCkgIT0gJy8nICYmIGVsZW1lbnQuY2hhckF0KDApICE9ICcqJyAmJiBlbGVtZW50LmNoYXJBdCgwKSAhPSAiJyIpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoQ2FsY3VsYXRpb24oZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIHByaW50KCJzd2FuYW5kIikuIFRoZSByZWFsdGltZXByaW50IG9wZXJhdGlvbnMKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlYWxUaW1lUHJpbnRNdWx0aXBsZVN0cmluZyhlbGVtZW50KSA9PSB0cnVlKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZFN0cmluZyA9ICcnCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgayA9IGkKICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdlbGVtZW50OiAnLCBlbGVtZW50KTsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbkVuZCA9IGVsZW1lbnQuY2hhckF0KGVsZW1lbnQubGVuZ3RoIC0gMSkgKyBlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDIpCgogICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb25kaXRpb25FbmQ6ICcsIGNvbmRpdGlvbkVuZCk7CgoKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWcgPSAwOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrOyBrIDwgY2xlYW5lZF9zb3VyY2VkYXRhLmxlbmd0aDsgaysrKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBjbGVhbmVkX3NvdXJjZWRhdGFba10KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb25FbmQgPSBlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDEpICsgZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGggLSAyKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygn4KSm4KWB4KS54KSw4KS+4KSTJykgfHwgZWxlbWVudC5pbmNsdWRlcygn4KSV4KS+4KSuJykgfHwgZWxlbWVudC5pbmNsdWRlcygn4KSF4KSo4KWN4KSv4KSl4KS+JykgfHwgZWxlbWVudC5pbmNsdWRlcygn4KSH4KSo4KSq4KWB4KSfJykgfHwgZWxlbWVudC5pbmNsdWRlcygn4KSq4KWB4KS2JykgfHwgZWxlbWVudC5pbmNsdWRlcygn4KSq4KWN4KSw4KS/4KSC4KSfJykgfHwgZWxlbWVudC5pbmNsdWRlcygn4KSF4KSX4KSwJykgfHwgY2xlYW5lZF9zb3VyY2VkYXRhW2sgKyAxXSA9PSAnPScgfHwgZWxlbWVudCA9PSAnfScpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm91bmRTdHJpbmc9Zm91bmRTdHJpbmcrICAnICcrIGNsZWFuZWRfc291cmNlZGF0YVtrXQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbkVuZCA9PSAnKSInKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdHJpbmcgPSBmb3VuZFN0cmluZyArICcgJyArIGNsZWFuZWRfc291cmNlZGF0YVtrXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWcgPT0gMSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFN0cmluZyA9IGZvdW5kU3RyaW5nICsgJyAnICsgY2xlYW5lZF9zb3VyY2VkYXRhW2tdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmbGFnID09IDApIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdHJpbmcgPSBjbGVhbmVkX3NvdXJjZWRhdGFba107CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSAxOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCghZm91bmRTdHJpbmcuaW5jbHVkZXMoIj4iKSkgJiYgKCFmb3VuZFN0cmluZy5pbmNsdWRlcygnLycpKSAmJiAoIWZvdW5kU3RyaW5nLmluY2x1ZGVzKCcqJykpICYmICghZm91bmRTdHJpbmcuaW5jbHVkZXMoJzwnKSkgJiYgKCFmb3VuZFN0cmluZy5pbmNsdWRlcygnPT0nKSkpCgoKICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZvdW5kU3RyaW5nOiAnLCBmb3VuZFN0cmluZyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoUmVhbFRpbWVQcmludE9wZXJhdGlvbihmb3VuZFN0cmluZywgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgIC8vc3RvcmluZyBvbmx5IHRoZSBzdHJpbmcgdmFsdWVzIHRvIHRva2VucyAoIG5vdCB0aGUgc3RyaW5ncyBpbiBwcmludCBzdGF0ZW1lbnRzKQogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKQogICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgewoKCmNvbnNvbGUubG9nKCdlbGVtZW50OiAnLCBlbGVtZW50KTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkU3RyaW5nID0gQnVpbGRTdHJpbmcoZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKQogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY2FsY3VsYXRlZFN0cmluZzogJywgY2FsY3VsYXRlZFN0cmluZyk7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRTdHJpbmcgPSBjYWxjdWxhdGVkU3RyaW5nLnJlcGxhY2UoL1snIl0rL2csICcnKQoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2FsY3VsYXRlZFN0cmluZy5pbmNsdWRlcygi4KSq4KWN4KSw4KS/4KSC4KSfIikpKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hTdHJpbmcoY2FsY3VsYXRlZFN0cmluZywgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAvL0ZvdW5kIFNvbHV0aW9uIHVzaW5nIHJlZ2V4cC0gcHJpbnQoYSkgd2l0aG91dCBzcGFjZSBpcyBnZXR0aW5nIGFjY2VwdGVkIGFzIGV4cHJlc3Npb24KICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXig/PS4qP+CkquCljeCksOCkv+CkguCknykoPz0uKlthLXpdKS8udGVzdChlbGVtZW50KSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEtleXdvcmQoZWxlbWVudC5zbGljZSgwLCA2KSwgdG9rZW5zKTsgLy9QdXNoaW5nIHByaW50IGtleXdvcmQgb25seQoKCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKGVsZW1lbnQuc2xpY2UoNiksIHRva2VucykgLy9QdXNoaW5nIHJlbWFpbmluZyBleHByZXNzaW9uIGxpa2UgKGEpLCAoZ2FnYWtzKSBldGMKICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAvL2Vycm9yIHByb25lIGNoYW5nZSBtYWRlIGhlcmUtIFB1c2hpbmcgZXhwcmVzc2lvbiBpbiBoZXJlCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHByZXNzaW9uKGVsZW1lbnQpID09IHRydWUgJiYgIWlzQ2FsY3VsYXRpb24oZWxlbWVudCkgJiYgIWVsZW1lbnQuaW5jbHVkZXMoJ1snKSAmJiAhZWxlbWVudC5pbmNsdWRlcygnXScpICYmICghaXNDb25kaXRpb25hbEtleXdvcmQoY2xlYW5lZF9zb3VyY2VkYXRhW2kgLSAxXSkpICYmIChjbGVhbmVkX3NvdXJjZWRhdGFbaSAtIDFdICE9ICfgpK7gpYcnICYmIGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0gIT0gJ+CkleCkvuCkricpKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IENoZWNrRnVuY3Rpb25FeHByZXNzaW9uID0gZWxlbWVudC5zcGxpdCgnKCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhc3NlZFZhbHVlcyA9IFJlbW92ZUJyYWNrZXRzKENoZWNrRnVuY3Rpb25FeHByZXNzaW9uWzFdKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkVmFsdWVzID0gcGFzc2VkVmFsdWVzLnNwbGl0KCcsJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHRva2Vucy5maW5kKGVsID0+IGVsLnZhbHVlID09IENoZWNrRnVuY3Rpb25FeHByZXNzaW9uWzBdKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRva2VuIT11bmRlZmluZWQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKClB1c2hGdW5jdGlvbkV4ZWN1dGlvbihlbGVtZW50LHRva2VucyxjbGVhbmVkX3NvdXJjZWRhdGEsaSxwYXNzZWRWYWx1ZXMpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXsKCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKGVsZW1lbnQsdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgoKICAgICAgICAgICAgICAgICAgICB9IAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwcmVzc2lvbihlbGVtZW50KSA9PSB0cnVlICYmIGVsZW1lbnQuaW5jbHVkZXMoJ1snKSAmJiBlbGVtZW50LmluY2x1ZGVzKCddJykpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hBcnJheShlbGVtZW50LCB0b2tlbnMpCgogICAgICAgICAgICAgICAgICAgIH0gCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzS2V5d29yZChlbGVtZW50KSAmJiAhaXNOdW1iZXIoZWxlbWVudCkgJiYgIWlzVmFyaWFibGUoZWxlbWVudCkgJiYgIWlzRXhwcmVzc2lvbihlbGVtZW50KSAmJiAhaXNPcGVyYXRvcihlbGVtZW50KSkKICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAvL0FOQ0hPUiAKICAgICAgICAgICAgICAgICAgICAgICAgLypIbmFkbGluZyBJbXB1cml0eSBlcnJvci1UaGUgbWFpbiBwcm9ibGVtIGlzIGZpZ3VyaW5nIG91dCBob3cgdG8gc29sdmUgIj03MDAwIiBsaWtlIHRoaW5ncwogICAgICAgICAgICAgICAgICAgIGluc3RlYWQgYXNraW5nIGRldmVsb3BlcnMgdG8gYWRkIHNwYWNlIG1hbnVhbGx5CiAgICAgICAgICAgICAgICAgICAgSGFuZGxpbmcgQWxwaGFudW1lcmljIHN0cmluZ3MgdG8gc29sdmUgaXNzdWVzIGxpa2UgJyBhbm5hPTIzNjI5MzQnCgogICAgICAgICAgICAgICAgICAgIGxldCBpbXB1cml0eSA9IGVsZW1lbnQuc3BsaXQoJz0nKQoKICAgICAgICAgICAgICAgICAgICBsZXQgZmluZFN0cmluZyA9IGltcHVyaXR5WzFdCgoKICAgICAgICAgICAgICAgICAgICAvL3RvIGFjY2VwdCBsb25nIG51bWJlcnMgaS5lIGE9NzQ5Mzc0NTkzNzQ1OTM3CgogICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGltcHVyaXR5WzBdKSAmJiBpc051bWJlcihpbXB1cml0eVsxXSkpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBpbXB1cml0eVsyXSA9IGltcHVyaXR5WzFdOwogICAgICAgICAgICAgICAgICAgICAgICBpbXB1cml0eVsxXSA9ICc9JzsKCiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL3RvIGFjY2VwdCBhPVNUUklORwogICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGltcHVyaXR5WzBdKSAmJiBpc1ZhcmlhYmxlKGltcHVyaXR5WzFdKSkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXR5WzJdID0gaW1wdXJpdHlbMV07CiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXR5WzFdID0gJz0nOwoKICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHkuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4gewoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoZWxlbWVudCkgPT0gdHJ1ZSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaFZhcmlhYmxlKGVsZW1lbnQsIHRva2VucykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb250aW51ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy8gQU5DSE9SIAoKICAgICAgICAgICAgICAgICAgICAgICAgLy9Jc3N1ZTogUmlnaHQgbm93LCBvbmx5IGlzTnVtYmVyIGlzIHJlc29sdmVkLCBhPSwgPTIzODI4cXcgYXJlbid0IHJlc29sdmVkLgogICAgICAgICAgICAgICAgICAgICAgICAvL1NvbHV0aW9uOiBXb3JrIG9uIGFsbCB0aGUgbW9kdWxlcwoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihlbGVtZW50KSA9PSB0cnVlKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hOdW1iZXIoZWxlbWVudCwgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy9BTkNIT1IgCiAgICAgICAgICAgICAgICAgICAgICAgIC8vWW91IG1pZ2h0IGhhdmUgdG8gcmVtb3ZlIHRoaXMgZXh0cmEgZmlsdGVycyBzaW5jZSB5b3UgYXJlIG9ubHkgd29ya2luZyBvbiBudW1iZXJzIChGdXR1cmUgSXNzdWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09wZXJhdG9yKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hPcGVyYXRvcihlbGVtZW50LCB0b2tlbikKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEtleXdvcmQoZWxlbWVudCkKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0V4cHJlc3Npb24oZWxlbWVudCkgPT0gdHJ1ZSkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoRXhwcmVzc2lvbihlbGVtZW50LCB0b2tlbnMpCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgIH0pCiAqLwoKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgfQoKCgoKCgoKCgoKCgoKICAgICAgICAgICAgICAgIC8vU0VDVElPTiAtIENoZWNraW5nIGVhY2ggdG9rZW4gYW5kIGFkZGluZyB0byB0b2tlbnMgYXJyYXkKICAgICAgICAgICAgICAgIC8vIFBBUlNJTkcgSU5JVElBVElPTgoKCiAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOyBpKyspIHsKCgogICAgICAgICAgICAgICAgICAgIFBhcnNlKGNsZWFuZWRfc291cmNlZGF0YSwgaSkKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL0FOQ0hPUiAKICAgICAgICAgICAgICAgIC8vQ0xFQU5JTkcgVVAgVEhFIFRPS0VOUyBBUlJBWQogICAgICAgICAgICAgICAgLy9SZW1vdmluZyB0b2tlbnMgd2l0aCB2YWx1ZSA9ICcnLCBJdCB3YXMgZ2VuZXJhdGVkIGR1ZSB0byAiIGNsZWFuZWRfc291cmNlZGF0YSA9IGNsZWFuZWRfc291cmNlZGF0YS5yZXBsYWNlKC8oO3xcbnxccikvZ20sICIgIikuc3BsaXQoJyAnKSIKICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5maWx0ZXIoZWwgPT4gZWwudmFsdWUgIT0gJycpCiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndG9rZW5zOiAnLCB0b2tlbnMpOwoKCgoKICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgIC8vU0VDVElPTiAtIFByaW50aW5nIE91dHB1dHMsIGNvbnNpZGVyaW5nIGNvbmRpdGlvbnMsIGZpbmRpbmcgdmFsdWVzIGluIHVwZGF0ZWRfdG9rZW5zCgoKCgogICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHsKCiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2tpbmcgZm9yIGFzc2lnbm1lbnQgb3BlcmF0b3JzCgoKICAgICAgICAgICAgICAgICAgICBsZXQgbXV0YWJsZV90b2tlbnMgPSB0b2tlbnMKICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZQogICAgICAgICAgICAgICAgICAgIGxldCB0b2tlblR5cGUgPSBtdXRhYmxlX3Rva2Vuc1tqXS50eXBlCgoKCiAgICAgICAgICAgICAgICAgICAgdmFyIFN0cmluZ1ZhciA9IFtdCgogICAgICAgICAgICAgICAgICAgIGxldCBWYXJXaXRob3V0YnJhY2tldHMgPSBSZW1vdmVCcmFja2V0cyhtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSkKCiAgICAgICAgICAgICAgICAgICAgVmFyV2l0aG91dGJyYWNrZXRzID0gVmFyV2l0aG91dGJyYWNrZXRzLnJlcGxhY2UoLyAvZywgJycpCgoKICAgICAgICAgICAgICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbal0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikKCgoKICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5SW5kZXhWYWx1ZShtdXRhYmxlX3Rva2VucyxqLGosdXBkYXRlZF90b2tlbnMsdG9rZW5zLE9yaWdpbmFsSXRlcmF0b3IsaXRlcmF0b3IpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSA9PSAnPScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgIAogICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKG11dGFibGVfdG9rZW5zLCBqLCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IsdGhpcykKCiAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICB9IAogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW5UeXBlPT0nUHVzaFRvQXJyYXknICkKICAgICAgICAgICAgICAgICAgICB7Cgp0b2tlbj10b2tlbi5yZXBsYWNlKCfgpKrgpYHgpLYnLCcnKQpsZXQgU3BsaXQ9dG9rZW4uc3BsaXQoJy4nKQpsZXQgQXJyYXlOYW1lPVNwbGl0WzBdCgpsZXQgRWxlbWVudD1SZW1vdmVCcmFja2V0cyhTcGxpdFsxXSkKY29uc29sZS5sb2coJ0VsZW1lbnQ6ICcsIEVsZW1lbnQpOwoKbGV0IEFycmF5VG9rZW49dXBkYXRlZF90b2tlbnMuZmluZChlbD0+ZWwubmFtZT09QXJyYXlOYW1lKQpjb25zb2xlLmxvZygnQXJyYXlUb2tlbjogJywgQXJyYXlUb2tlbik7CgpsZXQgRWxlbWVudHRvUHVzaD11cGRhdGVkX3Rva2Vucy5maW5kKGVsPT5lbC5uYW1lPT1FbGVtZW50KQoKY29uc29sZS5sb2coJ0VsZW1lbnR0b1B1c2g6ICcsIEVsZW1lbnR0b1B1c2gpOwoKaWYoRWxlbWVudHRvUHVzaD09dW5kZWZpbmVkKQp7CiBFbGVtZW50ID0gRWxlbWVudC5yZXBsYWNlKC8iL2csICIiKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50ID0gRWxlbWVudC5yZXBsYWNlKC8nL2csICIiKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCkVsZW1lbnR0b1B1c2g9RWxlbWVudAoKCn0KZWxzZXsKCgogICAgRWxlbWVudHRvUHVzaD1FbGVtZW50dG9QdXNoLnZhbHVlCn0KbGV0IEVsZW1lbnRJbmRleD11cGRhdGVkX3Rva2Vucy5pbmRleE9mKEFycmF5VG9rZW4pCmNvbnNvbGUubG9nKCdFbGVtZW50SW5kZXg6ICcsIEVsZW1lbnRJbmRleCk7CgoKbGV0IEFycmF5VmFsdWU9dXBkYXRlZF90b2tlbnMuZmluZChlbD0+ZWwubmFtZT09QXJyYXlOYW1lKS52YWx1ZQoKCgoKaWYoQXJyYXlWYWx1ZT09J1tdJykKewoKQXJyYXlWYWx1ZT0gQXJyYXlWYWx1ZS5zcGxpdCgnLCcpCgoKfQoKY29uc29sZS5sb2coJ0FycmF5VmFsdWU6ICcsIEFycmF5VmFsdWUpOwpBcnJheVZhbHVlLnB1c2goRWxlbWVudHRvUHVzaCkKQXJyYXlWYWx1ZT1BcnJheVZhbHVlLmZpbHRlcihlbD0+IGVsIT0nW10nKSAKY29uc29sZS5sb2coJ0FycmF5VmFsdWU6ICcsIEFycmF5VmFsdWUpOwoKdXBkYXRlZF90b2tlbnNbRWxlbWVudEluZGV4XS52YWx1ZT1BcnJheVZhbHVlCmNvbnNvbGUubG9nKCd1cGRhdGVkX3Rva2VuczogJywgdXBkYXRlZF90b2tlbnMpOwoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW49PSfgpIXgpKjgpY3gpK/gpKXgpL4nKQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2VucywgaiwgcmVzdWx0KQpsZXQgU3RhcnRvZkJsb2NrPSBtdXRhYmxlX3Rva2Vuc1tqKzFdLnN0YXJ0SW5kZXgKbGV0IEVuZG9mQmxvY2s9IG11dGFibGVfdG9rZW5zW2orMV0uRW5kSW5kZXgKCi8vbGV0IERvZXNBbnlUcnVlQ29uZGl0aW9uRXhpc3RzPSB0aGlzLkxhc3RDb25kaXRpb25WYWx1ZS5maW5kKGVsPT5lbD09dHJ1ZSkKCmxldCBsYXN0VmFsdWU9dGhpcy5MYXN0Q29uZGl0aW9uVmFsdWUucG9wKCkKCgoKCmlmKGxhc3RWYWx1ZT09dHJ1ZSkKCgp7CgoKaj1FbmRvZkJsb2NrCgoKfQoKCgoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuVHlwZSA9PSAnQWNjZXB0SW5wdXQnKSB7CgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgU2V0SW5wdXRWYWx1ZUFzID0gbXV0YWJsZV90b2tlbnNbal0uQWNjZXB0QXMKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZT1wcm9tcHQoJ0VudGVyIFZhbHVlIGZvciAnICsgU2V0SW5wdXRWYWx1ZUFzKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBTZXRJbnB1dFZhbHVlQXMsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KQoKCgogICAgICAgICAgICAgICAgICAgICAgIAoKCgoKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuVHlwZSA9PSAnZnVuY3Rpb24nKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnVuY3Rpb25Tb3VyY2VEYXRhID0gW10KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBqKzEsIGZ1bmN0aW9uU291cmNlRGF0YSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblNvdXJjZURhdGEgPSByZXN1bHQuU3RvcmVSZXN1bHQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblNvdXJjZURhdGEuZm9yRWFjaChlbD0+ewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5jb250ZXh0PSdmdW5jdGlvbicKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZV90b2tlbnNbal0uU291cmNlRGF0YT1mdW5jdGlvblNvdXJjZURhdGEKCgogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5UeXBlID09ICdmdW5jdGlvbkV4ZWN1dGlvbicpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tpbmcgaWYgZnVuY3Rpb24gaXMgaW52b2tlZCBzb21ld2hlcmUgbGF0ZXIgaW4gdGhlIHByb2dyYW0KCgoKICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmdW5jdGlvblNvdXJjZURhdGEgPSBbXQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ1bmN0aW9uTmFtZSA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhc3NlZFZhbHVlcyA9IG11dGFibGVfdG9rZW5zW2pdLnBhc3NlZFZhbHVlcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ1bmN0aW9uVG9rZW49bXV0YWJsZV90b2tlbnMuZmluZChlbD0+ZWwudmFsdWU9PWZ1bmN0aW9uTmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmdW5jdGlvbkFyZ3VtZW50cyA9IGZ1bmN0aW9uVG9rZW4uYXJndW1lbnRzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Tb3VyY2VEYXRhID0gZnVuY3Rpb25Ub2tlbi5Tb3VyY2VEYXRhCgogICAgICAgICAgICAgICAgICAgICAgICAgICAKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ3JlYXRpbmcgYSBzZXBlcmF0ZSBleGVjdXRpb24gY29udGV4dCBhbmQgc2V0dGluZyBmdWNudGlvbiBjb250ZXh0IG5hbWU6dmFsdWUgcGFpciBpbiAnZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMnCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkFyZ3VtZW50cy5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHBhc3NlZFZhbHVlc1tpbmRleF0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvIi9nLCAiIik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoLycvZywgIiIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZFZhbHVlc1tpbmRleF0gPSB2YWwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2luIHRoaXMgY29kZSB3ZSBhcmUgZmlsdGVyaW5nIG91dCBhcmd1bWVudHMgcGFzc2VkIGJhc2VkIG9uIHdoZXRoZXIgdGhleSBhbHJlYWR5IGV4aXN0IGluIHVwZGF0ZWQgdG9rZW5zIG9yIG5vdAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgRmluZEluVXBkYXRlZFRva2Vucz0gdXBkYXRlZF90b2tlbnMuZmluZChlbD0+ZWwubmFtZT09dmFsKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKLy9Gb3IgcGFzc2luZyBzYW1lIGFyZ3VtZW50IGFuZCBzYW1lIHZhbHVlIHRvIGZ1bmN0aW9uICBlLmcgZnVuY3Rpb24gZm9vIChmaWJvbmFjY2kpIGFuZCBmaWJvbmFjY2k9W10gaXMgYWxyZWFkeSBkZWNsYXJlZAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKEZpbmRJblVwZGF0ZWRUb2tlbnM9PXVuZGVmaW5lZCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgpmdW5jdGlvbkNvbnRleHR1cGRhdGVkX3Rva2Vucy5wdXNoKHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbCwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGogKyBpbmRleCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZhbHVlJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogJ0Z1bmN0aW9uRXhlY3V0aW9uQ29udGV4dCcKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Gb3IgcGFzc2luZyBkaWZmZXJlbnQgYXJndW1lbnQgYW5kIHZhbHVlIHRvIGZ1bmN0aW9uICBlLmcgZnVuY3Rpb24gZm9vIChhcnIpIGFuZCBhcnIgZG9lc24ndCBleGlzdCBhbnl3aGVyZSBpbiB0b2tlbnMuCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGVsIT1GaW5kSW5VcGRhdGVkVG9rZW5zLm5hbWUgJiYgRmluZEluVXBkYXRlZFRva2VucyE9dW5kZWZpbmVkKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMucHVzaCh7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbCwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBGaW5kSW5VcGRhdGVkVG9rZW5zLnZhbHVlLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiArIGluZGV4LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBGaW5kSW5VcGRhdGVkVG9rZW5zLnR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdGdW5jdGlvbkV4ZWN1dGlvbkNvbnRleHQnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbnRoZUVuZFNldFZhbHVldG86dmFsCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlewoKCmZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zLnB1c2goewoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWwsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiArIGluZGV4LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBGaW5kSW5VcGRhdGVkVG9rZW5zLnR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6ICdGdW5jdGlvbkV4ZWN1dGlvbkNvbnRleHQnLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbnRoZUVuZFNldFZhbHVldG86dmFsCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ29tcGxldGVUb2tlblZhbHVlTGlzdCA9IFsuLi51cGRhdGVkX3Rva2VucywgLi4uZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnNdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGZ1bmN0aW9uU291cmNlRGF0YS5sZW5ndGg7IGkrKykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWwgPSBmdW5jdGlvblNvdXJjZURhdGFbaV0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmdW5jdGlvblNvdXJjZURhdGEsQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaitpLDogJywgZnVuY3Rpb25Tb3VyY2VEYXRhLENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGoraSwpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWZUb2tlblByaW50KGZ1bmN0aW9uU291cmNlRGF0YSxDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpLCB0aGlzKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwudmFsdWUgPT0gJz0nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAKICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhmdW5jdGlvblNvdXJjZURhdGEsIGksIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yLHRoaXMpCgogICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC50eXBlID09ICdBY2NlcHRJbnB1dCcpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBTZXRJbnB1dFZhbHVlQXMgPWZ1bmN0aW9uU291cmNlRGF0YVtpXS5BY2NlcHRBcwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlPXByb21wdCgnRW50ZXIgVmFsdWUgZm9yJyArIFNldElucHV0VmFsdWVBcykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFNldElucHV0VmFsdWVBcywKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgoKCiAgICAgICAgICAgICAgICAgICAgICAgCgoKCgogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PSAnY29uZGl0aW9uJykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBmdW5jdGlvblNvdXJjZURhdGFbaV0udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBjYWxjdWxhdGUgdmFsdWUgb2Ygb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uVmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShlbGVtZW50LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkxhc3RDb25kaXRpb25WYWx1ZS5wdXNoKENvbmRpdGlvblZhbHVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29uc29sZS5sb2coJ2o6ICcsaik7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHZhbHVlIGlzIGZhbHNlLCBqdXN0IHNraXAgdGhlIGlmIGxvb3AgY29udGV4dCwgaWYgbm90IGl0IHdpbGwgYmUgcmFuIGluIGZpbmFsIHByaW50IG1vZHVsZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENvbmRpdGlvblZhbHVlID09IGZhbHNlKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEluaXRpYWxpemVMb29wID0gdG9rZW5zLmluZGV4T2YoZnVuY3Rpb25Tb3VyY2VEYXRhW2ldKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlIEJsb2NrcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGNhcmUgb2YgbmVzdGVkIGJsb2NrIGJ5IHRha2luZyBjYXJlIG9mIG5lc3RlZCB7IGFuZCB9IGJyYWNrZXRzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2l0IHVzZXMgdGhlIHN0YWNrIHRvIHB1c2ggYW5kIHBvcCBicmFja2V0cyB0byBhY2N1cmF0ZWx5IGlkZW50aWZ5IHN0YXJ0IGFuZCB0aGUgZW5kIG9mIHRoZSBibG9jawogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFJldHVybnZhbHVlID0gSGFuZGxlQmxvY2tzKGZ1bmN0aW9uU291cmNlRGF0YSwgaSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gUmV0dXJudmFsdWUuaQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9IYW5kbGluZyBzZXQgYXJyYXkgZWxlbWVudCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25Tb3VyY2VEYXRhW2ldLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5SW5kZXhWYWx1ZShmdW5jdGlvblNvdXJjZURhdGEsaSxqLENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsdG9rZW5zLE9yaWdpbmFsSXRlcmF0b3IsaXRlcmF0b3IpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25Tb3VyY2VEYXRhW2ldLnR5cGUgPT0gJ0Zvckxvb3BTdGFydCcpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEZsYWdQcmltYWxMb29wID0gMAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFNvdXJjZWRhdGFUb2tlbnMgPSBbXQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3VwZGF0ZWRfdG9rZW5zOiAnLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgRm9yTG9vcE1ldGFEYXRhID0gRm9yTG9vcFNldE1ldGFkYXRhKGZ1bmN0aW9uU291cmNlRGF0YSwgaSwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gRm9yTG9vcE1ldGFEYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ3ljbGUgPSBGb3JMb29wTWV0YURhdGEuQ3ljbGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE9yaWdpbmFsSXRlcmF0b3IgPSBGb3JMb29wTWV0YURhdGEuT3JpZ2luYWxJdGVyYXRvcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgSXRlcmF0aW9uU3RhcnQgPSBGb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gRm9yTG9vcE1ldGFEYXRhLml0ZXJhdG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gRm9yTG9vcE1ldGFEYXRhLmVsZW1lbnQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRWYWx1ZSA9IEZvckxvb3BNZXRhRGF0YS5lbGVtZW50VmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgZnVuY3Rpb25Tb3VyY2VEYXRhLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0YXJ0SW5kZXgsIGZ1bmN0aW9uU291cmNlRGF0YSwgY2hlY2ssIFN0b3JlUmVzdWx0OiAnLCBzdGFydEluZGV4LCBmdW5jdGlvblNvdXJjZURhdGEsIGNoZWNrLCBTdG9yZVJlc3VsdCk7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MoZnVuY3Rpb25Tb3VyY2VEYXRhLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gUmV0dXJudmFsdWUuU3RvcmVSZXN1bHQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQoZnVuY3Rpb25Tb3VyY2VEYXRhLCBpLCAneycsIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zID0gZ2V0U291cmNlZGF0YShGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQsIGZ1bmN0aW9uU291cmNlRGF0YSwgJ30nLCBTb3VyY2VkYXRhVG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnMuZm9yRWFjaChlbCA9PiB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuaXNOZXN0ZWRMb29wID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEZpbmROZXN0ZWRMb29wID0gU291cmNlZGF0YVRva2Vucy5maW5kKGVsID0+IGVsLnR5cGUgPT0gJ0Zvckxvb3BTdGFydCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChGaW5kTmVzdGVkTG9vcCAhPSB1bmRlZmluZWQpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmVzdGVkTG9vcGluZGV4ID0gU291cmNlZGF0YVRva2Vucy5pbmRleE9mKEZpbmROZXN0ZWRMb29wKSArIDIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBOZXN0ZWRMb29wbGVuZ3RoID0gKFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5FbmRJbmRleCAtIFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5zdGFydEluZGV4KSArIDEKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IE5lc3RlZExvb3BpbmRleDsgeCA8IE5lc3RlZExvb3BpbmRleCArIE5lc3RlZExvb3BsZW5ndGg7IHgrKykgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2Vuc1t4XS5pc05lc3RlZExvb3AgPSB0cnVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmluY2x1ZGVzKCcoJykgJiYgZWxlbWVudC5pbmNsdWRlcygnLCcpKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGbGFnUHJpbWFsTG9vcCA9IDEKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3ljbGU6ICcsIEN5Y2xlLEl0ZXJhdGlvblN0YXJ0KTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0l0ZXJhdGluZyBvdmVyIGZvcmxvb3Agc291cmNlZGF0YQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbGluZSAnaXRlcmF0b3IgPD0gQ3ljbGUnIGRldGVybWluZXMgc3RhcnQgb2YgdGhlIGxvb3AgYW5kIHRoZSBkdXJhdGlvbiBvZiB0aGUgbG9vcAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpdGVyYXRvciA9IEl0ZXJhdGlvblN0YXJ0OyBpdGVyYXRvciA8PSBDeWNsZTsgaXRlcmF0b3IrKykgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmxvb3BpbmRleCA9IENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QuZmluZChlbCA9PiBlbC5uYW1lID09IE9yaWdpbmFsSXRlcmF0b3IpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybG9vcGluZGV4LnZhbHVlID0gaXRlcmF0b3IKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdDb21wbGV0ZVRva2VuVmFsdWVMaXN0OiAnLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZsYWcgdG8gYXZvaWQgcnVubmluZyB0aGlzIGNvZGUgaWYgbG9vcCBpcyBwcmltYWwgYmVjYXVzZSB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBjb21wZWx0ZWx5IGRpZmZlcmVudAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZsYWdQcmltYWxMb29wID0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvckxvb3BBcnJheW9yU3RyaW5nT3V0cHV0KGVsZW1lbnRWYWx1ZSwgaXRlcmF0b3IsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIHRoaXMpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyBpKyspCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc05lc3RlZCA9IFNvdXJjZWRhdGFUb2tlbnNbaV0uaXNOZXN0ZWRMb29wCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gJ0Zvckxvb3BTdGFydCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRmxhZ1ByaW1hbExvb3AgPSAwCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkU291cmNlZGF0YVRva2VucyA9IFtdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmVzdGVkRm9yTG9vcE1ldGFEYXRhID0gRm9yTG9vcFNldE1ldGFkYXRhKFNvdXJjZWRhdGFUb2tlbnMsIGksIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29uc29sZS5sb2coJ05lc3RlZEZvckxvb3BNZXRhRGF0YTogJywgTmVzdGVkRm9yTG9vcE1ldGFEYXRhKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRDeWNsZSA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5DeWNsZSArIDEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuT3JpZ2luYWxJdGVyYXRvcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkSXRlcmF0aW9uU3RhcnQgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZGl0ZXJhdG9yID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkl0ZXJhdGlvblN0YXJ0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkZWxlbWVudCA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5lbGVtZW50CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRlbGVtZW50VmFsdWUgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuZWxlbWVudFZhbHVlCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U291cmNlZGF0YShzdGFydEluZGV4LCBTb3VyY2VkYXRhVG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdDogJywgc3RhcnRJbmRleCwgU291cmNlZGF0YVRva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhTb3VyY2VkYXRhVG9rZW5zLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gUmV0dXJudmFsdWUuU3RvcmVSZXN1bHQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQoU291cmNlZGF0YVRva2VucywgaSwgJ3snLCBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRTb3VyY2VkYXRhKE5lc3RlZEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgU291cmNlZGF0YVRva2VucywgJ30nLCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zOiAnLCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zKTsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoTmVzdGVkaXRlcmF0b3I7IE5lc3RlZGl0ZXJhdG9yIDwgTmVzdGVkQ3ljbGU7IE5lc3RlZGl0ZXJhdG9yKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSBOZXN0ZWRpdGVyYXRvcgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IE5lc3RlZGZvcmxvb3BpbmRleCA9IENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QuZmluZChlbCA9PiBlbC5uYW1lID09IE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm9ybG9vcGluZGV4OiAnLCBmb3Jsb29waW5kZXgpOwoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZGZvcmxvb3BpbmRleC52YWx1ZSA9IHkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgaW5kZXgrKykgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbCA9IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudmFsdWUgPT0gJ+CkquCljeCksOCkv+CkguCknycpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQoTmVzdGVkU291cmNlZGF0YVRva2VucywgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaW5kZXgsIHRoaXMsIHksIE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbC52YWx1ZSA9PSAnPScgJiYgZWwuaXNOZXN0ZWRMb29wID09IHRydWUpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hc3NpZ25pbmcgdmFsdWVzIHRvIHZhcmlhYmxlcwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCBpbmRleCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgeSwgTmVzdGVkT3JpZ2luYWxJdGVyYXRvcix0aGlzKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbC50eXBlID09ICdjb25kaXRpb24nICYmIGVsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2Vuc1tpXTogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uU3RhcnRJbmRleCA9IGluZGV4CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleF0udmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlQ29uZGl0aW9ucyBldmFsdWF0ZXMgY29uZGl0aW9uIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mIGZyb20gd2hlcmUgcHJpbnRpbmcgc2hvdWxkIHJlc3VtZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSBvZiBpIGRlcGVuZHMgb24gdGhlIGNvbmRpdGlvbnMKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uLmluY2x1ZGVzKCd8fCcpIHx8IGNvbmRpdGlvbi5pbmNsdWRlcygnJiYnKSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShjb25kaXRpb24sIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGluZGV4KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5MYXN0Q29uZGl0aW9uVmFsdWUucHVzaCh2YWx1ZSkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IGZhbHNlKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCbG9ja0xlbmd0aCA9IDAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJsb2NrU3RhcnQgPSAwCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleF0udmFsdWUgIT0gJ3snKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4ICsgMV0udmFsdWUgPT0gJ3snKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJsb2NrTGVuZ3RoID0gTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleCArIDFdLkVuZEluZGV4IC0gTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleCArIDFdLnN0YXJ0SW5kZXgKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBCbG9ja0xlbmd0aCArIGluZGV4ICsgMQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4ID0gSGFuZGxlQ29uZGl0aW9ucyhOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCBpbmRleCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ICE9IHVuZGVmaW5lZCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0geAoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gQ29uZGl0aW9uU3RhcnRJbmRleAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpOiAnLCBpKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpID0gaSArIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2k6ICcsIGkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiICYmIGVsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUoTmVzdGVkU291cmNlZGF0YVRva2VucyxpLGosQ29tcGxldGVUb2tlblZhbHVlTGlzdCx0b2tlbnMsT3JpZ2luYWxJdGVyYXRvcixpdGVyYXRvcikKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGU9PSAnQWNjZXB0SW5wdXQnICYmIGlzTmVzdGVkID09IGZhbHNlKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgU2V0SW5wdXRWYWx1ZUFzID1Tb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUuQWNjZXB0QXMKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU9cHJvbXB0KCdFbnRlciBWYWx1ZSBmb3InICsgU2V0SW5wdXRWYWx1ZUFzKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndmFsdWU6ICcsIHZhbHVlKTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogU2V0SW5wdXRWYWx1ZUFzLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgoKICAgICAgICAgICAgICAgICAgICAgICAKCgoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUgPT0gJz0nICYmIGlzTmVzdGVkID09IGZhbHNlKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoU291cmNlZGF0YVRva2VucywgaSwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IsdGhpcykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0hhbmRsaW5nIHByaW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIGlzTmVzdGVkID09IGZhbHNlKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3Igb3BlcmF0aW9ucyBsaWtlIHByaW50KGFycmF5WzNdKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZvciBsb29vcCBwcmludHM6ICcsIGZ1bmN0aW9uU291cmNlRGF0YVtpXSxpKTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQoU291cmNlZGF0YVRva2VucywgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaSwgdGhpcywgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxpbmcgc2V0IGFycmF5IGVsZW1lbnQgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNvdXJjZWRhdGFUb2tlbnNbaV0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKFNvdXJjZWRhdGFUb2tlbnMsaSxqLENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsdG9rZW5zLE9yaWdpbmFsSXRlcmF0b3IsaXRlcmF0b3IpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tpXS50eXBlID09ICdjb25kaXRpb24nKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnNbaV06ICcsIFNvdXJjZWRhdGFUb2tlbnNbaV0saSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uU3RhcnRJbmRleCA9IGkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbiA9IFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9IYW5kbGVDb25kaXRpb25zIGV2YWx1YXRlcyBjb25kaXRpb24gYW5kIHJldHVybiB0aGUgaW5kZXggb2YgZnJvbSB3aGVyZSBwcmludGluZyBzaG91bGQgcmVzdW1lCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb2YgaSBkZXBlbmRzIG9uIHRoZSBjb25kaXRpb25zCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uLmluY2x1ZGVzKCd8fCcpIHx8IGNvbmRpdGlvbi5pbmNsdWRlcygnJiYnKSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoY29uZGl0aW9uLCB1cGRhdGVkX3Rva2VucywgaSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTGFzdENvbmRpdGlvblZhbHVlLnB1c2godmFsdWUpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IGZhbHNlKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJsb2NrTGVuZ3RoID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCbG9ja1N0YXJ0ID0gMAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZSAhPSAneycpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2kgKyAxXS52YWx1ZSA9PSAneycpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJsb2NrTGVuZ3RoID0gU291cmNlZGF0YVRva2Vuc1tpICsgMV0uRW5kSW5kZXggLSBTb3VyY2VkYXRhVG9rZW5zW2kgKyAxXS5zdGFydEluZGV4CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IEJsb2NrTGVuZ3RoICsgaSArIDEKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gSGFuZGxlQ29uZGl0aW9ucyhTb3VyY2VkYXRhVG9rZW5zLCBpLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0KTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9IHVuZGVmaW5lZCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gQ29uZGl0aW9uU3RhcnRJbmRleAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2k6ICcsIGkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqOiAnLCBqKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpICsgU291cmNlZGF0YVRva2Vucy5sZW5ndGgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnajogJywgaik7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uU291cmNlRGF0YVtpXS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKClNldEFycmF5SW5kZXhWYWx1ZShTb3VyY2VkYXRhVG9rZW5zLGksaixDb21wbGV0ZVRva2VuVmFsdWVMaXN0LHRva2VucyxPcmlnaW5hbEl0ZXJhdG9yLGl0ZXJhdG9yKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuY3Rpb25Tb3VyY2VEYXRhW2ldLnR5cGUgPT0gJ1doaWxlTG9vcFN0YXJ0JykgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBUb2tlbnNDdXJyZW50SW5kZXggPSBpICsgMwoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uVmFsdWUgPSBmYWxzZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBmdW5jdGlvblNvdXJjZURhdGFbaSArIDFdLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgRXh0cmF0Y2VkVmFyaWFibGUgPSBbXQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhcmlhYmxlID0gJycKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgV2hpbGVMb29wU291cmNlZGF0YVRva2VucyA9IFtdCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBlbGVtZW50LmNoYXJBdChpKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZSh4KSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUgKyB4CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFyaWFibGUoZWxlbWVudC5jaGFyQXQoaSArIDEpKSAmJiBpc1ZhcmlhYmxlKHgpKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QuZmluZChlbCA9PiBlbC5uYW1lID09IHZhcmlhYmxlKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFeHRyYXRjZWRWYXJpYWJsZS5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGU6IHZhcmlhYmxlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gJycKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0V2hpbGVMb29wU291cmNlZGF0YShzdGFydEluZGV4LCBmdW5jdGlvblNvdXJjZURhdGEsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBIYW5kbGVCbG9ja3MoZnVuY3Rpb25Tb3VyY2VEYXRhLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCkKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdAoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChmdW5jdGlvblNvdXJjZURhdGEsIGksICd7JywgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBmdW5jdGlvblNvdXJjZURhdGEsICd9JywgV2hpbGVMb29wU291cmNlZGF0YVRva2VucykuU3RvcmVSZXN1bHQKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc3RhbnRseSBhY2Nlc3NpbmcgdGhlIGNvbmRpdGlvbnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoR2V0Q29uZGl0aW9uVmFsdWUoZWxlbWVudCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaiArIDEpKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgaSsrKSB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU0VDVElPTiB3aGlsZSBsb29wIGNvbnRleHQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUgPT0gJz0nKSB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBpLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGU9PSAnQWNjZXB0SW5wdXQnICkgewoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFNldElucHV0VmFsdWVBcyA9V2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS50eXBlLkFjY2VwdEFzCgoKCgogICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU9cHJvbXB0KCdFbnRlciBWYWx1ZSBmb3InICsgU2V0SW5wdXRWYWx1ZUFzKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndmFsdWU6ICcsIHZhbHVlKTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogU2V0SW5wdXRWYWx1ZUFzLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgoKICAgICAgICAgICAgICAgICAgICAgICAKCgoKCiAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsaW5nIENPTkRJVElPTkFMIHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gJ2NvbmRpdGlvbicpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IEhhbmRsZUNvbmRpdGlvbnMoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgaSwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpbmRleAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmVG9rZW5QcmludChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpLCB0aGlzKSAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogU2V0QXJyYXlJbmRleFZhbHVlKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsaSxqLENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsdG9rZW5zLE9yaWdpbmFsSXRlcmF0b3IsaXRlcmF0b3IpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaSArIDEgKyBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aCArIDEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgLy9za2lwcGluZyBwYXJzaW5nIGluZGV4IHNvIHRoYXQgZnVuY3Rpb24gY29udGV4dCBpcyBydW4gYnkgc2luZ2xlIGVudGl0eSBhbmQgZ2xvYmFsIGV4ZWN1dGlvbiBkb2Vzbid0IHJ1biB0aGlzIGNvZGUgdG9vCiAgICAgICAgICAgICAgICAgICAgICAvLyAgaiA9IG11dGFibGVfdG9rZW5zW2ogKyAxXS5FbmRJbmRleAoKCi8vSWYgd2UgcGFzcyBmdW5jdGlvbiBmb28oYXJyKSB3aGVyZSBhcnIgaXMgKHN1cHBvc2UpIGZpYm9uYWNjaT1bXSBkZWNsYXJlZCBpbiB0aGUgZ2xvYmFsIGV4ZSBjb250ZXh0KHVwZGF0ZWRfdG9rZW5zKS4gQnV0IG9wZXJhdGlvbiB3aWxsIGJlIHBlcmZvcm1lZCBvbgovL2FyciBpbiBmdW5jdGlvbkNvbnRleHR1cGRhdGVkX3Rva2Vucy4gc28gYXQgdGhlIGVuZCBvZiBmdWNudGlvbiBleGVjdXRpb24gd2Ugc2V0IHRoZSB2YWx1ZSB0byBpdCdzIHJpZ2h0IG93bmVyLgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW49ZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMuZmluZChlbD0+ZWwuSW50aGVFbmRTZXRWYWx1ZXRvIT0nJykKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEdpdmVQb3dlcnNUbz0gdXBkYXRlZF90b2tlbnMuZmluZChlbD0+ZWwubmFtZT09dG9rZW4uSW50aGVFbmRTZXRWYWx1ZXRvKQogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgR2l2ZVBvd2Vyc1RvLnZhbHVlPXRva2VuLnZhbHVlCgovL0kgaGF2ZSB0byBlbXB0eSBpdCBiZWNhdXNlIGZ1bmN0aW9uIGNvbnRleHQgaGFzIHRvIHJlbWFpbiBlbXB0eSBvdGhlciB3aXNlIGZ1bmN0aW9uIGFyZ3VtZW50cyB3aWxsIGtlZXAgb24gYWNjZXB0aW5nIG5ldyB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBrZXkKLy9mb3IgZS5nPSBQcmludEZ1bGxOYW1lKEZpcnN0TmFtZSxMYXN0TmFtZSkgYW5kIFByaW50RnVsbE5hbWUoRmlyc3ROYW0sTGFzdE5hbSkgbmVlZHMgdHdvIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dCBoZW5jZSBmaXJzdCBvbmUgbmVlZHMgdG8gbWFrZSBzcGFjZSBmb3IgbGF0ZXIKCiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zPVtdCgoKCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblR5cGUgPT0gJ2NvbmRpdGlvbicpCgogICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gbXV0YWJsZV90b2tlbnNbal0udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBjYWxjdWxhdGUgdmFsdWUgb2Ygb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uVmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShlbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaikKICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTGFzdENvbmRpdGlvblZhbHVlLnB1c2goQ29uZGl0aW9uVmFsdWUpCgogICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ29uZGl0aW9uVmFsdWU6ICcsIENvbmRpdGlvblZhbHVlKTsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdqOiAnLGopOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB2YWx1ZSBpcyBmYWxzZSwganVzdCBza2lwIHRoZSBpZiBsb29wIGNvbnRleHQsIGlmIG5vdCBpdCB3aWxsIGJlIHJhbiBpbiBmaW5hbCBwcmludCBtb2R1bGUKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDb25kaXRpb25WYWx1ZSA9PSBmYWxzZSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbml0aWFsaXplTG9vcCA9IHRva2Vucy5pbmRleE9mKG11dGFibGVfdG9rZW5zW2pdKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlIEJsb2NrcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGNhcmUgb2YgbmVzdGVkIGJsb2NrIGJ5IHRha2luZyBjYXJlIG9mIG5lc3RlZCB7IGFuZCB9IGJyYWNrZXRzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2l0IHVzZXMgdGhlIHN0YWNrIHRvIHB1c2ggYW5kIHBvcCBicmFja2V0cyB0byBhY2N1cmF0ZWx5IGlkZW50aWZ5IHN0YXJ0IGFuZCB0aGUgZW5kIG9mIHRoZSBibG9jawogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFJldHVybnZhbHVlID0gSGFuZGxlQmxvY2tzKG11dGFibGVfdG9rZW5zLCBqKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBSZXR1cm52YWx1ZS5qCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJyAmJiBtdXRhYmxlX3Rva2Vuc1tqXS5jb250ZXh0IT0nZnVuY3Rpb24nKQogICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQobXV0YWJsZV90b2tlbnMsIHVwZGF0ZWRfdG9rZW5zLCBqLCB0aGlzKSAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCgoKCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlblR5cGUgPT0gJ1doaWxlTG9vcFN0YXJ0JykgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBUb2tlbnNDdXJyZW50SW5kZXggPSBqICsgMwoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IENvbmRpdGlvblZhbHVlID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgRXh0cmF0Y2VkVmFyaWFibGUgPSBbXQoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhcmlhYmxlID0gJycKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gMAogICAgICAgICAgICAgICAgICAgICAgICBsZXQgV2hpbGVMb29wU291cmNlZGF0YVRva2VucyA9IFtdCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBlbGVtZW50LmNoYXJBdChpKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZSh4KSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUgKyB4CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFyaWFibGUoZWxlbWVudC5jaGFyQXQoaSArIDEpKSAmJiBpc1ZhcmlhYmxlKHgpKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZWwgPT4gZWwubmFtZSA9PSB2YXJpYWJsZSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXh0cmF0Y2VkVmFyaWFibGUucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlOiB2YXJpYWJsZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9ICcnCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFdoaWxlTG9vcFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgbXV0YWJsZV90b2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0CgoKCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KQogICAgICAgICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gZ2V0V2hpbGVMb29wU291cmNlZGF0YShXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgbXV0YWJsZV90b2tlbnMsICd9JywgV2hpbGVMb29wU291cmNlZGF0YVRva2VucykuU3RvcmVSZXN1bHQKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1doaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnM6ICcsIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMpOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdGFudGx5IGFjY2Vzc2luZyB0aGUgY29uZGl0aW9udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChHZXRDb25kaXRpb25WYWx1ZShlbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaiArIDEpKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgaSsrKSB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU0VDVElPTiB3aGlsZSBsb29wIGNvbnRleHQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUgPT0gJz0nKSB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBpLCB1cGRhdGVkX3Rva2VucykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGU9PSAnQWNjZXB0SW5wdXQnICkgewoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFNldElucHV0VmFsdWVBcyA9V2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS50eXBlLkFjY2VwdEFzCgoKCgogICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU9cHJvbXB0KCdFbnRlciBWYWx1ZSBmb3InICsgU2V0SW5wdXRWYWx1ZUFzKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndmFsdWU6ICcsIHZhbHVlKTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogU2V0SW5wdXRWYWx1ZUFzLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgoKICAgICAgICAgICAgICAgICAgICAgICAKCgoKCiAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsaW5nIENPTkRJVElPTkFMIHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gJ2NvbmRpdGlvbicpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IEhhbmRsZUNvbmRpdGlvbnMoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgaSwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpbmRleAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmVG9rZW5QcmludChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCB1cGRhdGVkX3Rva2VucywgaSwgdGhpcykgLy9mb3Igb3BlcmF0aW9ucyBsaWtlIHByaW50KGFycmF5WzNdKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKIFNldEFycmF5SW5kZXhWYWx1ZShXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLGksaix1cGRhdGVkX3Rva2Vucyx0b2tlbnMsT3JpZ2luYWxJdGVyYXRvcixpdGVyYXRvcikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHlwZSA9PSAnRm9yTG9vcFN0YXJ0JykKCgoKICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICB2YXIgRmxhZ1ByaW1hbExvb3AgPSAwCgogICAgICAgICAgICAgICAgICAgICAgICB2YXIgU291cmNlZGF0YVRva2VucyA9IFtdCgoKICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndXBkYXRlZF90b2tlbnM6ICcsIHVwZGF0ZWRfdG9rZW5zKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBGb3JMb29wTWV0YURhdGEgPSBGb3JMb29wU2V0TWV0YWRhdGEobXV0YWJsZV90b2tlbnMsIGosIHVwZGF0ZWRfdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Zvckxvb3BNZXRhRGF0YTogJywgRm9yTG9vcE1ldGFEYXRhKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBGb3JMb29wTWV0YURhdGEuRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDeWNsZSA9IEZvckxvb3BNZXRhRGF0YS5DeWNsZQogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE9yaWdpbmFsSXRlcmF0b3IgPSBGb3JMb29wTWV0YURhdGEuT3JpZ2luYWxJdGVyYXRvcgogICAgICAgICAgICAgICAgICAgICAgICB2YXIgSXRlcmF0aW9uU3RhcnQgPSBGb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gRm9yTG9vcE1ldGFEYXRhLml0ZXJhdG9yCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gRm9yTG9vcE1ldGFEYXRhLmVsZW1lbnQKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRWYWx1ZSA9IEZvckxvb3BNZXRhRGF0YS5lbGVtZW50VmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgbXV0YWJsZV90b2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3RhcnRJbmRleCwgbXV0YWJsZV90b2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdDogJywgc3RhcnRJbmRleCwgbXV0YWJsZV90b2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCk7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBSZXR1cm52YWx1ZS5TdG9yZVJlc3VsdAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmVSZXN1bHQKCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChtdXRhYmxlX3Rva2VucywgaiwgJ3snLCBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpCgogICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2VucyA9IGdldFNvdXJjZWRhdGEoRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBtdXRhYmxlX3Rva2VucywgJ30nLCBTb3VyY2VkYXRhVG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdTb3VyY2VkYXRhVG9rZW5zOiAnLCBTb3VyY2VkYXRhVG9rZW5zKTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2Vucy5mb3JFYWNoKGVsID0+IHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5pc05lc3RlZExvb3AgPSBmYWxzZQoKICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgRmluZE5lc3RlZExvb3AgPSBTb3VyY2VkYXRhVG9rZW5zLmZpbmQoZWwgPT4gZWwudHlwZSA9PSAnRm9yTG9vcFN0YXJ0JykKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmluZE5lc3RlZExvb3AgIT0gdW5kZWZpbmVkKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IE5lc3RlZExvb3BpbmRleCA9IFNvdXJjZWRhdGFUb2tlbnMuaW5kZXhPZihGaW5kTmVzdGVkTG9vcCkgKyAzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmVzdGVkTG9vcGxlbmd0aCA9IChTb3VyY2VkYXRhVG9rZW5zW05lc3RlZExvb3BpbmRleF0uRW5kSW5kZXggLSBTb3VyY2VkYXRhVG9rZW5zW05lc3RlZExvb3BpbmRleF0uc3RhcnRJbmRleCkgKyAyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gTmVzdGVkTG9vcGluZGV4OyB4IDwgTmVzdGVkTG9vcGluZGV4ICsgTmVzdGVkTG9vcGxlbmd0aDsgeCsrKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zW3hdLmlzTmVzdGVkTG9vcCA9IHRydWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5jbHVkZXMoJygnKSAmJiBlbGVtZW50LmluY2x1ZGVzKCcsJykpCgoKICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZsYWdQcmltYWxMb29wID0gMQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0N5Y2xlOiAnLCBDeWNsZSxJdGVyYXRpb25TdGFydCk7CgoKICAgICAgICAgICAgICAgICAgICAgICAgLy9JdGVyYXRpbmcgb3ZlciBmb3Jsb29wIHNvdXJjZWRhdGEKICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIGxpbmUgJ2l0ZXJhdG9yIDw9IEN5Y2xlJyBkZXRlcm1pbmVzIHN0YXJ0IG9mIHRoZSBsb29wIGFuZCB0aGUgZHVyYXRpb24gb2YgdGhlIGxvb3AKCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaXRlcmF0b3IgPSBJdGVyYXRpb25TdGFydDsgaXRlcmF0b3IgPD0gQ3ljbGU7IGl0ZXJhdG9yKyspIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3Jsb29waW5kZXggPSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsID0+IGVsLm5hbWUgPT0gT3JpZ2luYWxJdGVyYXRvcikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Jsb29waW5kZXgudmFsdWUgPSBpdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3VwZGF0ZWRfdG9rZW5zOiAnLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mbGFnIHRvIGF2b2lkIHJ1bm5pbmcgdGhpcyBjb2RlIGlmIGxvb3AgaXMgcHJpbWFsIGJlY2F1c2UgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgY29tcGVsdGVseSBkaWZmZXJlbnQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChGbGFnUHJpbWFsTG9vcCA9IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3JMb29wQXJyYXlvclN0cmluZ091dHB1dChlbGVtZW50VmFsdWUsIGl0ZXJhdG9yLCB1cGRhdGVkX3Rva2VucywgdGhpcykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IGkrKykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzTmVzdGVkID0gU291cmNlZGF0YVRva2Vuc1tpXS5pc05lc3RlZExvb3AKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gJ0Zvckxvb3BTdGFydCcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRmxhZ1ByaW1hbExvb3AgPSAwCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkU291cmNlZGF0YVRva2VucyA9IFtdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmVzdGVkRm9yTG9vcE1ldGFEYXRhID0gRm9yTG9vcFNldE1ldGFkYXRhKFNvdXJjZWRhdGFUb2tlbnMsIGksIHVwZGF0ZWRfdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdOZXN0ZWRGb3JMb29wTWV0YURhdGE6ICcsIE5lc3RlZEZvckxvb3BNZXRhRGF0YSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkQ3ljbGUgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuQ3ljbGUgKyAxCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLk9yaWdpbmFsSXRlcmF0b3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE5lc3RlZEl0ZXJhdGlvblN0YXJ0ID0gTmVzdGVkRm9yTG9vcE1ldGFEYXRhLkl0ZXJhdGlvblN0YXJ0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRpdGVyYXRvciA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5JdGVyYXRpb25TdGFydAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkZWxlbWVudCA9IE5lc3RlZEZvckxvb3BNZXRhRGF0YS5lbGVtZW50CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRlbGVtZW50VmFsdWUgPSBOZXN0ZWRGb3JMb29wTWV0YURhdGEuZWxlbWVudFZhbHVlCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U291cmNlZGF0YShzdGFydEluZGV4LCBTb3VyY2VkYXRhVG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdDogJywgc3RhcnRJbmRleCwgU291cmNlZGF0YVRva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhTb3VyY2VkYXRhVG9rZW5zLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JlUmVzdWx0ID0gUmV0dXJudmFsdWUuU3RvcmVSZXN1bHQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQoU291cmNlZGF0YVRva2VucywgaSwgJ3snLCBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ0Zvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydDogJywgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkU291cmNlZGF0YVRva2VucyA9IGdldFNvdXJjZWRhdGEoTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBTb3VyY2VkYXRhVG9rZW5zLCAnfScsIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ05lc3RlZFNvdXJjZWRhdGFUb2tlbnM6ICcsIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMpOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChOZXN0ZWRpdGVyYXRvcjsgTmVzdGVkaXRlcmF0b3IgPCBOZXN0ZWRDeWNsZTsgTmVzdGVkaXRlcmF0b3IrKykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IE5lc3RlZGl0ZXJhdG9yCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmVzdGVkZm9ybG9vcGluZGV4ID0gdXBkYXRlZF90b2tlbnMuZmluZChlbCA9PiBlbC5uYW1lID09IE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm9ybG9vcGluZGV4OiAnLCBmb3Jsb29waW5kZXgpOwoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lc3RlZGZvcmxvb3BpbmRleC52YWx1ZSA9IHkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgaW5kZXgrKykgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbCA9IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudmFsdWUgPT0gJ+CkquCljeCksOCkv+CkguCknycpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQoTmVzdGVkU291cmNlZGF0YVRva2VucywgdXBkYXRlZF90b2tlbnMsIGluZGV4LCB0aGlzLCB5LCBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudmFsdWUgPT0gJz0nICYmIGVsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXNzaWduaW5nIHZhbHVlcyB0byB2YXJpYWJsZXMKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoTmVzdGVkU291cmNlZGF0YVRva2VucywgaW5kZXgsIHVwZGF0ZWRfdG9rZW5zLCB5LCBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbC50eXBlID09ICdjb25kaXRpb24nICYmIGVsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2Vuc1tpXTogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uU3RhcnRJbmRleCA9IGluZGV4CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleF0udmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlQ29uZGl0aW9ucyBldmFsdWF0ZXMgY29uZGl0aW9uIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mIGZyb20gd2hlcmUgcHJpbnRpbmcgc2hvdWxkIHJlc3VtZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSBvZiBpIGRlcGVuZHMgb24gdGhlIGNvbmRpdGlvbnMKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShjb25kaXRpb24sIHVwZGF0ZWRfdG9rZW5zLCBpbmRleCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTGFzdENvbmRpdGlvblZhbHVlLnB1c2godmFsdWUpCgoKCmlmKHZhbHVlPT1mYWxzZSkKewoKICAgIGJyZWFrCgoKCgp9CgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIGlmICh2YWx1ZSA9PSBmYWxzZSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQmxvY2tMZW5ndGggPSAwCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCbG9ja1N0YXJ0ID0gMAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdLnZhbHVlICE9ICd7JykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleCArIDFdLnZhbHVlID09ICd7JykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCbG9ja0xlbmd0aCA9IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXggKyAxXS5FbmRJbmRleCAtIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXggKyAxXS5zdGFydEluZGV4CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gQmxvY2tMZW5ndGggKyBpbmRleCArIDEKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih2YWx1ZT09dHJ1ZSkgewoKCmNvbnNvbGUubG9nKGVsLE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsaW5kZXgpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgoqLwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpID0gaSArIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2k6ICcsIGkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiICYmIGVsLmlzTmVzdGVkTG9vcCA9PSB0cnVlKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheUluZGV4VmFsdWUoTmVzdGVkU291cmNlZGF0YVRva2VucyxpLGosdXBkYXRlZF90b2tlbnMsdG9rZW5zLE9yaWdpbmFsSXRlcmF0b3IsaXRlcmF0b3IpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlID09ICc9JyAmJiBpc05lc3RlZCA9PSBmYWxzZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXNzaWduaW5nIHZhbHVlcyB0byB2YXJpYWJsZXMKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoU291cmNlZGF0YVRva2VucywgaSwgdXBkYXRlZF90b2tlbnMsIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogZWxzZSBpZihTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGU9PSdQdXNoVG9BcnJheScpCiAKICAgICAgICAgICAgICAgICAgICB7CgpsZXQgdG9rZW49U291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZQoKdG9rZW49dG9rZW4ucmVwbGFjZSgn4KSq4KWB4KS2JywnJykKbGV0IFNwbGl0PXRva2VuLnNwbGl0KCcuJykKbGV0IEFycmF5PVNwbGl0WzBdCmxldCBFbGVtZW50dG9QdXNoPVJlbW92ZUJyYWNrZXRzKFNwbGl0WzFdKQpFbGVtZW50dG9QdXNoPXVwZGF0ZWRfdG9rZW5zLmZpbmQoZWw9PmVsLm5hbWU9PUVsZW1lbnR0b1B1c2gpLnZhbHVlCgpsZXQgQXJyYXlFbD11cGRhdGVkX3Rva2Vucy5maW5kKGVsPT5lbC5uYW1lPT1BcnJheSkKCgpsZXQgQXJyYXlWYWx1ZT1BcnJheUVsLnZhbHVlCmlmKEFycmF5VmFsdWU9PSdbXScpCnsKQXJyYXlWYWx1ZT0gQXJyYXlWYWx1ZS5zcGxpdCgnLCcpCn0KQXJyYXlWYWx1ZS5wdXNoKEVsZW1lbnR0b1B1c2gpCgoKbGV0IGluZGV4PXVwZGF0ZWRfdG9rZW5zLmluZGV4T2YoQXJyYXlFbCkKCkFycmF5VmFsdWU9QXJyYXlWYWx1ZS5maWx0ZXIoZWw9PiBlbCE9J1tdJykKCgoKCgoKCnVwZGF0ZWRfdG9rZW5zW2luZGV4XS52YWx1ZT1BcnJheVZhbHVlCiAKCgogICAgICAgICAgICAgICAgICAgIH0KCgogIGVsc2UgaWYgKFNvdXJjZWRhdGFUb2tlbnNbaV0udHlwZT09ICdBY2NlcHRJbnB1dCcgKSB7CgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgU2V0SW5wdXRWYWx1ZUFzID1Tb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUuQWNjZXB0QXMKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZT1wcm9tcHQoJ0VudGVyIFZhbHVlIGZvcicgKyBTZXRJbnB1dFZhbHVlQXMpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFNldElucHV0VmFsdWVBcywKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgoKCiAgICAgICAgICAgICAgICAgICAgICAgCgoKCgogICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0hhbmRsaW5nIHByaW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIGlzTmVzdGVkID09IGZhbHNlKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZm9yIGxvb29wIHByaW50czogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQoU291cmNlZGF0YVRva2VucywgdXBkYXRlZF90b2tlbnMsIGksIHRoaXMsIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0hhbmRsaW5nIHNldCBhcnJheSBlbGVtZW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlJbmRleFZhbHVlKFNvdXJjZWRhdGFUb2tlbnMsaSxqLHVwZGF0ZWRfdG9rZW5zLHRva2VucyxPcmlnaW5hbEl0ZXJhdG9yLGl0ZXJhdG9yKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tpXS50eXBlID09ICdjb25kaXRpb24nKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnNbaV06ICcsIFNvdXJjZWRhdGFUb2tlbnNbaV0saSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uU3RhcnRJbmRleCA9IGkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbiA9IFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9IYW5kbGVDb25kaXRpb25zIGV2YWx1YXRlcyBjb25kaXRpb24gYW5kIHJldHVybiB0aGUgaW5kZXggb2YgZnJvbSB3aGVyZSBwcmludGluZyBzaG91bGQgcmVzdW1lCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb2YgaSBkZXBlbmRzIG9uIHRoZSBjb25kaXRpb25zCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uLmluY2x1ZGVzKCd8fCcpIHx8IGNvbmRpdGlvbi5pbmNsdWRlcygnJiYnKSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoY29uZGl0aW9uLCB1cGRhdGVkX3Rva2VucywgaSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkxhc3RDb25kaXRpb25WYWx1ZS5wdXNoKHZhbHVlKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gZmFsc2UpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQmxvY2tMZW5ndGggPSAwCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJsb2NrU3RhcnQgPSAwCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlICE9ICd7JykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNvdXJjZWRhdGFUb2tlbnNbaSArIDFdLnZhbHVlID09ICd7JykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQmxvY2tMZW5ndGggPSBTb3VyY2VkYXRhVG9rZW5zW2kgKyAxXS5FbmRJbmRleCAtIFNvdXJjZWRhdGFUb2tlbnNbaSArIDFdLnN0YXJ0SW5kZXgKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gQmxvY2tMZW5ndGggKyBpICsgMQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKysKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBIYW5kbGVDb25kaXRpb25zKFNvdXJjZWRhdGFUb2tlbnMsIGksIHVwZGF0ZWRfdG9rZW5zKTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9IHVuZGVmaW5lZCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gQ29uZGl0aW9uU3RhcnRJbmRleAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2k6ICcsIGkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqOiAnLCBqKTsKCiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBqICsgU291cmNlZGF0YVRva2Vucy5sZW5ndGgKICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnajogJywgaik7CgoKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIC8vRU5EIEZPUiBMT09QIEVYRUNVVElPTgoKCgoKICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAKCgogLy9UbyBmaW5kIHVuZGVmaW5lZCB2YXJpYWJsZXMKICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAvLwoKCgoKZnVuY3Rpb24gb25seVVuaXF1ZSh2YWx1ZSwgaW5kZXgsIHNlbGYpIHsgCiAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7Cn0KCnZhciBhc3NpZ25lZF92YXJpYWJsZXM9YXNzaWduZWRfdmFyaWFibGVzLmZpbHRlcihvbmx5VW5pcXVlKQoKbGV0IGRpZmZlcmVuY2U9IHZhcmlhYmxlc19hcnJheS5maWx0ZXIoeD0+ICFhc3NpZ25lZF92YXJpYWJsZXMuaW5jbHVkZXMoeCkpCgogICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UubGVuZ3RoID4gMCkKCiAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgIGRpZmZlcmVuY2UuZm9yRWFjaChlbD0+ewoKCiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvci5wdXNoKCdWYXJpYWJsZSAnICsgZWwgKyAnIGlzIHVuZGVmaW5lZCAnKQoKCiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGlmKHRoaXMuZXJyb3IubGVuZ3RoPjApCiAgICAgICAgICAgICAgewoKdGhpcy5saW5lYnlsaW5lT3V0cHV0PXRoaXMuZXJyb3IKCgogICAgICAgICAgICAgIH0KCmVsc2V7CgogICAgICAgICAgICAgICAgdGhpcy5saW5lYnlsaW5lT3V0cHV0ID0gdGhpcy5vdXRwdXQuc3BsaXQoJ1xuJykKICAgICAgICAgICAgICAgIAp9CgoKCgp2YXIgdDEgPSBwZXJmb3JtYW5jZS5ub3coKQogICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZWJ5bGluZU91dHB1dCE9ICcnICYmIHRoaXMuZXJyb3IubGVuZ3RoPT0wKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5UaW1lVGFrZW4gPSAiQ29tcGlsZWQgU3VjY2VzZnVsbHkgaW4gIiArICh0MSAtIHQwKS50b1ByZWNpc2lvbig0KSArICIgbXMuIgoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBlbHNlewoKICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRXJyb3IgPSB0cnVlCgogICAgICAgICAgICAgICAgICAgIHRoaXMuVGltZVRha2VuID0gIkNvbXBpbGF0aW9uIEVycm9yOiBDaGVjayBmb3IgYXNzaWduZW1lbnQgYW5kIGRlY2xhcmF0aW9uIG1pc3R5cGluZyIgCgoKICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgdGhpcy5saW5lYnlsaW5lT3V0cHV0ID0gdGhpcy5saW5lYnlsaW5lT3V0cHV0LmZpbHRlcihmdW5jdGlvbihpdGVtKSB7CiAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtICE9PSAiIgogICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgLy9TRUNUSU9OIC0gQ2FsY3VsYXRpbmcgcmVtYWluaW5nIHZhbHVlcwoKCiAgICAgICAgICAgICAgICAvL3NvIHRoYXQgcmVwbGFjZSB4IHdpdGggdmFsdWVzCgogICAgICAgICAgICAgICAgLyoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLmZvckVhY2goKGVsLCBpKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsLnZhbHVlCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92aW5nIHRoZSAiKCIiIGFuZCAiKSIKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDbGVhbmVkRWxlbWVudCA9IFJlbW92ZUJyYWNrZXRzKGVsZW1lbnQpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9ICcnCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93aHkgcHVyZWV2YWw/CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9ucyBsaWtlIDUwKzYwIHdlcmUgc2V0IGFzIFs1LDAsKyw2LDBdIGluc3RlYWQgb2YgWzUwLCssNjBdLiBiYXNpY2FsbHkgZGlyZWN0IGNhbGN1bGF0aW9uIHdhcyBub3Qgd29ya2luZwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHVyZWV2YWwgZmluZHMgc3VjaCBwdXJlIG9wZXJhdGlvbnMgYW5kIHRoZW4gY2FsY3VsYXRlIHRoZW0gdG8gZGlyZWN0bHkgc2V0IHRoZWlyIHZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIHNoaXQgaXMgb25seSBmb3IgcHVyZW9wZXJhdGlvbnMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHVyZXZhbCA9IC9eKFstK10/WzAtOV0qXC4/WzAtOV0rW1wvXCtcLVwqXSkrKFstK10/WzAtOV0qXC4/WzAtOV0rKSokL2dtLnRlc3QoQ2xlYW5lZEVsZW1lbnQpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdXJldmFsID09IHRydWUpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnNbaV0udmFsdWUgPSBldmFsKHVwZGF0ZWRfdG9rZW5zW2ldLnZhbHVlKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxjdWxhdGlvbihDbGVhbmVkRWxlbWVudCkgPT0gdHJ1ZSAmJiAhcHVyZXZhbCkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybXMgPSBDbGVhbmVkRWxlbWVudC5zcGxpdCgnJykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMuZm9yRWFjaCgoZWwsIGkpID0+IHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4dG9DaGFuZ2UgPSAnJyAvL3RvIGtub3cgd2hpY2ggdmFsdWUgdG8gcmVwbGFjZSBsaWtlICJhbm5hK2RhZGEtYmFkIiB3aXRoICI1KzYtNyIKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsLnZhbHVlIC8vIHJlYWRpbmcgdGhlIGN1cnJlbnQgdmFsdWUsIGZvciBsb24gc3RyaW5nIHZhcmlhYmxlIG5hbWVzIGl0J3Mgc3RpbGwgbGlrZSAiYW5uYStkYWRhLWJhZCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC50b1N0cmluZygpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFN0cmluZ1ZhciA9IFtdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwdXJldmFsID0gL14oWy0rXT9bYS16XSpcLj9bYS16XStbXC9cK1wtXCpdKSsoWy0rXT9bYS16XSpcLj9bYS16XSspKiQvZ20udGVzdChlbGVtZW50KQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmluY2x1ZGVzKCc+JykgfHwgZWxlbWVudC5pbmNsdWRlcygnPCcpIHx8IGVsZW1lbnQuaW5jbHVkZXMoJz09JykpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3BsaXRFbGVtZW50c0FycmF5KGVsZW1lbnQpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyhTdHJpbmdWYXIsIHVwZGF0ZWRfdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0ZVVwZGF0ZWRfdG9rZW5zd2l0aFZhbHVlcyhTdHJpbmdWYXIsIGksIHVwZGF0ZWRfdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIGErYi1jCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB1cmV2YWwgPT0gdHJ1ZSB8fCBlbGVtZW50LmNoYXJBdCgwKSA9PSAiKCIpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNwbGl0RWxlbWVudHNBcnJheShlbGVtZW50KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdWYXIgPSBTZXRWYWx1ZXMoU3RyaW5nVmFyLCB1cGRhdGVkX3Rva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRlVXBkYXRlZF90b2tlbnN3aXRoVmFsdWVzKFN0cmluZ1ZhciwgaSwgdXBkYXRlZF90b2tlbnMpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKgogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlSW50aWFsaXplZFZhcmlhYmxlcy5mb3JFYWNoKGVsPT57CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWc9MAogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFNraXBJbmRleD0wCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBtPTA7bTx1cGRhdGVkX3Rva2Vucy5sZW5ndGg7bSsrKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWwubmFtZT09dXBkYXRlZF90b2tlbnNbbV0ubmFtZSAmJiBmbGFnPT0wKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlbC52YWx1ZS5jaGFyQXQoMCk9PSciJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCdWlsdFN0cmluZz0gQnVpbGRTdHJpbmcoZWwudmFsdWUsICkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnPTE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vuc1ttXS52YWx1ZT1lbC52YWx1ZTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgU2tpcEluZGV4PW0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIG0hPVNraXBJbmRleCAmJiBmbGFnPT0xICYmIGVsLm5hbWU9PXVwZGF0ZWRfdG9rZW5zW21dLm5hbWUpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnNwbGljZShtLDEpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICovCgoKCgogICAgICAgICAgICAgICAgLy9TRUNUSU9OIC0gSXRlcmF0aW5nIG92ZXIgdG9rZW5zIGFuZCB0aGVuIFBSSU5USU5HIEZJTkFMIHVzaW5nIHZhbHVlcyBzdG9yZWQgaW4gdXBkYXRlZCB0b2tlbnMKCiAgICAgICAgICAgICAgICAvKiAgICAgICAgCgogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykgewoKCiAgICAgICAgICAgICAgICB2YXIgbXV0YWJsZV90b2tlbnMgPSB0b2tlbnMKICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlCiAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gJ+CkquCljeCksOCkv+CkguCknycgKQoKICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBSZW1vdmVCcmFja2V0cyhtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlKQoKCgoKICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNfYXJyYXkucHVzaChiKQoKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgLy9TRUNUSU9OIC0gT3V0cHV0dGluZyB0aGUgY29kZQogICAgICAgICAgICAgICAgICAgIC8vIGZpbmRpbmcgdGhlIHJlbHZhbnQgdmFsdWUgYW5kIHRoZW4gb3V0cHV0IGl0IGFzIEhUTUwKICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gYiApIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQgKyBlbC52YWx1ZSArICJcbiI7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgdG8gYmUgY29udGludWVkCgogICAgICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIC8vSGFuZGxpbmcgQ29uZGl0aW9ucwoKICAgICAgICAgICAgICAgIGlmKG11dGFibGVfdG9rZW5zW2pdLnR5cGU9PSJjb25kaXRpb24iKQogICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbj0gdXBkYXRlZF90b2tlbnMuZmluZChlbD0+IGVsLm9yaWdpbmFsdmFsdWU9PW11dGFibGVfdG9rZW5zW2pdLnZhbHVlKQoKCgogICAgICAgICAgICAgICAgICAgIGxldCBDb25kaXRpb25WYWx1ZT10b2tlbi52YWx1ZQoKICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgaWYoQ29uZGl0aW9uVmFsdWU9PWZhbHNlKQogICAgICAgICAgICAgICAgICAgewoKbGV0IEluaXRpYWxpemVMb29wPSB0b2tlbnMuaW5kZXhPZihtdXRhYmxlX3Rva2Vuc1tqXSkKCgoKCgp3aGlsZShtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlIT0nfScgKQp7CgoKCiAgICBsZXQgeD0gbXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZS5sZW5ndGgKICAgIAogICAgCnRva2Vucy5zcGxpY2UoaisxLCAxKTsKIAoKICAgIGorKzsKCgp9CgoKCgogICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIGlmKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIC9eKFstK10/WzAtOV0qXC4/WzAtOV0rW1wvXCtcLVwqXSkrKFstK10/WzAtOV0qXC4/WzAtOV0rKSokL2dtLnRlc3QobXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZSkgKQogICAgICAgICAgICAgICAgewogCiAgICAgICAgICAgICAgICBsZXQgYT0gZXZhbChtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlKQoKICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQgKyAiXG4iICsgYSArICJcbiIKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgCgogICAgICAgIAogICAgICAgICAgICAgIAoKCgoKICAgICAgLy8gdGhpcyBpcyB0byBoYW5kbGUg4KSq4KWN4KSw4KS/4KSC4KSfICgiQWdlIGlzIisgQWdlKSBldGMuCgogICAgICAgICAgICAgICAgaWYoaXNTdHJpbmdhbmRWYWx1ZShtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSkpCnsKCgogICAgICAgIAoKICAgICAgICAgICAgICAgICAgICBsZXQgeD1tdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZQogICAgICAgICAgICAgICAgICAgIGxldCBzdHJpbmc9JycKICAgICAgICAgICAgICAgICAgICBsZXQgbmV3ZWw9JycKCiAgICAgICAgICAgICAgICAgICAgeD1SZW1vdmVCcmFja2V0cyh4KQoKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAvL3ggPSB4LnJlcGxhY2UoLyAvZywnJykKCiAgICAgICAgICAgICAgICAgICAgeD14LnNwbGl0KCIrIikKCiAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIHguZm9yRWFjaChlbGVtZW50ID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbWVudC5jaGFyQXQoMCk9PSAiICIgfHwgZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGgtMSk9PSIgIiAmJiAhKGVsZW1lbnQuaW5jbHVkZXMoJyInKSkpewoKICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICBuZXdlbD0gZWxlbWVudC5yZXBsYWNlKC9ccy9nLCAnJyk7CgogICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3ZWw9ZWxlbWVudAogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgIGxldCB5PSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsPT4gZWwubmFtZT09IG5ld2VsKQoKICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgIAovLwogICAgICAgICAgICAgICAgICAgICAgIGlmKHkhPXVuZGVmaW5lZCkKICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nPXN0cmluZyArICcgJyArIHkudmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAvLwoKCiAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgIGVsc2V7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudD0gZWxlbWVudC5yZXBsYWNlKC8iL2csICcnKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nPXN0cmluZysgJyAnICsgZWxlbWVudAogICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIH0pOwoKCgogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0ICsgIlxuIiArIHN0cmluZyArICJcbiIKfQoKCi8vVEhJUyBJUyB0byBoYW5kbGUgb3BlcmF0aW9ucyBsaWtlIOCkquCljeCksOCkv+CkguCknyAoIk5hbWUgaXMgR09BVCIpLCDgpKrgpY3gpLDgpL/gpILgpJ8gKCJHb29kYnllIikKCmVsc2V7CgoKCiAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZT0gUmVtb3ZlQnJhY2tldHMobXV0YWJsZV90b2tlbnNbal0udmFsdWUpCiAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICBsZXQgQ2xlYW5lZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvIC9nLCcnKQoKICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgaWYoL14oWy0rXT9bMC05XSpcLj9bMC05XStbXC9cK1wtXCpdKSsoWy0rXT9bMC05XSpcLj9bMC05XSspKiQvZ20udGVzdChDbGVhbmVkVmFsdWUpIT10cnVlKQoKICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvIi9nLCAiIik7CiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8nL2csICIiKTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dCArICJcbiIgKyB2YWx1ZSArICJcbiIgCiB9CiAgICAgICAgICAgICAgICAgICAgICAgIAoKfQoKCiAgICAgICAgICAgIH0KCgogICAgICAgICAgIAogICAgICAgICAgICB9KQoKICAgICAgICB9CiAgICAgICAgKi8KCgogICAgICAgIH0KCiAgICB9Cgp9OyAK"},{"version":3,"sources":["Practise.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;;AAKA;AACA;AACA;;;;AAIA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;;;;AAIA;;;;;;AAMA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;;;AAIA;AACA;;;AAGA;AACA;AACA;;;;AAIA;;;;AAIA;AACA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;AACA;;;;;AAKA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;;;;;;AAMA;;;AAGA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;;;;AAKA;;;AAGA;;;;;AAKA;;;;AAIA;;;;;;AAMA;;AAEA;;;;;AAKA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;;;;AAQA;;;;AAIA;;AAEA;;;;;AAKA;;;;;AAKA;;;;AAIA;;;AAGA;;;;;;AAMA;;AAEA;;;;;AAKA;;AAEA;AACA;;;;;AAKA;;;;AAIA;;;AAGA;;AAEA;;AAEA;;;;AAIA;AACA;;;;AAIA;;;;AAIA;;;AAGA;AACA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;AAEA;;AAEA;;;;;;AAMA;AACA;;;;;AAKA;;;AAGA;;AAEA;;;;;AAKA;AACA;;;AAGA;AACA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;;;AAGA;;;AAGA;AACA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;;AAGA;;;;;AAKA;AACA;;;;;AAKA;;;AAGA;;;;;AAKA;AACA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;;;;;;AAMA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;;AAGA;;;;AAIA;;AAEA;AACA;;;;AAIA;;;;;AAKA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;;;AAMA;;;AAGA;;;;AAIA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;;;;AAKA;;;;AAIA;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;;;AAGA;;;;AAIA;;AAEA;;AAEA;AACA;;;AAGA;;;;;;AAMA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;;AAKA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;AACA;;AAEA;AACA;;;;;AAKA;;;;AAIA;;;;AAIA;AACA;;;;AAIA;;;;;AAKA;;;AAGA;;;;AAIA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;;AAGA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;;;;AAKA;;;AAGA;;;;;AAKA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;;;AAKA;;AAEA;AACA;;;AAGA;;;AAGA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;AAKA;;;;AAIA;;;AAGA;;AAEA;AACA;;AAEA;;;;;AAKA;;;;;AAKA;AACA;;;;AAIA;;;AAGA;;AAEA;AACA;;;;AAIA;;AAEA;;AAEA;;;;;;AAMA;;;;;AAKA;AACA;;AAEA;;;AAGA;AACA;;;AAGA;AACA;;;;;;AAMA;;;;AAIA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AAUA;;AAEA;;;;;AAKA;;AAEA;AACA;;;;;;AAMA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;AACA;;AAEA;;;;;AAKA;;;;;;;;;;;;;;AAcA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;;;;;AAKA;;AAEA;;;AAGA;AACA;AACA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;;;;;AAMA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;;;;AAKA;;;AAGA;;;AAGA;;;AAGA;;;;;;AAMA;;AAEA;;AAEA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;;;;;;;;;AASA;;AAEA;;;;AAIA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;;;;AAKA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;AACA;;;;;;AAMA;;;;;;AAMA;AACA;;;;;AAKA;;;;AAIA;AACA;;;;AAIA;;;;;AAKA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;;;;;AAKA;;AAEA;;AAEA;AACA;AACA;;;;;AAKA;;;AAGA;;AAEA;;;AAGA;;;AAGA;;;;;AAKA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;AAKA;;;;AAIA;;AAEA;;;AAGA;;;;;AAKA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;AAKA;;;;;AAKA;;;;;;;;;;;AAWA;;AAEA;;;;;;;;;;;AAWA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;;;AAGA;;AAEA;;;;;;;;;;AAUA;AACA;;;;;;AAMA;;;;;;AAMA;AACA;;AAEA;;;;;AAKA;;;;AAIA;AACA;;AAEA;;;AAGA;;;;;;;;;AASA;;AAEA;;;;;AAKA;;AAEA;;AAEA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;AAKA;;;;;AAKA;AACA;;;;;AAKA;;AAEA;;;;;AAKA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;;AAKA;;AAEA;;AAEA;;;;;;AAMA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;;AAGA;;;AAGA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;;AAKA;;;;AAIA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;AACA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;;;;AAKA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;;;AAKA;;;AAGA;;;;AAIA;AACA;AACA;AACA;;AAEA;;;;;;AAMA;;;;AAIA;;AAEA;AACA;AACA;;;;;AAKA;AACA;;;AAGA;;;;;AAKA;;;;;AAKA;;;;;AAKA;;;;;AAKA;;AAEA;;AAEA;;;;;AAKA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;;;;;;;;;AASA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;;;;AAKA;AACA;;;;;AAKA;;;AAGA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;;;;AAKA;;;;AAIA;;AAEA;;;;AAIA;AACA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;;;;AAKA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;;AAIA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;;;;;AAKA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;;AAGA;;;;;AAKA;;;;AAIA;;;;AAIA;;;AAGA;;;;AAIA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;;;AAKA;;;;AAIA;;;;AAIA;;;;;AAKA;;;;;AAKA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;;;;;;;;;AASA;;;;AAIA;AACA;;AAEA;;;;;AAKA;;AAEA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;;;;;AAKA;;;AAGA;;;;;AAKA;;;;;AAKA;;AAEA;;;;;AAKA;;;;AAIA;;;AAGA;;AAEA;;;AAGA;;;;;AAKA;;;;;;;;AAQA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA;;;;;AAKA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;AAKA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;AAKA;;;;AAIA;;;;AAIA;;;;AAIA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;;;AAKA;;;;AAIA;;;;AAIA;;;;;AAKA;;;;;AAKA;AACA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;;;;;;;;;AASA;;;;AAIA;AACA;;AAEA;;;;;AAKA;;;;AAIA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;;;;;AAKA;;;AAGA;;;;;AAKA;;;;;AAKA;;AAEA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;;AAKA;;AAEA;;AAEA;AACA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;;AAGA;;AAEA;AACA;;;;;AAKA;;;AAGA;;;;AAIA;;;AAGA;;;;;AAKA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;;AAKA;AACA;;;;AAIA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;AACA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;;;AAIA;;AAEA;;;;AAIA;AACA;;AAEA;;;;;AAKA;;;;;;AAMA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;;;;AAKA;;;;;;AAMA;AACA;AACA;;;;;AAKA;;;;AAIA;;;;AAIA;;;;;AAKA;;;;;AAKA;;;;;AAKA;;;;;AAKA;;;AAGA;;;;AAIA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;;;;;;;AAQA;;;;AAIA;;;AAGA;;AAEA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;;;;;;;;;AASA;;;;AAIA;AACA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;;;;AAKA;;AAEA;;;;AAIA;;;;AAIA;AACA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;;AAIA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;;;;;AAKA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;;;;AAKA;;;;;;;;AAQA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;AACA;;;AAGA;;;AAGA;;AAEA;AACA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;;AAGA;;;;;AAKA;;AAEA;;;;AAIA;;;;;AAKA;;;;;AAKA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;AACA;AACA;;AAEA;;;;AAIA;;;;AAIA;;;;AAIA;;;AAGA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;;;;;AAKA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA;;;AAGA;AACA;AACA;;;;;AAKA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;AACA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;AACA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;;;;AAKA;;;;AAIA;;AAEA;;;;;;AAMA;;;AAGA;;AAEA;AACA;;;;;;AAMA;;;;AAIA;;;;AAIA;AACA;;AAEA;;;;;;AAMA;AACA;;;;AAIA;;;AAGA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;AAUA;;AAEA;AACA;;;;;AAKA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;;;AAIA;;;AAGA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;;;;;AAKA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;;;;AAIA;AACA;;;AAGA;;AAEA;;;;AAIA;AACA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;AAIA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA","file":"Practise.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class=\"hello\">\n   \n <Header/>\n\n   <div id=\"compiler\">\n\n\n   <div id=\"textarea\">\n\n\n\n\n   <!-- <textarea  onkeydown=\"if(event.keyCode===9){var v=this.value,s=this.selectionStart,e=this.selectionEnd;this.value=v.substring(0, s)+'\\t'+v.substring(e);this.selectionStart=this.selectionEnd=s+1;return false;}\" ref=\"textareaID\" placeholder=\"Welcome To Kalaam, This is your Code cm.\" v-model=\"code\" type=\"text\" name=\"code\" id=\"codearea\"></textarea>-->\n\n  <no-ssr placeholder=\"Codemirror Loading...\">\n\n  <codemirror id=\"codearea\" style=\"text-align:left;\" ref=\"myCm\"\n              :value=\"code\" \n              placeholder=\"Welcome To Kalaam, This is your Code Editor.\"\n              :options=\"cmOptions\"\n              @ready=\"onCmReady\"\n              @focus=\"onCmFocus\"\n              @input=\"onCmCodeChange\">\n  </codemirror>\n  </no-ssr>\n\n    <button style=\"background: linear-gradient(to right, #11998e, #12ff6b);\n    border: none;\n    font-weight: 600;\" id=\"subm\" @click=\"RUN()\">RUN</button>\n        <button id=\"subm\" @click=\"Add('()')\"></button>\n<button id=\"subm\" @click=\"Add('')\"></button>\n    <button id=\"subm\" @click=\"Add('()')\"></button>\n\n    <button id=\"subm\" @click=\"Add('()')\"></button>\n\n    <button id=\"subm\" @click=\"Add(' x  y ')\"> </button>\n    <button id=\"subm\" @click=\"Add('()')\"></button>\n    <button id=\"subm\" @click=\"Add('.()')\">.</button>\n    <button id=\"subm\" @click=\"Add('.()')\">.</button>\n    <button id=\"subm\" @click=\"Add('')\"></button>\n    \n\n   \n   </div>\n\n    <div id=\"output\">\n\n<div id=\"bharatDIV\">\n\n<p id=\"version\">Kalam v1.0.0</p>\n<p id=\"CodeStatus\" v-if=\"this.isError==false\">{{TimeTaken}}</p>\n        \n<p id=\"CodeStatus\" v-if=\"this.isError==true\" >{{TimeTaken}}</p>\n        \n\n<div id=\"printOutput\">\n\n<p style=\"white-space: pre; \"  id=\"linebylineOutput\" v-for=\"(output,index) in this.linebylineOutput\" :key=\"index\">\n\n\n {{output}} \n\n\n\n</p>\n</div>\n</div>\n\n\n\n\n    </div>\n</div>\n  \n\n    \n      \n  </div>\n</template>\n\n<script>\nimport Header from '../components/Header'\n\nimport { codemirror } from 'vue-codemirror'\n \n// require styles\nimport 'codemirror/lib/codemirror.css'\n   import {\n    SourceDataReplaceforEasyParsing\n} from '../FunctionScripts/functions'\nimport * as TypeCheck from '../FunctionScripts/TypeChecking'\nimport * as AdvancedTypeCheck from '../FunctionScripts/AdvancedTypeChecking'\nimport * as BuildOperation from '../FunctionScripts/BuildOperations'\nimport {\n    PushArray,\n    PushCalculation,\n    PushConditionalKeyword,\n    PushCondition,\n    PushForLoop,\n    PushWhileLoop,\n    PushWhileLoopCondition,\n    PushForLoopAruguments,\n    PushExpression,\n    PushKeyword,\n    PushNumber,\n    PushOperator,\n    PushRealTimePrintOperation,\n    PushString,\n    PushStringandValueOperation,\n    PushVariable,\n    PushVariableValue,\n    PushFunctionData,\n    PushFunctionExecution,\n    PushToArray,\n    PushInput\n\n} from '../FunctionScripts/PushFunctions'\nimport {\n    RemoveBrackets,\n    Count,\n    ResetValue,\n    isArrayOperation,\n    CreateArrayElement,\n    CalculateValues,\n    GetArrayorStringElement,\n    SetArrayorStringElement,\n    PrintArrayElement,\n    handlemultConditions,\n    HandleBlocks,\n    SplitElementsArray,\n    SetValues,\n    PushSetArrayIndexValue,\n    PushGetArrayIndexValue,\n    UpdateUpdated_tokenswithValues,\n    GetConditionValue,\n    ForLoopArrayorStringOutput,\n    AssignorUpdateValues,\n    HandleConditions,\n    getLoopIndexStart,\n    ForLoopSetMetadata,\n    SetArrayIndexValue\n} from '../FunctionScripts/MiscImportantFunctions'\n\nimport { mapState } from 'vuex'\n\n\n\nexport default {\n    name: \"HelloWorld\",\n    props: {\n        msg: String\n    },\n\n   \n      computed: mapState(['CurrentCode']),\n\n\n    data() {\n        return {\n            code:'',\nCodeinuse:'',\n           \n \n            output: '',\n            cm:'',\n            error: [],\n            OperationObjects: [],\n            linebylineOutput: '',\n            TimeTaken: '',\n            inputIndexes: [],\n            input: '',\n            isError:'',\n            LastConditionValue:[],\n            LineByLineCode:[],\n            cmOptions: {\n        // codemirror options\n        tabSize: 4,\n        lineNumbers: true,\n        line: true,\n        theme:''\n      }\n\n        };\n    },\n      components: {\n    codemirror,\n    Header\n  },\n\n mounted() {\n    console.log('this is current codemirror object', this.codemirror)\n    // you can use this.codemirror to do something...\n  },\n\n    created(){\n\n\n\nlet m=this.$store.state.CurrentCode.replace('&lt;','<')\nm=m.replace('&gt;','>')\nthis.code=m\n\n\n\n/*\nthis.Codeinuse=m\n\n\nif(this.code.length>0)\n{\n\nthis.LineByLineCode=this.code.split(\"\\n\")\n\nthis.LineByLineCode.forEach((el,index)=>{\n    \n\n\nel= (index+1) + '  ' + el\n\nthis.LineByLineCode[index]=el + '\\n'\n\n\n})\n\n \n this.LineByLineCode=this.LineByLineCode.join('\\n')\n\n this.code=this.LineByLineCode\n\n}\n \n*/\n\n    },\n\n    methods: {\n\n\n onCmReady(cm) {\n      console.log('the editor is readied!', cm)\n\n     \n\nthis.cm=cm;\n\nif(screen.width<420)\n{\n\n this.cm.setSize('100%', 300);\n\n}\nelse{\n\n this.cm.setSize('100%', 500);\n}\n\n\n    },\n    onCmFocus(cm) {\n    \n\n\n      //this.cm=cm\n    },\n    onCmCodeChange(newCode) {\n      //console.log('this is new code', newCode)\n      this.code = newCode\n    },\n\nAdd:function(insert)\n\n{\n\nvar doc = this.cm.getDoc();\n\n    var cursor = doc.getCursor();\n    doc.replaceRange(insert, cursor);\n \n\n\n\n}\n,\n        RUN: function() {\n\n\n\n                var t0 = performance.now()\n\n                this.isError=false\n\n                //to stop accumulating output on succesive RUN\n                this.output = ''\n                this.input = '',\n                    this.linebylineOutput = this.output.split(\"\\n\")\n                this.inputIndexes = []\n                this.error = []\n                this.OperationObjects = []\n                var sourcedata = this.code;\n                var cleaned_sourcedata = []\n                var i = 0;\n                var tokens = [];\n                var mixedimpurity = []\n                var updated_tokens = []\n                var functionContextupdated_tokens = []\n                var variables_array = []\n                var assigned_variables = []\n                var terms = []\n                var terms2 = []\n                var operation = ''\n                var CalculationStack = []\n                var foundToken = ''\n                var ReIntializedVariables = []\n                var tempthis=this\n\n                //emptying accumulatedvalue stored for operations like Name= Name+Array[i]\n                //See AssignorUpdateValues fuction for more\n                ResetValue()\n\n\n               \n\n                function AddOutput(tempthis,value)\n                {\n\n\n\n                tempthis.output = tempthis.output + value + \"\\n\";\n                \n                \n\n\n\n                }\n\n\n                //preparing sourcedata for easy parsing by handling new lines, enters etc.\n                //cleaning up the data to get my version of sourcedata. it's better to get version suitable for me because users can type what they wish but I need to maintain \n                //integrity of program in every possible conditio. So. I created my own condition below\n\n                function GetCleanSourcedata(sourcedata, cleaned_sourcedata, impurities) {\n\n                    sourcedata = SourceDataReplaceforEasyParsing(sourcedata)\n\n                    sourcedata.forEach((element, i) => {\n\n\n                        //finding the elements which has =\" in it so that to seprate them e.g. anna=\"swanand\" also finding the elements which starts with =. e.g \"=78787890\"\n\n\n\n                        if (!element.includes('==') && (element.indexOf('=\"') > -1 || element.indexOf('=') > 0 || element.charAt(0) == \"=\") && element != '==')\n\n\n                        {\n\n\n\n                            impurities.push(element) //push such element as impurity in impurities\n\n\n\n                            let elements = element.split(\"=\")\n                            let index = cleaned_sourcedata.length\n\n\n                            cleaned_sourcedata[index] = (elements[0])\n                            cleaned_sourcedata[index + 1] = (\"=\")\n                            cleaned_sourcedata[index + 2] = (elements[1])\n\n\n\n                        }\n\n                       \n\n                        //as long as element is pure, push it to new and clean version of sourcedata\n                        if (!impurities.includes(element)) {\n\n\n\n                            cleaned_sourcedata.push(element)\n\n                        }\n\n                        //\n\n                    })\n\n\n                    //removing empty \"\" values for final version of sourcedata\n                    //SECTION FInal sourcedata cleaning\n\n                    cleaned_sourcedata = cleaned_sourcedata.filter(function(item) {\n\n                        return item !== \"\"\n                    })\n\n\n\n                    return cleaned_sourcedata;\n\n                }\n\n\n                let Result = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity)\n\n                cleaned_sourcedata = Result\n                console.log('cleaned_sourcedata: ', cleaned_sourcedata);\n\n\n\n\n                //SECTION - Checking for type of characters\n\n\n                const isVariable = TypeCheck.isVariable()\n                const isNumber = TypeCheck.isNumber()\n\n                const isOperator = TypeCheck.isOperator()\n\n                const isKeyword = TypeCheck.isKeyword()\n                const isConditionalKeyword = TypeCheck.isConditionalKeyword()\n                const isForLoop = TypeCheck.isForLoop()\n                const isWhileLoop = TypeCheck.isWhileLoop()\n                const isFunction = TypeCheck.isFunction()\n                //needs work\n                const isExpression = TypeCheck.isExpression()\n\n                const isArray = TypeCheck.isArray()\n                const isInput = TypeCheck.isInput()\n\n                const isSetArrayIndexValue = TypeCheck.isSetArrayIndexValue()\n\n                // const isEmptyArrayInit = TypeCheck.isEmptyArrayInit()\n\n                const isString = TypeCheck.isString()\n                const isEmptyStringorChar = TypeCheck.isEmptyStringorChar()\n\n                const isPureEval = AdvancedTypeCheck.isPureEval()\n\n                //if parser encounters anything like (\" or (, then that's a realtime print. \n                //buildstring will be applied now to create a string and push it into tokens\n\n                const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString()\n\n\n\n                const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n                const isCalculation = AdvancedTypeCheck.isCalculation()\n\n                const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n\n\n\n\n                //SECTION Build Operations \n\n\n                const BuildString = BuildOperation.BuildString()\n\n                const BuildArray = BuildOperation.BuildArray()\n\n                //this function is the first step to handlle operations like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n\n                const BuildCondition = BuildOperation.BuildCondition()\n\n\n\n                //This will run for every print statement encountered in the program, not just for loops\n\n                function IfTokenPrint(Tokens, updated_tokens, j, global, iterator, OriginalIterator)\n\n\n\n\n                {\n\n\n                    var token = Tokens[j].value\n                    \n\n\n\n                    var NextTokenValue = Tokens[j + 1].value\n                    \n                    \n                    \n                    //NextTokenValue = NextTokenValue.replace(\"+\", ' + ')\n                    \n\n\n\n\n                    var StringVar = []\n\n                    var b = RemoveBrackets(NextTokenValue)\n                    \n                    \n                    \n\n                    if (isVariable(b) && !variables_array.includes(b)) {\n\n                        variables_array.push(b)\n                        // \n\n                    }\n\n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n\n                    //This loop is only for printing direct values like print(name), print(array)\n                    updated_tokens.forEach((el, i) => {\n                        \n                        \n                        \n                        \n                        \n\n\n                        if (el.name == b) {\n                            \n                            \n\n                            //for calculations like x=ageone+agetwo\n\n                            //If we have already caluculated value, use that or else move forward\n\n\n\n\n                            if (assigned_variables.includes(el)||assigned_variables.includes(el.name) ) {\n\n\n                                \n\n                                AddOutput(global, el.value)\n\n\n\n                            } else {\n\n\n                                if (isNumber(el.value)) {\n                                    \n                                    \n\n\n\n                                     AddOutput(global, el.value)\n\nassigned_variables.push(el.name);\n\n\n\n\n                                }\n\n                                //operations like age=2020-1996\n                                else if (isPureEval(el.value)) {\n\n\n\n\n                                    let outputpure = eval(el.value)\n\n\n\n                                    el.value = outputpure\n\n\n                                     AddOutput(global, el.value)\n\n                                    assigned_variables.push(el.name);\n\n                                }\n\n\n\n                                //operations like name=\"swanand kadam\", variable assignments as strings\n                                else if (!isPureEval(el.value) && !isNumber(el.value))\n                                \n\n\n                                {\n\n\n\n                                    if (!(el.name.includes(']') && el.name.includes('['))) {\n\n\n                                        if(el.type=='Array')\n                                        {\n\n\nif (el.value.includes('[')==false)\n\n{\n\nel.value='['+el.value.toString()+']'\n\n\n\n}\n\n                                        }\n\n                                        AddOutput(global, el.value)\n                                        \n                                        \n\n\n\n                                        assigned_variables.push(el.name);\n                                    }\n\n\n\n\n                                }\n\n\n                            }\n\n                        }\n\n\n\n\n                        // work to be continued\n                    })\n\n\n                    //ANCHOR - CONDITION 2\n                    if (Tokens[j + 1].type == 'Array')\n\n\n\n\n                    {\n\n                        //To run only if iterator is present\n\n                        //This runs on for loop - Print(Array[a]) etc\n\n                        //this runs only if for(i) and in the loop, array[i], not on array[x]. Iterator and index should be same\n\n                        if (iterator != undefined && Tokens[j + 1].IndexInput == OriginalIterator)\n\n                        {\n\n\n\n                            let Value = NextTokenValue\n                            // console.log('Value: ', Value);\n\n                            let ArrayElement = CreateArrayElement(Value, iterator)\n\n\n                            let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                            AddOutput(global, output)\n\n\n                            assigned_variables.push(Tokens[j + 1]);\n\n\n                        }\n\n\n                        //This runs to Print(Array[2]) like specific array values\n                        else if (Tokens[j+1].IndexInput != OriginalIterator)\n                        \n\n\n                        {\n\n                            //\n\n                            let Value = NextTokenValue\n\n                            let IndexToChange = Tokens[j + 1].IndexInput\n\n\n                            let ArrayElement = CreateArrayElement(Value, IndexToChange)\n\n\n                            let element = ArrayElement.replace(']', '')\n\n\n                            let Split = element.split('[')\n\n\n\n\n                            if (Split[1].includes('-') || Split[1].includes('+')) {\n\n\n                                let output = CalculateValues(Split[1], j, updated_tokens)\n\n                                Split[1] = output\n\n                                Split = Split.join('[') + ']'\n                                ArrayElement = Split\n                                //console.log('ArrayElement: ', ArrayElement);\n\n\n                            }\n\n\n                            let token = updated_tokens.find(el => el.name == Split[1])\n\n                            if (token != undefined && OriginalIterator != Split[1]) {\n\n                                Split[1] = token.value\n\n                                Split = Split.join('[') + ']'\n                                ArrayElement = Split\n\n\n                            } else {\n\n                                ArrayElement = ArrayElement\n                                //console.log('ArrayElement: ', ArrayElement);\n\n                            }\n\n\n                            let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                                        AddOutput(global, output)\n                             console.log('output: ', output);\n\n\n\n\n                        }\n\n\n                    }\n\n\n\n\n                    //printing direct numbers and direct calcultions like print(10), print(10*10)\n                    else if (token == '' && (isPureEval(RemoveBrackets(NextTokenValue)) || isNumber(RemoveBrackets(NextTokenValue)))) {\n\n\n                        NextTokenValue=RemoveBrackets(NextTokenValue)\n                        \n\nif(isNumber(NextTokenValue) && Tokens[j+1].type!='Calculation')\n\n\n{\n   \nAddOutput(global, NextTokenValue)\n\n}\n\nelse{\n\n\nlet a = eval(NextTokenValue)\nconsole.log('a: ', a);\n\n                          AddOutput(global, a)\n\n}\n                        \n                        \n\n                                     \n\n                    }\n\n\n\n\n                    //foroperations like print('you live, you learn')\n                    else if (Tokens[j + 1].mode == \"RealTimePrint\" && !NextTokenValue.includes('+') && !NextTokenValue.includes('='))\n\n                    {\n\n\n                        let output = RemoveBrackets(NextTokenValue)\n\n                        output = output.replace(/\"/g, '');\n                        output = output.replace(/'/g, '');\n\n\n                                        AddOutput(global, output+\"\\n\")\n\n\n\n                    }\n\n                    //operations like print(Age + 'is young age')\n                    else if (Tokens[j + 1].mode == \"RealTimePrint\" && NextTokenValue.includes('+')) {\n\n\n\n                        let x = SplitElementsArray(NextTokenValue)\n\n\n\n\n                        StringVar = SetValues(x, updated_tokens)\n\n\n\n\n                        StringVar = StringVar.join('')\n                        StringVar = StringVar.split(\"+\")\n\n                        let output = StringVar.join(' ')\n                        output = RemoveBrackets(output)\n\n                        AddOutput(global, output+\"\\n\")\n\n\n\n                    } else if ( isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != \"RealTimePrint\")\n                    \n\n\n                    {\n\nNextTokenValue=RemoveBrackets(NextTokenValue)\n\n                        let output = CalculateValues(NextTokenValue, j, updated_tokens)\n\n                        AddOutput(global, output+\"\\n\")\n\n\n                    }\n                    \n\n\n\n\n                }\n\n\n                //END OF Functions and Imported Functions\n\n\n\n                //SECTION - Parsing STARTS here\n\n                //SECTION - Checking each token and adding to tokens array\n\n\n\n            \n                let variableArray = [] //TO REMOVE DUPLICATE VARIABLES, SEE 482\n\n                function Parse(cleaned_sourcedata, i) {\n\n                    var element = cleaned_sourcedata[i];\n\n\n                    var string = []\n\n\n\n\n                    if (isVariable(element) == true) {\n                        \n\n\n\n                        if (cleaned_sourcedata[i + 1] == '=') {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            if (variableArray.includes(element)) {\n\n                                // let UpdateElementValue = element\n\n                                let x = tokens.find(el => el.value == element)\n\n                                let index = tokens.indexOf(x)\n\n\n                                ReIntializedVariables.push({\n                                    name: element\n                                })\n\n                                //\n\n                                //tokens[index+2].value= cleaned_sourcedata[i+2]\n\n\n\n                            }\n\n                            variableArray.push(element)\n\n\n\n\n                        } else if (cleaned_sourcedata[i - 1] == '=') {\n\n\nconsole.log('element: ', element);\n                            PushVariableValue(element, tokens)\n                            \n\n                        }\n\n                    } \n                    \n                    else if (isNumber(element) == true) {\n\n                        PushNumber(element, tokens)\n\n                    } \n\n                    else if(isEmptyStringorChar(element)==true){\n\n\n\n                         if(element.length>1 && (element.charAt(0)==\"'\"||element.charAt(0)=='\"')){\n                             \n\nelement=element.replace(/['\"]+/g, '')\n\n        \n\n    }\n\n    else{\n\n        element=\" \"\n    }\n\n                        \nPushVariableValue(element,tokens)\n\n\n\n\n\n                    }\n                    \n                    else if (isInput(element) == true)\n                    \n\n                    {\n\n                        PushInput(element, tokens, cleaned_sourcedata, i)\n\n\n\n\n                    } \n                    \n                    else if (isOperator(element) == true) {\n                        \n                        PushOperator(element, tokens)\n\n                    } \n                    \n                    else if (isKeyword(element) == true) {\n\n                        PushKeyword(element, tokens)\n\n                    } \n                    \n                    else if (isFunction(element) == true) {\n\n                        PushFunctionData(element, tokens, cleaned_sourcedata, i)\n\n                    }\n\n                    //check if it accpets Arry[2a] as index : \n                    else if (isArray(element) == true) {\n\n\n\n\n                        if (element.charAt(element.length - 1) == ']') {\n\n\n\n                            PushArray(element, tokens)\n\n                        } else {\n\n\n                            let BuiltArray = BuildArray(element, i, cleaned_sourcedata)\n\n                            PushArray(BuiltArray, tokens)\n\n\n\n                        }\n                    }\n\n                    //for Numbers[a]=x\n                    else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == true) {\n\n\n\n\n                        PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n\n\n\n                    }\n\n\n\n                    //for x=Numbers[a]\n                    else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == false) {\n\n\n\n                        PushGetArrayIndexValue(element, tokens, cleaned_sourcedata, i)\n\n\n\n\n                    }\n\n                \n                    else if (isConditionalKeyword(element) == true) {\n\n\n\n                        if (isWhileLoop(element) == true) {\n\n                            PushWhileLoop(element, tokens, cleaned_sourcedata, i)\n                            // PushWhileLoopCondition(element, cleaned_sourcedata, i, tokens)\n\n\n                        } else {\n\n                            PushConditionalKeyword(element, tokens)\n                        }\n\n\n                        let foundcondition = BuildCondition(element, i, cleaned_sourcedata)\n                        // console.log('foundcondition: ', foundcondition);\n\n\n\n                        PushCondition(foundcondition, tokens)\n\n\n\n\n                    } \n\n                    else if(element.includes(''))\n    \n{\n\n   PushToArray(element, tokens)\n\n\n                    }\n                    \n                    \n                    else if (isForLoop(element) == true) {\n\n                        PushForLoop(element, tokens)\n                        PushForLoopAruguments(element, cleaned_sourcedata, i, tokens)\n\n                        updated_tokens.push({\n\n                            name: cleaned_sourcedata[i + 1],\n                            value: 0,\n                            type: 'ForLoopIterator'\n\n                        })\n\n\n                    } \n                    \n                    \n                    else if (isCalculation(element) == true) {\n\n\n                        let element = ''\n\n                        if (cleaned_sourcedata[i + 1] != undefined) {\n\n\n\n                            // this is to perform long operations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n\n                            while (isCalculation(cleaned_sourcedata[i]))\n\n\n\n                            {\n\n\n                                element = element + cleaned_sourcedata[i];\n\n\n                                i++;\n\n                            }\n\n\n\n\n                        }\n\n\n                        //PushCalculation(element,tokens)\n\n\n\n\n                        //  \n                        terms = element.split('')\n\n                        //removing the \"(\"\" and \")\"\n\n                        var CleanedElement = RemoveBrackets(element)\n\n\n                        // to stop prevention of expressions like is\"+ getting added as a calculation\n                        if (!(CleanedElement.includes('\"')) && element.charAt(0) != '/' && element.charAt(0) != '*' && element.charAt(0) != \"'\") {\n\n                            PushCalculation(element, tokens, cleaned_sourcedata, i)\n\n\n\n                        }\n\n                    }\n\n                    //finding operations like print(\"swanand\"). The realtimeprint operations\n                    else if (isRealTimePrintMultipleString(element) == true) {\n\n\n\n                        //\n                        let foundString = ''\n\n                        let k = i\n                        //  console.log('element: ', element);\n                        let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n                        //console.log('conditionEnd: ', conditionEnd);\n\n\n                        var flag = 0;\n\n\n\n\n                        for (k; k < cleaned_sourcedata.length; k++) {\n\n                            let element = cleaned_sourcedata[k]\n                            let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n\n                            if (element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || element.includes('') || cleaned_sourcedata[k + 1] == '=' || element == '}') {\n\n\n                                //foundString=foundString+  ' '+ cleaned_sourcedata[k]\n\n                                //\n                                break;\n\n\n                            }\n\n                            if (conditionEnd == ')\"')\n\n                            {\n\n                                foundString = foundString + ' ' + cleaned_sourcedata[k];\n                                break;\n\n                            } else if (flag == 1) {\n\n                                foundString = foundString + ' ' + cleaned_sourcedata[k]\n\n                            } else if (flag == 0) {\n\n                                foundString = cleaned_sourcedata[k];\n\n                                flag = 1;\n\n                            }\n\n\n\n\n                        }\n\n\n\n                        if ((!foundString.includes(\">\")) && (!foundString.includes('/')) && (!foundString.includes('*')) && (!foundString.includes('<')) && (!foundString.includes('==')))\n\n\n                        {\n\n                            //console.log('foundString: ', foundString);\n                            PushRealTimePrintOperation(foundString, tokens)\n\n                        }\n\n\n\n\n                    }\n\n\n\n\n                    //storing only the string values to tokens ( not the strings in print statements)\n                    else if (isString(element))\n                    \n\n\n                    {\n\n\nconsole.log('element: ', element);\n\n                        let calculatedString = BuildString(element, i, cleaned_sourcedata)\n                        console.log('calculatedString: ', calculatedString);\n\n\n\n                        calculatedString = calculatedString.replace(/['\"]+/g, '')\n\n                        if (!(calculatedString.includes(\"\")))\n\n                            PushString(calculatedString, tokens)\n\n                        \n\n\n\n                    }\n\n\n\n\n                    //Found Solution using regexp- print(a) without space is getting accepted as expression\n                    else if (/^(?=.*?)(?=.*[a-z])/.test(element)) {\n\n                        PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n\n\n                        PushExpression(element.slice(6), tokens) //Pushing remaining expression like (a), (gagaks) etc\n                    }\n\n\n                    //error prone change made here- Pushing expression in here\n                    else if (isExpression(element) == true && !isCalculation(element) && !element.includes('[') && !element.includes(']') && (!isConditionalKeyword(cleaned_sourcedata[i - 1])) && (cleaned_sourcedata[i - 1] != '' && cleaned_sourcedata[i - 1] != '')) {\n\n\n\n                       \n\n                            let CheckFunctionExpression = element.split('(')\n                            \n\n\n                            let passedValues = RemoveBrackets(CheckFunctionExpression[1])\n                            passedValues = passedValues.split(',')\n                            let token = tokens.find(el => el.value == CheckFunctionExpression[0])\n\n                            if(token!=undefined)\n                            {\n\n\n\n\n\n\n                           \n\n\nPushFunctionExecution(element,tokens,cleaned_sourcedata,i,passedValues)\n\n                            }\n\n\n                        \n\n                        else{\n\n                        PushExpression(element,tokens)\n                        }\n\n\n\n\n\n                    } \n                    \n                    else if (isExpression(element) == true && element.includes('[') && element.includes(']')) {\n\n                        PushArray(element, tokens)\n\n                    } \n                    \n                    else if (!isKeyword(element) && !isNumber(element) && !isVariable(element) && !isExpression(element) && !isOperator(element))\n                {\n\n\n                        //ANCHOR \n                        /*Hnadling Impurity error-The main problem is figuring out how to solve \"=7000\" like things\n                    instead asking developers to add space manually\n                    Handling Alphanumeric strings to solve issues like ' anna=2362934'\n\n                    let impurity = element.split('=')\n\n                    let findString = impurity[1]\n\n\n                    //to accept long numbers i.e a=749374593745937\n\n                    if (isVariable(impurity[0]) && isNumber(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n                    //to accept a=STRING\n                    if (isVariable(impurity[0]) && isVariable(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n\n\n                    impurity.forEach((element, i) => {\n\n                        if (isVariable(element) == true) {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            //continue;\n                        }\n\n                        // ANCHOR \n\n                        //Issue: Right now, only isNumber is resolved, a=, =23828qw aren't resolved.\n                        //Solution: Work on all the modules\n\n\n                        if (isNumber(element) == true) {\n\n\n                            PushNumber(element, tokens)\n\n                        }\n\n                        //ANCHOR \n                        //You might have to remove this extra filters since you are only working on numbers (Future Issue)\n                        if (isOperator(element) == true) {\n                            PushOperator(element, token)\n\n                        }\n\n\n\n                        if (isKeyword(element) == true) {\n\n                            PushKeyword(element)\n\n                        }\n\n                        if (isExpression(element) == true) {\n\n\n                            PushExpression(element, tokens)\n\n                        }\n\n\n\n\n                    })\n */\n\n                    }\n\n\n\n\n                }\n\n\n\n\n\n\n\n\n\n\n\n\n\n                //SECTION - Checking each token and adding to tokens array\n                // PARSING INITIATION\n\n\n                for (i; i < cleaned_sourcedata.length; i++) {\n\n\n                    Parse(cleaned_sourcedata, i)\n                }\n\n                //ANCHOR \n                //CLEANING UP THE TOKENS ARRAY\n                //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n                tokens = tokens.filter(el => el.value != '')\n                console.log('tokens: ', tokens);\n\n\n\n\n               \n\n\n                //SECTION - Printing Outputs, considering conditions, finding values in updated_tokens\n\n\n\n\n                for (var j = 0; j < tokens.length; j++) {\n\n                    // Checking for assignment operators\n\n\n                    let mutable_tokens = tokens\n                    var token = mutable_tokens[j].value\n                    let tokenType = mutable_tokens[j].type\n\n\n\n                    var StringVar = []\n\n                    let VarWithoutbrackets = RemoveBrackets(mutable_tokens[j].value)\n\n                    VarWithoutbrackets = VarWithoutbrackets.replace(/ /g, '')\n\n\n                    if (mutable_tokens[j].type == \"SetArrayIndexValue\")\n\n\n\n                    {\n\n                       \n                       SetArrayIndexValue(mutable_tokens,j,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                       } else if (mutable_tokens[j].value == '=') {\n                           \n\n                      \n                      \n                      \n     AssignorUpdateValues(mutable_tokens, j, updated_tokens, iterator, OriginalIterator,this)\n\n                      \n                  \n\n\n                    } \n                    else if(tokenType=='PushToArray' )\n                    {\n\ntoken=token.replace('','')\nlet Split=token.split('.')\nlet ArrayName=Split[0]\n\nlet Element=RemoveBrackets(Split[1])\nconsole.log('Element: ', Element);\n\nlet ArrayToken=updated_tokens.find(el=>el.name==ArrayName)\nconsole.log('ArrayToken: ', ArrayToken);\n\nlet ElementtoPush=updated_tokens.find(el=>el.name==Element)\n\nconsole.log('ElementtoPush: ', ElementtoPush);\n\nif(ElementtoPush==undefined)\n{\n Element = Element.replace(/\"/g, \"\");\n                                Element = Element.replace(/'/g, \"\");\n                                \n\nElementtoPush=Element\n\n\n}\nelse{\n\n\n    ElementtoPush=ElementtoPush.value\n}\nlet ElementIndex=updated_tokens.indexOf(ArrayToken)\nconsole.log('ElementIndex: ', ElementIndex);\n\n\nlet ArrayValue=updated_tokens.find(el=>el.name==ArrayName).value\n\n\n\n\nif(ArrayValue=='[]')\n{\n\nArrayValue= ArrayValue.split(',')\n\n\n}\n\nconsole.log('ArrayValue: ', ArrayValue);\nArrayValue.push(ElementtoPush)\nArrayValue=ArrayValue.filter(el=> el!='[]') \nconsole.log('ArrayValue: ', ArrayValue);\n\nupdated_tokens[ElementIndex].value=ArrayValue\nconsole.log('updated_tokens: ', updated_tokens);\n\n\n                    }\n                    \n                    else if(token=='')\n                    \n                    {\n\n\n                let result = HandleBlocks(mutable_tokens, j, result)\nlet StartofBlock= mutable_tokens[j+1].startIndex\nlet EndofBlock= mutable_tokens[j+1].EndIndex\n\n//let DoesAnyTrueConditionExists= this.LastConditionValue.find(el=>el==true)\n\nlet lastValue=this.LastConditionValue.pop()\n\n\n\n\nif(lastValue==true)\n\n\n{\n\n\nj=EndofBlock\n\n\n}\n\n\n\n\n\n                    }\n                    \n                    else if (tokenType == 'AcceptInput') {\n\n                        let SetInputValueAs = mutable_tokens[j].AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for ' + SetInputValueAs)\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n                    else if (tokenType == 'function') {\n\n\n\n                            let functionSourceData = []\n\n                            let result = HandleBlocks(mutable_tokens, j+1, functionSourceData)\n\n                            functionSourceData = result.StoreResult\n\n                            functionSourceData.forEach(el=>{\n\n                                el.context='function'\n                            })\n\n                            mutable_tokens[j].SourceData=functionSourceData\n\n\n                    }\n\n                    \n                    \n                    \n                    else if (tokenType == 'functionExecution') {\n\n                        //checking if function is invoked somewhere later in the program\n\n\n\n                       \n                            let functionSourceData = []\n                             \n                            let functionName = mutable_tokens[j].value\n\n                            let passedValues = mutable_tokens[j].passedValues\n                            \n\n                            let functionToken=mutable_tokens.find(el=>el.value==functionName)\n                            let functionArguments = functionToken.arguments\n                            \n\n\n                            \n\n                            functionSourceData = functionToken.SourceData\n\n                           \n\n\n\n                            //Creating a seperate execution context and setting fucntion context name:value pair in 'functionContextupdated_tokens'\n                            functionArguments.forEach((el, index) => {\n\n\n\n\n                                let val = passedValues[index]\n\n\n\n                                val = val.replace(/\"/g, \"\");\n                                val = val.replace(/'/g, \"\");\n                                \n                               \n\n                                passedValues[index] = val\n                                \n\n                                \n                               \n                                //in this code we are filtering out arguments passed based on whether they already exist in updated tokens or not\n\n                                let FindInUpdatedTokens= updated_tokens.find(el=>el.name==val)\n                                \n                                \n\n//For passing same argument and same value to function  e.g function foo (fibonacci) and fibonacci=[] is already declared\n                                if(FindInUpdatedTokens==undefined)\n                                {\n\nfunctionContextupdated_tokens.push({\n\n\n\n\n                                    name: el,\n\n                                    value: val,\n\n                                    identifier: j + index,\n                                    type: 'value',\n                                    context: 'FunctionExecutionContext'\n\n\n\n\n                                })\n\n\n                                }\n\n                                //For passing different argument and value to function  e.g function foo (arr) and arr doesn't exist anywhere in tokens.\n\n\n                                else if(el!=FindInUpdatedTokens.name && FindInUpdatedTokens!=undefined) {\n\n\n                                    functionContextupdated_tokens.push({\n\n\n\n\n                                    name: el,\n\n                                    value: FindInUpdatedTokens.value,\n\n                                    identifier: j + index,\n                                    type: FindInUpdatedTokens.type,\n                                    context: 'FunctionExecutionContext',\n                                    IntheEndSetValueto:val\n\n\n\n\n                                })\n\n\n\n                                }\n\n                                else{\n\n\nfunctionContextupdated_tokens.push({\n\n\n\n\n                                    name: el,\n\n                                    value: val,\n\n                                    identifier: j + index,\n                                    type: FindInUpdatedTokens.type,\n                                    context: 'FunctionExecutionContext',\n                                    IntheEndSetValueto:val\n\n\n\n\n                                })\n\n\n\n\n                                }\n\n\n                                \n                                \n\n                             \n\n\n\n\n                            });\n\n                            var CompleteTokenValueList = [...updated_tokens, ...functionContextupdated_tokens]\n                            \n                            \n                            \n                            \n                            \n                            \n                            \n                            \n\n\n                            for (let i = 1; i < functionSourceData.length; i++)\n\n                            {\n\n\n                                let el = functionSourceData[i]\n\n\n\n\n                                if (el.value == '')\n                                \n\n                                {\n\n                                   \n                                console.log('functionSourceData,CompleteTokenValueList, j+i,: ', functionSourceData,CompleteTokenValueList, j+i,);\n\n                                 IfTokenPrint(functionSourceData,CompleteTokenValueList, i, this)\n                                 \n                                    \n\n                                  \n\n                                    \n\n\n                                \n                                } \n                                else if (el.value == '=') {\n                                    \n\n                      \n                      \n                      \n     AssignorUpdateValues(functionSourceData, i, CompleteTokenValueList, iterator, OriginalIterator,this)\n\n                      \n                  \n\n\n                    }\n                                 else if (el.type == 'AcceptInput') {\n\n                        let SetInputValueAs =functionSourceData[i].AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    } else if (el.type == 'condition')\n\n                                {\n\n\n\n\n                                    let element = functionSourceData[i].value\n\n                                    //this function is the first step to calculate value of operations like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n                                    let ConditionValue = GetConditionValue(element, CompleteTokenValueList, i)\n                                    this.LastConditionValue.push(ConditionValue)\n                                    //  console.log('j: ',j);\n\n\n\n\n                                    //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                                    if (ConditionValue == false) {\n\n                                        let InitializeLoop = tokens.indexOf(functionSourceData[i])\n\n                                        //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                                        //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                                        let Returnvalue = HandleBlocks(functionSourceData, i)\n\n                                        i = Returnvalue.i\n                                    }\n\n\n\n\n                                }\n\n\n\n\n                                //Handling set array element statements in for loop\n                                else if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n                                    SetArrayIndexValue(functionSourceData,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n\n                                } else if (functionSourceData[i].type == 'ForLoopStart')\n\n\n\n                                {\n\n                                    var FlagPrimalLoop = 0\n\n                                    var SourcedataTokens = []\n\n\n                                    //console.log('updated_tokens: ', updated_tokens);\n\n                                    let ForLoopMetaData = ForLoopSetMetadata(functionSourceData, i, CompleteTokenValueList)\n\n\n                                    var ForLoopSourcedataIndexStart = ForLoopMetaData.ForLoopSourcedataIndexStart\n                                    var Cycle = ForLoopMetaData.Cycle\n                                    var OriginalIterator = ForLoopMetaData.OriginalIterator\n                                    var IterationStart = ForLoopMetaData.IterationStart\n                                    var iterator = ForLoopMetaData.iterator\n                                    var element = ForLoopMetaData.element\n                                    var elementValue = ForLoopMetaData.elementValue\n\n                                    function getSourcedata(startIndex, functionSourceData, check, StoreResult) {\n                                        //console.log('startIndex, functionSourceData, check, StoreResult: ', startIndex, functionSourceData, check, StoreResult);\n\n\n\n                                        let Returnvalue = HandleBlocks(functionSourceData, startIndex, StoreResult)\n                                        StoreResult = Returnvalue.StoreResult\n\n\n                                        return StoreResult\n\n\n                                    }\n\n\n\n\n                                    ForLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', ForLoopSourcedataIndexStart)\n\n                                    //\n\n                                    SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, functionSourceData, '}', SourcedataTokens)\n                                    \n                                    \n\n\n\n                                    SourcedataTokens.forEach(el => {\n\n                                        el.isNestedLoop = false\n\n                                    })\n\n\n                                    let FindNestedLoop = SourcedataTokens.find(el => el.type == 'ForLoopStart')\n                                    if (FindNestedLoop != undefined) {\n\n                                        let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 2\n                                        let NestedLooplength = (SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex) + 1\n\n\n                                        for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n\n\n                                            SourcedataTokens[x].isNestedLoop = true\n\n                                        }\n\n\n                                    }\n\n\n\n\n                                    if (element.includes('(') && element.includes(','))\n\n\n                                    {\n\n                                        FlagPrimalLoop = 1\n\n\n                                    }\n\n\n\n\n                                    // console.log('Cycle: ', Cycle,IterationStart);\n\n\n                                    //Iterating over forloop sourcedata\n                                    //this line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                                    for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n\n\n\n                                        let forloopindex = CompleteTokenValueList.find(el => el.name == OriginalIterator)\n\n\n\n\n                                        forloopindex.value = iterator\n\n                                        //console.log('CompleteTokenValueList: ', CompleteTokenValueList);\n\n                                        //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                                        if (FlagPrimalLoop = 0) {\n                                            ForLoopArrayorStringOutput(elementValue, iterator, CompleteTokenValueList, this)\n\n                                        }\n\n\n                                        for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                                        {\n\n\n                                            let isNested = SourcedataTokens[i].isNestedLoop\n\n\n\n\n                                            if (SourcedataTokens[i].type == 'ForLoopStart') {\n                                                \n\n                                                var NestedFlagPrimalLoop = 0\n\n                                                var NestedSourcedataTokens = []\n\n                                                let NestedForLoopMetaData = ForLoopSetMetadata(SourcedataTokens, i, CompleteTokenValueList)\n\n                                                //  console.log('NestedForLoopMetaData: ', NestedForLoopMetaData);\n\n                                                var NestedForLoopSourcedataIndexStart = NestedForLoopMetaData.ForLoopSourcedataIndexStart\n                                                var NestedCycle = NestedForLoopMetaData.Cycle + 1\n                                                var NestedOriginalIterator = NestedForLoopMetaData.OriginalIterator\n                                                var NestedIterationStart = NestedForLoopMetaData.IterationStart\n                                                var Nestediterator = NestedForLoopMetaData.IterationStart\n                                                \n                                                var Nestedelement = NestedForLoopMetaData.element\n                                                var NestedelementValue = NestedForLoopMetaData.elementValue\n\n\n                                                function getSourcedata(startIndex, SourcedataTokens, check, StoreResult) {\n                                                    //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n\n\n                                                    let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                                                    StoreResult = Returnvalue.StoreResult\n\n\n                                                    return StoreResult\n\n\n                                                }\n\n\n\n\n                                                NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n\n\n\n                                                NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                                                //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n\n\n\n\n                                                for (Nestediterator; Nestediterator < NestedCycle; Nestediterator++) {\n                                                    {\n\n                                                        let y = Nestediterator\n\n\n                                                        let Nestedforloopindex = CompleteTokenValueList.find(el => el.name == NestedOriginalIterator)\n                                                        //console.log('forloopindex: ', forloopindex);\n\n\n\n                                                        Nestedforloopindex.value = y\n\n\n                                                        for (let index = 0; index < NestedSourcedataTokens.length; index++) {\n\n\n                                                            let el = NestedSourcedataTokens[index]\n\n                                                            if (el.value == '')\n\n                                                            {\n\n\n\n                                                                IfTokenPrint(NestedSourcedataTokens, CompleteTokenValueList, index, this, y, NestedOriginalIterator)\n\n\n                                                            } else if (el.value == '=' && el.isNestedLoop == true) {\n\n\n                                                                //assigning values to variables\n\n\n                                                                AssignorUpdateValues(NestedSourcedataTokens, index, CompleteTokenValueList, y, NestedOriginalIterator,this)\n\n                                                            } else if (el.type == 'condition' && el.isNestedLoop == true)\n\n\n\n                                                            {\n\n\n\n\n                                                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                                let ConditionStartIndex = index\n                                                                let condition = NestedSourcedataTokens[index].value\n                                                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                                //value of i depends on the conditions\n\n                                                                if (condition.includes('||') || condition.includes('&&'))\n\n                                                                {\n\n\n                                                                    let value = GetConditionValue(condition, CompleteTokenValueList, index)\n                                                                this.LastConditionValue.push(value)\n\n\n\n\n                                                                    if (value == false) {\n\n\n\n                                                                        let BlockLength = 0\n                                                                        let BlockStart = 0\n\n                                                                        while (NestedSourcedataTokens[index].value != '{')\n\n                                                                        {\n\n                                                                            if (NestedSourcedataTokens[index + 1].value == '{')\n\n                                                                            {\n\n\n                                                                                BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                                                                index = BlockLength + index + 1\n\n\n\n\n                                                                                break;\n\n                                                                            }\n\n\n\n                                                                            index++\n                                                                        }\n\n                                                                    } else {\n\n\n                                                                        index = index\n\n\n                                                                    }\n\n\n\n\n                                                                } else {\n\n\n                                                                    let x = HandleConditions(NestedSourcedataTokens, index, CompleteTokenValueList);\n\n\n\n\n                                                                    if (x != undefined) {\n\n\n                                                                        index = x\n\n\n\n                                                                    } else {\n                                                                        index = ConditionStartIndex\n                                                                        //console.log('i: ', i);\n                                                                    }\n\n                                                                }\n\n\n\n\n\n                                                            }\n\n\n\n                                                            //console.log('i: ', i);\n\n                                                            // i = i + NestedSourcedataTokens.length\n                                                            //console.log('i: ', i);\n                                                            else if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop == true)\n\n\n\n\n                                                            {\n                                                                        SetArrayIndexValue(NestedSourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n                                                            }\n\n\n\n\n                                                        }\n\n\n\n\n                                                    }\n\n\n\n\n                                                }\n\n\n\n\n                                            } \n\n                                             else if (SourcedataTokens[i].type== 'AcceptInput' && isNested == false) {\n\n                                       let SetInputValueAs =SourcedataTokens[i].type.AcceptAs\n\n\n\n\n                                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n                                            \n                                            else if (SourcedataTokens[i].value == '=' && isNested == false) {\n\n                                                //assigning values to variables\n\n\n                                                AssignorUpdateValues(SourcedataTokens, i, CompleteTokenValueList, iterator, OriginalIterator,this)\n\n\n\n\n                                            }\n\n\n\n\n                                            //Handling print statements in for loop\n                                            else if (SourcedataTokens[i].value == '' && isNested == false)\n\n\n\n\n                                            {\n\n\n                                                //for operations like print(array[3])\n\n                                                // console.log('for looop prints: ', functionSourceData[i],i);\n\n\n                                                IfTokenPrint(SourcedataTokens, CompleteTokenValueList, i, this, iterator, OriginalIterator)\n\n                                                //\n\n\n                                            }\n\n\n\n                                            //Handling set array element statements in for loop\n                                            else if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                            {\n\n\n\n                                                    SetArrayIndexValue(SourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n                                            }\n\n\n\n                                            // Handling CONDITIONAL statements in for loop\n                                            else if (SourcedataTokens[i].type == 'condition')\n\n\n\n                                            {\n\n\n\n\n                                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                let ConditionStartIndex = i\n                                                let condition = SourcedataTokens[i].value\n                                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                //value of i depends on the conditions\n\n                                                if (condition.includes('||') || condition.includes('&&'))\n\n                                                {\n\n\n                                                    let value = GetConditionValue(condition, updated_tokens, i)\n                                                                this.LastConditionValue.push(value)\n\n\n\n\n                                                    if (value == false) {\n\n\n\n                                                        let BlockLength = 0\n                                                        let BlockStart = 0\n\n                                                        while (SourcedataTokens[i].value != '{')\n\n                                                        {\n\n                                                            if (SourcedataTokens[i + 1].value == '{')\n\n                                                            {\n\n\n                                                                BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                                                                i = BlockLength + i + 1\n\n\n\n\n                                                                break;\n\n                                                            }\n\n\n\n                                                            i++\n                                                        }\n\n                                                    } else {\n\n\n                                                        i = i\n\n\n                                                    }\n\n\n\n\n                                                } else {\n\n\n                                                    i = HandleConditions(SourcedataTokens, i, CompleteTokenValueList);\n\n\n\n                                                    if (i != undefined) {\n\n\n                                                        i = i\n\n\n                                                    } else {\n                                                        i = ConditionStartIndex\n                                                        //console.log('i: ', i);\n                                                    }\n\n                                                }\n\n\n\n\n                                            }\n\n\n                                        }\n\n\n\n                                    }\n                                    //console.log('j: ', j);\n\n                                    i = i + SourcedataTokens.length\n                                    //console.log('j: ', j);\n\n\n                                } else if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n\n\nSetArrayIndexValue(SourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n                                } else if (functionSourceData[i].type == 'WhileLoopStart') {\n\n\n                                    let TokensCurrentIndex = i + 3\n\n\n\n                                    let ConditionValue = false\n\n                                    let element = functionSourceData[i + 1].value\n\n                                    let ExtratcedVariable = []\n\n                                    let variable = ''\n                                    let WhileLoopSourcedataIndexStart = 0\n                                    let WhileLoopSourcedataTokens = []\n\n\n\n                                    for (let i = 0; i < element.length; i++) {\n                                        let x = element.charAt(i)\n\n\n                                        if (isVariable(x))\n\n                                        {\n\n                                            variable = variable + x\n\n\n\n                                        }\n                                        if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n\n                                            let token = CompleteTokenValueList.find(el => el.name == variable)\n\n                                            ExtratcedVariable.push({\n                                                variable: variable,\n                                                value: token.value\n\n                                            })\n\n\n                                            variable = ''\n\n\n                                        }\n\n                                    }\n\n\n\n\n                                    function getWhileLoopSourcedata(startIndex, functionSourceData, check, StoreResult) {\n\n\n\n                                        StoreResult = HandleBlocks(functionSourceData, startIndex, StoreResult)\n\n\n\n                                        return StoreResult\n\n\n\n\n                                    }\n\n\n\n\n                                    WhileLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', WhileLoopSourcedataIndexStart)\n                                    //\n                                    WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, functionSourceData, '}', WhileLoopSourcedataTokens).StoreResult\n\n\n\n\n                                    //constantly accessing the conditionvalue\n\n                                    while (GetConditionValue(element, CompleteTokenValueList, j + 1)) {\n\n                                        for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n\n\n\n\n                                            //SECTION while loop context\n\n                                            if (WhileLoopSourcedataTokens[i].value == '=') {\n\n\n\n\n                                                AssignorUpdateValues(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                                                //\n\n                                                // \n\n\n                                            }\n\n                                               else if (WhileLoopSourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =WhileLoopSourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                            // Handling CONDITIONAL statements in for loop\n                                            else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                                            {\n\n\n\n\n                                                let index = HandleConditions(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                                                if (index != undefined) {\n                                                    i = index\n\n\n                                                } else {\n                                                    i = i\n                                                }\n\n\n\n\n                                            } else if (WhileLoopSourcedataTokens[i].value == '')\n\n\n\n\n                                            {\n\n\n                                                IfTokenPrint(WhileLoopSourcedataTokens, CompleteTokenValueList, i, this) //for operations like print(array[3])\n\n\n\n\n                                            } else if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                            {\n\n SetArrayIndexValue(WhileLoopSourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n\n                                            }\n\n\n\n                                        }\n\n\n                                    }\n\n                                    i = i + 1 + WhileLoopSourcedataTokens.length + 1\n                                  \n\n                                }\n\n\n\n\n                            }\n\n\n\n\n                        \n\n\n                        //skipping parsing index so that function context is run by single entity and global execution doesn't run this code too\n                      //  j = mutable_tokens[j + 1].EndIndex\n\n\n//If we pass function foo(arr) where arr is (suppose) fibonacci=[] declared in the global exe context(updated_tokens). But operation will be performed on\n//arr in functionContextupdated_tokens. so at the end of fucntion execution we set the value to it's right owner.\n                        let token=functionContextupdated_tokens.find(el=>el.IntheEndSetValueto!='')\n                        let GivePowersTo= updated_tokens.find(el=>el.name==token.IntheEndSetValueto)\n                        \n                        GivePowersTo.value=token.value\n\n//I have to empty it because function context has to remain empty other wise function arguments will keep on accepting new values with the same key\n//for e.g= PrintFullName(FirstName,LastName) and PrintFullName(FirstNam,LastNam) needs two different execution context hence first one needs to make space for later\n\n                        functionContextupdated_tokens=[]\n\n\n\n                    } else if (tokenType == 'condition')\n\n                    {\n\n\n\n\n                        let element = mutable_tokens[j].value\n\n                        //this function is the first step to calculate value of operations like  (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n                        let ConditionValue = GetConditionValue(element, updated_tokens, j)\n                         this.LastConditionValue.push(ConditionValue)\n\n                        // console.log('ConditionValue: ', ConditionValue);\n                        //  console.log('j: ',j);\n\n\n\n\n                        //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                        if (ConditionValue == false) {\n\n                            let InitializeLoop = tokens.indexOf(mutable_tokens[j])\n\n                            //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                            //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                            let Returnvalue = HandleBlocks(mutable_tokens, j)\n\n                            j = Returnvalue.j\n                        }\n\n\n\n\n                    } else if (token == '' && mutable_tokens[j].context!='function')\n                    \n\n\n                    {\n\n\n\n                        IfTokenPrint(mutable_tokens, updated_tokens, j, this) //for operations like print(array[3])\n\n\n\n                    } else if (tokenType == 'WhileLoopStart') {\n\n\n                        let TokensCurrentIndex = j + 3\n\n                        let ConditionValue = false\n\n                        let element = mutable_tokens[j + 1].value\n\n                        let ExtratcedVariable = []\n\n                        let variable = ''\n                        let WhileLoopSourcedataIndexStart = 0\n                        let WhileLoopSourcedataTokens = []\n\n\n\n                        for (let i = 0; i < element.length; i++) {\n                            let x = element.charAt(i)\n\n\n                            if (isVariable(x))\n\n                            {\n\n                                variable = variable + x\n\n\n\n                            }\n                            if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n\n                                let token = updated_tokens.find(el => el.name == variable)\n\n                                ExtratcedVariable.push({\n                                    variable: variable,\n                                    value: token.value\n\n                                })\n\n\n                                variable = ''\n\n\n                            }\n\n                        }\n\n\n\n\n                        function getWhileLoopSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n\n\n\n                            StoreResult = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n\n\n\n                            return StoreResult\n\n\n\n\n                        }\n\n\n\n\n                        WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart)\n                        //\n                        WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, '}', WhileLoopSourcedataTokens).StoreResult\n                        console.log('WhileLoopSourcedataTokens: ', WhileLoopSourcedataTokens);\n\n\n\n\n                        //constantly accessing the conditionvalue\n\n                        while (GetConditionValue(element, updated_tokens, j + 1)) {\n\n                            for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n\n\n\n\n                                //SECTION while loop context\n\n                                if (WhileLoopSourcedataTokens[i].value == '=') {\n\n\n\n\n                                    AssignorUpdateValues(WhileLoopSourcedataTokens, i, updated_tokens)\n\n                                    //\n\n                                    // \n\n\n                                }\n\n                                  else if (WhileLoopSourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =WhileLoopSourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                // Handling CONDITIONAL statements in for loop\n                                else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                                {\n\n\n\n\n                                    let index = HandleConditions(WhileLoopSourcedataTokens, i, updated_tokens)\n                                 \n\n\n                                    if (index != undefined) {\n                                        i = index\n\n\n                                    } else {\n                                        i = i\n                                    }\n\n\n\n\n                                } else if (WhileLoopSourcedataTokens[i].value == '')\n\n\n\n\n                                {\n\n\n                                    IfTokenPrint(WhileLoopSourcedataTokens, updated_tokens, i, this) //for operations like print(array[3])\n\n\n\n\n                                } else if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n SetArrayIndexValue(WhileLoopSourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n\n                                }\n\n\n\n                            }\n\n\n                        }\n                    } else if (tokenType == 'ForLoopStart')\n\n\n\n                    {\n\n                        var FlagPrimalLoop = 0\n\n                        var SourcedataTokens = []\n\n\n                        //console.log('updated_tokens: ', updated_tokens);\n\n                        let ForLoopMetaData = ForLoopSetMetadata(mutable_tokens, j, updated_tokens)\n\n                        console.log('ForLoopMetaData: ', ForLoopMetaData);\n\n                        var ForLoopSourcedataIndexStart = ForLoopMetaData.ForLoopSourcedataIndexStart\n                        var Cycle = ForLoopMetaData.Cycle\n                        \n                        var OriginalIterator = ForLoopMetaData.OriginalIterator\n                        var IterationStart = ForLoopMetaData.IterationStart\n                        var iterator = ForLoopMetaData.iterator\n                        var element = ForLoopMetaData.element\n                        var elementValue = ForLoopMetaData.elementValue\n\n                        function getSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n                            //console.log('startIndex, mutable_tokens, check, StoreResult: ', startIndex, mutable_tokens, check, StoreResult);\n\n\n\n                            let Returnvalue = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n                            StoreResult = Returnvalue.StoreResult\n\n\n                            return StoreResult\n\n\n                        }\n\n\n\n\n                        ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart)\n\n                        //\n\n                        SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, '}', SourcedataTokens)\n                        //console.log('SourcedataTokens: ', SourcedataTokens);\n\n\n\n                        SourcedataTokens.forEach(el => {\n\n                            el.isNestedLoop = false\n\n                        })\n\n\n                        let FindNestedLoop = SourcedataTokens.find(el => el.type == 'ForLoopStart')\n                        \n                        \n                        if (FindNestedLoop != undefined) {\n\n                            let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 3\n                            let NestedLooplength = (SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex) + 2\n                            \n                            \n\n\n                            for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n\n\n                                SourcedataTokens[x].isNestedLoop = true\n                                \n                                \n\n                            }\n\n\n                        }\n\n\n\n\n                        if (element.includes('(') && element.includes(','))\n\n\n                        {\n\n                            FlagPrimalLoop = 1\n\n\n                        }\n\n\n\n                        // console.log('Cycle: ', Cycle,IterationStart);\n\n\n                        //Iterating over forloop sourcedata\n                        //this line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                        for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n\n\n\n                            let forloopindex = updated_tokens.find(el => el.name == OriginalIterator)\n\n\n\n\n                            forloopindex.value = iterator\n\n                            //console.log('updated_tokens: ', updated_tokens);\n\n                            //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                            if (FlagPrimalLoop = 0) {\n                                ForLoopArrayorStringOutput(elementValue, iterator, updated_tokens, this)\n\n                            }\n\n\n                            for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                            {\n\n\n                                let isNested = SourcedataTokens[i].isNestedLoop\n\n\n                                if (SourcedataTokens[i].type == 'ForLoopStart') {\n                                    \n\n                                    var NestedFlagPrimalLoop = 0\n\n                                    var NestedSourcedataTokens = []\n\n                                    let NestedForLoopMetaData = ForLoopSetMetadata(SourcedataTokens, i, updated_tokens)\n\n                                    //  console.log('NestedForLoopMetaData: ', NestedForLoopMetaData);\n\n                                    var NestedForLoopSourcedataIndexStart = NestedForLoopMetaData.ForLoopSourcedataIndexStart\n                                    var NestedCycle = NestedForLoopMetaData.Cycle + 1\n                                    var NestedOriginalIterator = NestedForLoopMetaData.OriginalIterator\n                                    var NestedIterationStart = NestedForLoopMetaData.IterationStart\n                                    var Nestediterator = NestedForLoopMetaData.IterationStart\n                                    var Nestedelement = NestedForLoopMetaData.element\n                                    var NestedelementValue = NestedForLoopMetaData.elementValue\n\n\n                                    function getSourcedata(startIndex, SourcedataTokens, check, StoreResult) {\n                                        //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n\n\n                                        let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                                        StoreResult = Returnvalue.StoreResult\n\n\n                                        return StoreResult\n\n\n                                    }\n\n\n\n\n                                    NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n                                    //console.log('ForLoopSourcedataIndexStart: ', ForLoopSourcedataIndexStart);\n\n\n\n                                    NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                                    //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n\n\n\n\n                                    for (Nestediterator; Nestediterator < NestedCycle; Nestediterator++) {\n                                        {\n\n                                            let y = Nestediterator\n\n\n                                            let Nestedforloopindex = updated_tokens.find(el => el.name == NestedOriginalIterator)\n                                            //console.log('forloopindex: ', forloopindex);\n\n\n\n                                            Nestedforloopindex.value = y\n\n\n                                            for (let index = 0; index < NestedSourcedataTokens.length; index++) {\n\n\n                                                let el = NestedSourcedataTokens[index]\n\n                                                if (el.value == '')\n\n                                                {\n\n\n\n                                                    IfTokenPrint(NestedSourcedataTokens, updated_tokens, index, this, y, NestedOriginalIterator)\n\n\n                                                } else if (el.value == '=' && el.isNestedLoop == true) {\n\n\n                                                    //assigning values to variables\n\n\n                                                    AssignorUpdateValues(NestedSourcedataTokens, index, updated_tokens, y, NestedOriginalIterator)\n\n                                                } else if (el.type == 'condition' && el.isNestedLoop == true)\n\n\n\n                                                {\n\n\n\n\n                                                    //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                    let ConditionStartIndex = index\n                                                    let condition = NestedSourcedataTokens[index].value\n                                                    //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                    //value of i depends on the conditions\n\n                                                   \n\n                                                        let value = GetConditionValue(condition, updated_tokens, index)\n                                                        \n                                                                this.LastConditionValue.push(value)\n\n\n\nif(value==false)\n{\n\n    break\n\n\n\n\n}\n\n\n\n\n\n                                                      /*  if (value == false) {\n\n\n\n                                                            let BlockLength = 0\n                                                            let BlockStart = 0\n\n                                                            while (NestedSourcedataTokens[index].value != '{')\n\n                                                            {\n\n                                                                if (NestedSourcedataTokens[index + 1].value == '{')\n\n                                                                {\n\n\n                                                                    BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                                                    index = BlockLength + index + 1\n\n\n\n\n                                                                    break;\n\n                                                                }\n\n\n\n                                                                index++\n                                                            }\n\n                                                        } else if(value==true) {\n\n\nconsole.log(el,NestedSourcedataTokens,index);\n\n                                                        }\n\n\n\n\n*/\n                                                  \n\n\n\n                                                }\n\n\n\n                                               \n\n                                                // i = i + NestedSourcedataTokens.length\n                                                //console.log('i: ', i);\n                                                else if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop == true)\n\n\n\n\n                                                {\n\n                                                    \n\n                                                        SetArrayIndexValue(NestedSourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                                                }\n\n\n\n\n                                            }\n\n\n\n\n                                        }\n\n\n\n\n                                    }\n\n\n\n\n                                } else if (SourcedataTokens[i].value == '=' && isNested == false) {\n                                    \n\n                                    //assigning values to variables\n\n\n\n                                    AssignorUpdateValues(SourcedataTokens, i, updated_tokens, iterator, OriginalIterator)\n\n                                }\n\n else if(SourcedataTokens[i].type=='PushToArray')\n \n                    {\n\nlet token=SourcedataTokens[i].value\n\ntoken=token.replace('','')\nlet Split=token.split('.')\nlet Array=Split[0]\nlet ElementtoPush=RemoveBrackets(Split[1])\nElementtoPush=updated_tokens.find(el=>el.name==ElementtoPush).value\n\nlet ArrayEl=updated_tokens.find(el=>el.name==Array)\n\n\nlet ArrayValue=ArrayEl.value\nif(ArrayValue=='[]')\n{\nArrayValue= ArrayValue.split(',')\n}\nArrayValue.push(ElementtoPush)\n\n\nlet index=updated_tokens.indexOf(ArrayEl)\n\nArrayValue=ArrayValue.filter(el=> el!='[]')\n\n\n\n\n\n\n\nupdated_tokens[index].value=ArrayValue\n \n\n\n                    }\n\n\n  else if (SourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =SourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                //Handling print statements in for loop\n                                else if (SourcedataTokens[i].value == '' && isNested == false)\n\n\n\n\n                                {\n\n                                    //for operations like print(array[3])\n\n                                    // console.log('for looop prints: ', SourcedataTokens[i],i);\n\n\n                                    IfTokenPrint(SourcedataTokens, updated_tokens, i, this, iterator, OriginalIterator)\n\n                                    //\n\n\n                                }\n\n\n\n                                //Handling set array element statements in for loop\n                                else if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n                                   SetArrayIndexValue(SourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                                }\n\n\n\n                                // Handling CONDITIONAL statements in for loop\n                                else if (SourcedataTokens[i].type == 'condition')\n\n\n\n                                {\n\n\n\n\n                                    //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                    let ConditionStartIndex = i\n                                    let condition = SourcedataTokens[i].value\n                                    //HandleConditions evaluates condition and return the index of from where printing should resume\n                                    //value of i depends on the conditions\n\n                                    if (condition.includes('||') || condition.includes('&&'))\n\n                                    {\n\n\n                                        let value = GetConditionValue(condition, updated_tokens, i)\n\n                                                                this.LastConditionValue.push(value)\n\n\n                                        if (value == false) {\n\n\n\n                                            let BlockLength = 0\n                                            let BlockStart = 0\n\n                                            while (SourcedataTokens[i].value != '{')\n\n                                            {\n\n                                                if (SourcedataTokens[i + 1].value == '{')\n\n                                                {\n\n\n                                                    BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                                                    i = BlockLength + i + 1\n\n\n\n\n                                                    break;\n\n                                                }\n\n\n\n                                                i++\n                                            }\n\n                                        } else {\n\n\n                                            i = i\n\n\n                                        }\n\n\n\n\n                                    } else {\n\n\n                                        i = HandleConditions(SourcedataTokens, i, updated_tokens);\n\n\n\n                                        if (i != undefined) {\n\n\n                                            i = i\n\n\n                                        } else {\n                                            i = ConditionStartIndex\n                                            //console.log('i: ', i);\n                                        }\n\n                                    }\n\n\n\n\n                                }\n\n\n                            }\n\n\n\n                        }\n                        //console.log('j: ', j);\n\n                        j = j + SourcedataTokens.length\n                        //console.log('j: ', j);\n\n\n                    }\n\n                    //END FOR LOOP EXECUTION\n\n\n\n\n                }\n\n\n\n\n                \n\n\n //To find undefined variables\n               \n                //\n\n\n\n\nfunction onlyUnique(value, index, self) { \n    return self.indexOf(value) === index;\n}\n\nvar assigned_variables=assigned_variables.filter(onlyUnique)\n\nlet difference= variables_array.filter(x=> !assigned_variables.includes(x))\n\n                if (difference.length > 0)\n\n                {\n\n                    difference.forEach(el=>{\n\n\n                    this.error.push('Variable ' + el + ' is undefined ')\n\n\n                    })\n                    \n\n                }\n\n              if(this.error.length>0)\n              {\n\nthis.linebylineOutput=this.error\n\n\n              }\n\nelse{\n\n                this.linebylineOutput = this.output.split('\\n')\n                \n}\n\n\n\n\nvar t1 = performance.now()\n                if (this.linebylineOutput!= '' && this.error.length==0) {\n                    this.TimeTaken = \"Compiled Succesfully in \" + (t1 - t0).toPrecision(4) + \" ms.\"\n\n                }\n\n                else{\n\n                    this.isError = true\n\n                    this.TimeTaken = \"Compilation Error: Check for assignement and declaration mistyping\" \n\n\n                }\n\n\n               \n               this.linebylineOutput = this.linebylineOutput.filter(function(item) {\n                   \n                   \n                    return item !== \"\"\n                })\n\n\n                //SECTION - Calculating remaining values\n\n\n                //so that replace x with values\n\n                /*\n                            updated_tokens.forEach((el, i) => {\n                                \n\n\n                                let element = el.value\n\n\n                                //removing the \"(\"\" and \")\"\n\n\n                                var CleanedElement = RemoveBrackets(element)\n\n                                operation = ''\n\n\n\n                                //why pureeval?\n                                // operations like 50+60 were set as [5,0,+,6,0] instead of [50,+,60]. basically direct calculation was not working\n                                //pureeval finds such pure operations and then calculate them to directly set their value\n                                //this shit is only for pureoperations\n                                let pureval = /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedElement)\n\n                                if (pureval == true) {\n\n\n\n                                    updated_tokens[i].value = eval(updated_tokens[i].value)\n\n\n                                }\n\n\n\n\n                                if (isCalculation(CleanedElement) == true && !pureval) {\n\n                                    terms = CleanedElement.split('')\n\n\n\n                                }\n\n\n\n\n                            })\n\n\n\n\n                            //\n\n                            // performing calculations\n\n\n\n\n                            updated_tokens.forEach((el, i) => {\n\n                                var indextoChange = '' //to know which value to replace like \"anna+dada-bad\" with \"5+6-7\"\n\n\n\n                                let element = el.value // reading the current value, for lon string variable names it's still like \"anna+dada-bad\"\n                                element = element.toString()\n                                var StringVar = []\n                                // \n\n                                let pureval = /^([-+]?[a-z]*\\.?[a-z]+[\\/\\+\\-\\*])+([-+]?[a-z]*\\.?[a-z]+)*$/gm.test(element)\n\n\n\n                                if (element.includes('>') || element.includes('<') || element.includes('==')) {\n\n\n\n                                    StringVar = SplitElementsArray(element)\n\n\n\n                                    StringVar = SetValues(StringVar, updated_tokens)\n\n\n                                    UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n\n\n                                }\n\n\n                                //finding operations like a+b-c\n                                if (pureval == true || element.charAt(0) == \"(\") {\n\n                                    // \n\n\n                                    StringVar = SplitElementsArray(element)\n                                    StringVar = SetValues(StringVar, updated_tokens)\n                                    UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n                                }\n\n\n\n\n                            })\n\n\n\n\n                            /*\n                             ReIntializedVariables.forEach(el=>{\n\n                            let flag=0\n                            let SkipIndex=0\n\n                            for(let m=0;m<updated_tokens.length;m++)\n                            {\n                                \n                            if(el.name==updated_tokens[m].name && flag==0)\n                            {\n\n\n                            if(el.value.charAt(0)=='\"')\n                            {\n\n\n                                let BuiltString= BuildString(el.value, )\n\n                                \n                            }\n                            flag=1;\n                            updated_tokens[m].value=el.value;\n\n\n                            \n\n                            SkipIndex=m\n\n\n                            }\n\n                            //\n\n                            if( m!=SkipIndex && flag==1 && el.name==updated_tokens[m].name)\n\n                            {\n\n                            updated_tokens.splice(m,1)\n\n                            }\n\n\n                            }\n\n\n\n\n                            })\n                            */\n\n\n\n\n                //SECTION - Iterating over tokens and then PRINTING FINAL using values stored in updated tokens\n\n                /*        \n\n            for (var j = 0; j < tokens.length; j++) {\n\n\n                var mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n             \n\n                if (token == '' )\n\n                {\n\n                    var b = RemoveBrackets(mutable_tokens[j+1].value)\n\n\n\n\n                    variables_array.push(b)\n\n                    \n\n                 \n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n                    updated_tokens.forEach((el, i) => {\n\n                        if (el.name == b ) {\n\n\n\n                            this.output = this.output + el.value + \"\\n\";\n\n                            assigned_variables.push(el.name);\n\n                           \n\n\n                        }\n\n\n\n                        // work to be continued\n\n                    })\n\n                    \n\n                    \n\n                }\n\n\n                //Handling Conditions\n\n                if(mutable_tokens[j].type==\"condition\")\n                {\n\n\n\n                   \n\n                    let token= updated_tokens.find(el=> el.originalvalue==mutable_tokens[j].value)\n\n\n\n                    let ConditionValue=token.value\n\n                  \n\n                   if(ConditionValue==false)\n                   {\n\nlet InitializeLoop= tokens.indexOf(mutable_tokens[j])\n\n\n\n\n\nwhile(mutable_tokens[j+1].value!='}' )\n{\n\n\n\n    let x= mutable_tokens[j+1].value.length\n    \n    \ntokens.splice(j+1, 1);\n \n\n    j++;\n\n\n}\n\n\n\n\n                   }\n\n\n                }\n\n\n                if(token == '' && /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(mutable_tokens[j+1].value) )\n                {\n \n                let a= eval(mutable_tokens[j+1].value)\n\n                this.output = this.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n                \n\n        \n              \n\n\n\n\n      // this is to handle  (\"Age is\"+ Age) etc.\n\n                if(isStringandValue(mutable_tokens[j].value))\n{\n\n\n        \n\n                    let x=mutable_tokens[j].value\n                    let string=''\n                    let newel=''\n\n                    x=RemoveBrackets(x)\n\n                    \n                    //x = x.replace(/ /g,'')\n\n                    x=x.split(\"+\")\n\n                    \n\n                    x.forEach(element => {\n                        \n\n                        \n                        if(element.charAt(0)== \" \" || element.charAt(element.length-1)==\" \" && !(element.includes('\"'))){\n\n                          \n                       newel= element.replace(/\\s/g, '');\n\n                        \n\n\n                        }\n                        else{\n\n                            newel=element\n                        }\n\n                       let y= updated_tokens.find(el=> el.name== newel)\n\n                      \n                       \n//\n                       if(y!=undefined)\n                       {\n\n\n\n                       string=string + ' ' + y.value\n                       //\n\n\n                       }\n                       else{\n\n                           \n                           element= element.replace(/\"/g, '');\n                           string=string+ ' ' + element\n                       }\n                       \n\n                       \n\n                    });\n\n\n\n                        this.output = this.output + \"\\n\" + string + \"\\n\"\n}\n\n\n//THIS IS to handle operations like  (\"Name is GOAT\"),  (\"Goodbye\")\n\nelse{\n\n\n\n                  let value= RemoveBrackets(mutable_tokens[j].value)\n                 // \n\n                  \n\n                   let CleanedValue = value.replace(/ /g,'')\n\n                    \n\n\n                   if(/^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedValue)!=true)\n\n                   {\n\n                 // \n\n                    value = value.replace(/\"/g, \"\");\n                    value = value.replace(/'/g, \"\");\n\n\n\n                        this.output = this.output + \"\\n\" + value + \"\\n\" \n }\n                        \n\n}\n\n\n            }\n\n\n           \n            })\n\n        }\n        */\n\n\n        }\n\n    }\n\n}; \n</script>\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n\n::-webkit-input-placeholder {\n   text-align: center;\n   vertical-align: middle;\n   line-height: 500px;\n}\n\n:-moz-placeholder { /* Firefox 18- */\n   text-align: center;  \n      vertical-align: middle;\n        line-height: 500px;\n\n\n}\n\n\n::-moz-placeholder {  /* Firefox 19+ */\n   text-align: center;  \n      vertical-align: middle;\n         line-height: 500px;\n\n\n}\n\n:-ms-input-placeholder {  \n   text-align: center; \n      vertical-align: middle;\n         line-height: 500px;\n\n\n}\n\nbutton:focus {outline:0;}\n\n#bharatP{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace\n}\n#versionNumber{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace;\n    padding-left: 6%\n}\n\n\n#version{\n\n    margin: 0;\n    float: left;\n    color: #92924c;\n    font-size: 90%;\n\n}\n\n#bharatDIV{\n\n    padding-top: 2%;\n    padding-left: 2%\n\n}\n\n\n#linebylineOutput\n{\n\n\n\nheight: 10px;\n    text-align: left;\n    \n\n\n}\n#errorstack{\n\ntext-align: left;\npadding-left: 2.5%;\npadding-top: 6%;\nfont-weight: bold;\ncolor:rgb(231, 83, 83);\n\n}\n\n#compiler{\n\n  display: flex;\n}\n\n#textarea{\n\n  width: 50%;\n  margin-left: -1%\n\n}\n#output{\n\n  height: 600px;\n  width: 50%;\n  background-color: black;\n    color: white;\n    overflow: auto\n  \n}\nh3 {\n  margin: 40px 0 0;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n\n.hello {\n  display: grid;\n}\n\n\n#codearea {\nwidth: 93%;\n    margin-left: 3.5%;\n    height: 500px;\n    background-color: whitesmoke;\n    font-family: monospace;\n    font-size: medium;\n    border: none;\n    outline: none;\n    resize: none;\n}\n\n#row{\n\ndisplay: flex;\n    width: 2%;\n    margin-top: -12%;\n\n}\n\n#rowdiv{\n\n\n  verflow: hidden;\n    height: 500px;\n    margin-left: 2%;\n    margin-right: 1%;\n    margin-top: 0%;\n    font-size: small;\n\n}\n\n#subm {\n  width: 18.5%;\n  height: 50px;\n      cursor: pointer;\n      border: none\n\n  \n}\n\n#subm:hover{\n\n\n    background-image: radial-gradient( circle 534px at 7.8% 17.6%,  rgba(254,253,112,1) 1.7%, rgba(248,143,111,1) 91.8% );\n}\n\np{\n\n \n  margin-top: 4%\n}\n\n#CodeStatus{\n\n    margin-top: 5%;  \n      text-align: left;\n    color: #2fff2f;\n    font-family: monospace\n\n}\n\n\n\n\n\n/* Smartphones (portrait) ----------- */\n@media only screen\nand (max-width : 480px) {\n\n\n::-webkit-input-placeholder {\n   text-align: center;\n   vertical-align: middle;\n   line-height: 250px;\n   font-size: 90%\n}\n\n:-moz-placeholder { /* Firefox 18- */\n   text-align: center;  \n      vertical-align: middle;\n        line-height: 250px;\n\n   font-size: 90%\n\n}\n\n::-moz-placeholder {  /* Firefox 19+ */\n   text-align: center;  \n      vertical-align: middle;\n         line-height: 250px;\n\n   font-size: 90%\n\n}\n\n:-ms-input-placeholder {  \n   text-align: center; \n      vertical-align: middle;\n         line-height: 250px;\n   font-size: 90%\n\n\n}\n\n#compiler{\n\n\n    display: inline-block\n}\n\n#CodeStatus{\n\ntext-align: left;\n\n}\n\n#linebylineOutput{\n\n\n}\n.hello{\n\n\n    text-align: center;\n    margin-top: 2%\n}\n#textarea{\n\n    width: 100%;\n    margin: 0%\n}\n#codearea{\n\n       height: 310px;\n       width: 99%;\n       margin-left: 0\n\n}\n\n#textarea button{\n\nwidth: 20%;\n    height: 30px;\n    font-size: small;\n}\n\n#output{\n\n\n    width: 100%;\n   height: 330px;\n\n    margin-top: 5%;\n}\n#printOutput{\n\n    width: 100%;\n    float: left\n}\n\n#headerlist{\n\n    list-style-type: none;\n    padding: 0;\n    display: grid;\n  \n    width: 100%;\n    background-color: #9cffff;\n    line-height: 40px;\n}\n\n}\n\n\n\n</style>"]}]}